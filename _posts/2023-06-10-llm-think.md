---
layout: post
title:  大语言模型沉思录 Deep Think in LLM
date:   2023-06-10 12:00:00
categories: 大模型
tags: gpt ChatGPT LLM 大模型 AGI 世界模型 系统 快思考 慢思考 灾难 遗忘 幻觉 朱松纯 乔姆斯基 推理 元胞自动机 生命游戏 涌现 可解释 操作系统 可视化 因果推理 世界模型 norm
excerpt: 各个大模型表现究竟怎么样？如何评估大模型表现？LLM真的是AGI吗？
mathjax: true
permalink: /llm
---

* content
{:toc}

# LLM 大语言模型


## LLM 原理

### 讲解


#### 3D交互

【2024-1-24】新西兰软件工程师 [Brendan Bycroft](https://bbycroft.net/) 开发的LLM 3D可视化网站 [LLM Visualization](https://bbycroft.net/llm), 展示 nanoGPT, GPT-2, GPT-3, 动态展示网络结构、运行过程
- 源码可部署： [llm-viz](https://github.com/bbycroft/llm-viz)
- 国内有人汉化，加了引流操作，公众号关注后才能体验, 详见[文章](https://mp.weixin.qq.com/s/pmQh8VtBovVIWigDkjSXMg)


#### LLM 视频

LLM介绍 
- 【2023-11-23】Andrej Karpathy **Intro to Large Language Models**, [video](https://www.youtube.com/watch?v=zjkBMFhNj_g), [pdf](https://drive.google.com/file/d/1pxx_ZI7O-Nwl7ZLNk5hI3WzAsTLwvNU7/view)

<iframe width="560" height="315" src="https://www.youtube.com/embed/zjkBMFhNj_g?si=MB5Exvx750NaPuU5" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>




#### 动图讲解

【2024-1-15】transformer 语言建模，动图讲解：
- 原文：[Generative AI exists because of the transformer](https://ig.ft.com/generative-ai/)
- 译文：[一次性讲透AI大模型的核心概念](https://www.toutiao.com/article/7290571935116050983/)

过程

```py
# (1) 原始句子，来自互联网上大量文本
We go to work by train
# (2) 分词成令牌(Tokens): 编码的基本单位
We, go, to, work, by, train
# (3) 掌握单词(work)的语义, 需要关注上下文,注意邻近词
I have to go work
...
I work in my neighborhood
# (4) work 训练集：正例词集(E.g:roof),负例(E.g:dove)。
work roof, work office # 正例
work dove # 负例
# (5) 向量化: 根据每个词在训练数据中邻近程度来调整向量,称为词嵌入(embedding)。
work roof -> 0.8
work dove -> -0.9
# 词嵌入可以包含数百个值,每个值表示一个词意义的不同方面
work -> [0.1, ..., 0.9]
# 近义词向量的相似度高，如 sea和ocean
# (6) transformer 自注意力(Attention)，同时计算所有单词，而不是RNN的顺序扫描
self-attention
# (7) 规模扩大,自注意力允许LLM获取句子外的上下文(context),更深入的理解句子。
next token prediction
tokenization -> word embedding/positional embedding -> self-attention -> Encoded output
# (8) 模型给每个令牌一个概率分数(probability score),表示序列中下一个词的可能性。
# (9) 循环下去，直至结束：贪心搜索->集束搜索找最佳

```

## 名词

### 章鱼测试

章鱼测试
>- 两位说英语的荒岛幸存者被困在相邻岛屿上，中间隔着危险水域。幸运的是，他们发现了前任居民留下的电报机，电报机通过一条水下电缆连接起来，他们能够通过电报传递信息。
>- 但是，他们不知道的是：附近水域里，生活着一个具备超级智能的章鱼，它劫持了水下电缆并拦截了他们之间传送的消息。尽管章鱼不懂英语，但其超级智能使其能够检测到电报信息文字的统计模式，并能准确表示各种电报信号间的统计关系。
>- 在章鱼觉得自己已经学好这些统计规律之后，它切断水下电缆，将自己两个长触手定位在电缆的两个末端，基于它所识别出来的统计模式，接收并自己来回复两名漂流者的电报信号。无论两位幸存者是否注意到交流对象已发生变化，章鱼发送出去的信息，在本质上似乎没有任何含义。
>- 毕竟，章鱼只是遵循它从人类之间的前期交流中学到的统计模式，而并没有看到过任何人类对信号的解释，比如“椰子”或“海水”所代表的真实含义。此外，章鱼甚至可能都不明白这些信号是具有意义的，或起到了促进交流的功能。“


【2023-12-7】复旦大学张奇教授团队写了一本在线免费的电子书，《大规模语言模型：从理论到实践》，[主页](intro-llm.github.io)，大概有 300 页篇幅，将大模型从理论到实战的每个阶段都描述的较为清楚。
- [LLM-TAP.pdf](https://intro-llm.github.io/chapter/LLM-TAP.pdf)


## 思考

LLM 真的理解语言吗？
- 2019年, 台大用反事实数据集测试BERT，发现效果等同于随机，详见站内 [BERT真的理解了吗](https://wqw547243068.github.io/bert#bert%E7%9C%9F%E7%9A%84%E6%9C%89%E7%90%86%E8%A7%A3%E8%83%BD%E5%8A%9B%E5%90%97)


### LLM 未来趋势

【2024-4-25】

**人工智能发展的快速步伐**

- 下一个 AI 模型，如 GPT-5 比 GPT-4 更强大，这标志着这一领域的快速进步。
- 复制 GPT-4 模型相对容易，真正的挑战是如何引领下一次 AI 能力的重大变革。
- Sam 比较了 AI 的巨大潜力和 iPhone 对移动通信领域的革命性影响。

**走向通用人工智能的道路**

- OpenAI 宗旨是实现**通用人工智能**。对于实现这一目标，开放源代码可能不是最好的策略。
- 通过提供免费且无广告的 ChatGPT，OpenAI 正在努力在追求其目标的同时对社会产生积极影响。为了让每个人都能使用 AI，应该致力于降低 AI 计算成本，并在全球范围内普及其使用，从而消除不平等。
- ChatGPT 作为一种旨在辅助人类的工具，并不需要具备情感功能。
- 对于超级智能 AI，我们无需过度恐慌，因为与未来的模型相比，每一代新模型总有不足之处，这正是不断进步的动力。

**创新与创业机会**

- 仅仅专注于解决当前 AI 的局限可能不够远见，因为未来的模型，如 GPT-5 和 GPT-6，很可能会使现有的努力变得过时。
- Sora 等突破性创新可能会彻底改变娱乐行业，创造出既有电影的情节性又有游戏的互动性的个性化体验。
- 虽然 AI 创业公司大有可为，但成功并非仅仅依靠使用 AI 技术就能保证，还必须坚守商业的基本原则。
- 虽然 AI 在国际象棋等领域可能已经超过了人类，但人们通常还是更喜欢看人类选手的比赛。不过，Altman 也指出了一些反例，例如一些青少年更愿意与 AI 理疗师而非人类理疗师进行对话。

Altman 的演讲提供了对人工智能未来的一种变革性展望，不仅强调了技术进步的速度，还论述了实现通用人工智能的战略，探讨了如何通过创新方法充分利用 AI 的潜力来应对社会挑战，以及人类与 AI 之间不断变化的关系。


### LLM 有意识吗

【2023-10-31】[Open AI首席科学家：ChatGPT可能已经有了意识，AI将万世不朽](https://www.toutiao.com/article/7296014528830571035/)

Ilya Sutskever接受了《麻省理工科技评论》记者Will Douglas Heaven专访，他在采访中谈到了OpenAI早年的创业史、实现AGI的可能性，还介绍了OpenAI未来在管控“超级智能”方面的计划，他希望让未来的超级智能，可以像父母看待孩子那样看待人类。

ChatGPT可能**有意识**（如果你眯起眼睛仔细看的话）。他认为，世界需要清醒地认识到他的公司和其他公司正在努力创造的技术的真正威力。他还认为，总有一天人类会选择与机器融合。

Sutskever说的很多话都很疯狂，但不像一两年前听起来那么疯狂。正如他自己告诉我的那样，ChatGPT已经改写了很多人对未来的预期，把"永远不会发生"变成了"会比你想象的更快发生"。


### LLM=缸中之脑

【2023-7-27】朱松纯：[大模型=缸中之脑？通院朱松纯团队剖析AGI关键缺失](https://mp.weixin.qq.com/s/OUku0k2lRBix5ltREBkT8Q), [论文链接](https://arxiv.org/abs/2307.03762)
- 通用人工智能（AGI）应具备的四个特征：
  - 能够执行**无限任务**
  - **自主生成**新任务；智能体生成新任务需要两个基本机制。
    - 首先，智能体需要一个驱动任务生成的引擎。
    - 其次，智能体需要一个包含真实世界中物理法则和社会规范的世界模型，来指导智能体和真实世界的交互。
  - 由**价值系统**驱动
  - 拥有反映真实世界的**世界模型**
- “知行合一”：大语言模型距离通用人工智能最欠缺的一步
- ![](https://p9.itc.cn/images01/20230727/8d2d1bff80054bd88f50b1707e12a038.jpeg)

大语言模型无异于缸中之脑
- `缸中之脑`由哲学家 `Hilary Putnam` 提出的一个著名**思想实验**，该实验假设人的大脑从身体剥离，放在一个能够维持其机能的营养液缸，由一个超级计算机联结大脑神经元制造出各种幻象，让人觉得一切正常，就像《黑客帝国》所演的那样，那我们该怎么知道自己不是缸中之脑呢？
- 大模型本身并不在真实世界中 (living in the world)，无法像人一样实现从” 词语 (word)“到” 世界 (world)“的联结。这一点是由它的内在构造机制所决定的 —— 通过**统计建模**在大量文本上进行训练，学习文本之间的语言学相关关系，从而根据上个词汇预测下个词汇。
- 缺乏符号落地使得大模型很容易陷入绕圈圈的境地。

研究者尝试给 GPT-4 一个引子，让它跟自己对话，然而在**有限**回合之后，GPT 就开始重复自己说的话，无法跳脱当下的语义空间。
- ![](https://p7.itc.cn/images01/20230727/77077d63dbbf4503b2173f6fae8ec954.png)

大模型的 “智能” 与其说是内在的，不如说是人类智能的投影。大模型生成的文本并不先天具有意义，其意义来自于人类用户对于文本的阐释。

语言学家`乔姆斯基`曾经尝试挑战语言学界构造了一个**符合语法规范但无意义**的句子 —— “无色的绿思狂暴地沉睡”（“Colorless green ideas sleep furiously”），然而 中国语言学之父`赵元任`在他的名文《从胡说中寻找意义》中给予了这个句子一个充满哲思的阐释。

潜在的研究方向：
- 建立**透明**的评估机制和评估系统；
- 创造具有丰富可供性（大量交互可能性）的**仿真环境**；
- 探索一套 “知行合一” 的认知架构，从 “纯数据驱动” 的范式向 “**任务驱动**” 的范式转变。

### LLM 应用构建范式

【2023-8-9】亚马逊科学家[Eugene Yan](https://mp.weixin.qq.com/s/XVH5sCSyGccKt9K8nvkzdA), 大语言模型系统和产品的7个关键模式：
- Evals评估、RAG检索增强生成、Fine-tuning微调、Caching缓存、Guardrails安全栏、Defensive UX防御性用户体验、Collect user feedback收集用户反馈等。

按照提高性能与降低成本/风险的程度以及接近数据与接近用户的程度进行了组织。
- 评估：衡量表现
- RAG：检索增强生成 → 添加最近的、外部的知识
- 微调：提高特定任务的能力
- 缓存：为了减少延迟和成本; [GPTCache](https://gptcache.readthedocs.io/en/latest/), 基于语义相似度判断
  - [GPTCache : A Library for Creating Semantic Cache for LLM Queries](https://github.com/zilliztech/GPTCache)
- 护栏：确保产出质量
  - Anthropic分享了关于设计提示以引导模型生成**有帮助**、**无害**和**诚实**（HHH）回应的信息。使用HHH提示进行Python微调相比使用RLHF微调可以获得更好的性能。
- 防御性用户体验：优雅地预测和处理错误
  - 用户与基于机器学习或LLM的产品进行交互时，可能会发生不准确或产生幻觉等不良情况。
  - 因此提前预测和管理这些问题，主要通过引导用户行为、防止滥用和优雅地处理错误来实现。
- 收集用户反馈：构建数据飞轮
  - 数据——用于预训练的语料库、专家制作的演示、人类对奖励建模的偏好——是LLM产品中为数不多的壕沟之一；用于改进模型、用户偏好个性化、评估整体表现
  - 反馈可以是显式或隐式。
    - 显式反馈是用户对我们产品的请求所提供的信息；
    - 隐式反馈是从用户互动中学到的信息，而无需用户刻意提供反馈。
- ![](https://eugeneyan.com/assets/llm-patterns.png)

详见
- [Patterns for Building LLM-based Systems & Products](https://eugeneyan.com/writing/llm-patterns/)
- [译文](https://mp.weixin.qq.com/s/XVH5sCSyGccKt9K8nvkzdA)


### LLM 应用挑战

【2023-7-26】[盘点大模型在应用上的几大挑战](https://zhuanlan.zhihu.com/p/645515816), 盘点大模型现在面临的16大挑战，论文来自伦敦大学、MetaAI、StabilityAI联合发布70页综述
- 论文 [Challenges and Applications of Large Language Models](https://arxiv.org/pdf/2307.10169.pdf)

大模型面对的挑战主要可以分为三大类：“设计”、“行为”和“科学”，其中，大模型的“设计”与部署前的决策有关，在部署过程中会出现“行为”的挑战，而“科学”的挑战则阻碍了研究大模型的学术进步。
- ![](https://pic4.zhimg.com/80/v2-1598b6790c8b76c320c3129b021a85ab_1440w.webp)

> 利用 LLM 技术时，不能**完全**将决策权交给机器，需要保持对技术的审慎和理性，不盲目依赖机器的意见，而是结合自身的判断和价值观做出决策。


#### 1 不明数据集

由于各团队在扩展预训练的数据量，随着现如今预训练数据集规模的扩大，个人难以完整阅读和检查整个文档的质量。

近年来预训练数据集变得**不可控**，因为大小和多样性迅速增长，而并非所有的数据集都是公开可用的。
1. **近似重复数据**会影响模型性能，而过滤这些数据更加困难，通常在大多数数据收集流程中采用最小哈希算法等方法进行过滤。通过去重处理，可以显著降低模型中重复序列的数量；
1. 对于多任务微调的预训练模型，需要确定适当的**任务混合比例**，通过使用任务说明追加到每个输入-输出对中的方式进行指令微调是一种常见的策略。然而，如何**平衡**任务数据集仍然不清楚。；
1. **模仿闭源模型**的数据收集趋势，但这些模型无法完全模拟专有模型的内容，存在巨大的能力差距。
1. 在训练集中包含与评估测试集**相关或相似的数据**将导致性能指标被夸大，因为模型可能会记住测试数据并在测试中简单地重复它们。此外，预训练数据集中可能存在未检测到的个人身份信息（如手机号码和电子邮件地址），这可能导致隐私泄露。


#### 2 依赖分词器

大语言模型的训练和运行通常依赖于特定的**分词器**，这可能对其性能和适应性产生影响。

`分词`（Tokenization）是将一系列单词或字符拆分为较小单元（即 token）的过程，以便输入模型。其中一种常见的分词方法是`子词分词`（subword tokenization），将单词分解为`子词`或 `WordPieces`。目的是有效处理模型词汇表中的**罕见**和**未登录**词汇，同时限制每个序列的 token 数量，以减少计算复杂性。子词分词器通常通过无监督训练来构建词汇表，并可选地使用合并规则以提高对训练数据的编码效率。

然而，分词的必要性也存在一些缺点：
1. 不同语言传达相同信息所需的 token 数量差异很大，这可能导致基于 token 数量计费的 API 语言模型在许多受支持的语言中过度收费且结果不佳，特别是在这些 API 在本身就较不可负担的地区使用。
1. 分词器和预训练语料库之间的不一致性可能导致错误 token，进而导致模型行为异常。
1. 不同语言的分词方案也面临一些挑战，特别是对于非空格分隔的语言如中文或日文。现有的子词分词方法主要是贪婪算法，试图以尽可能高效的方式编码语言，从而导致对较多语言共享的子词的偏好，不利于低资源语言的 token。
1. 此外，分词器会带来计算负担、语言依赖性、处理新词、固定词汇表大小、信息丢失和人类可解释性等多个挑战。


#### 3 预训练成本高

大型语言模型的训练需要大量的计算资源和时间，这可能会对其广泛应用产生限制。

训练 LLM 的主要消耗是在预训练过程中，需要数十万个计算小时、数百万元的成本，以及相当于数个普通美国家庭年度能源消耗量的能量。而近期提出的缩放定律认为，模型性能随着模型大小、数据集大小和训练中使用的计算量呈**幂律**关系，这种不可持续的情况被称为“红色 AI”。

为了解决这些问题，有两条研究路线：
1. 计算最优训练方法：通过学习经验性的“缩放定律”，以实现在给定计算预算下最大化训练效率；
1. 预训练目标：利用各种目标进行自监督训练，其中不同的预训练目标会影响模型的数据效率和所需迭代次数。
1. 其他研究方向，如并行策略、层叠模型、递增批量大小和最新权重平均等，这些方法在提高模型性能和减少计算成本方面具有一定效果。
  - 预训练目标的选择包括语言建模、掩码语言建模、前缀语言建模、连续区间损坏和混合去噪等。
  - 并行策略是解决训练和推理中巨大 LLM 规模的常见方法，其中模型并行（model parallelism）和流程并行（pipeline parallelism）是两种常见的策略。

#### 4 微调开销

大语言模型的微调通常需要额外的资源和时间，这可能对其快速部署产生影响。

预训练 LLM 时，使用大量且多样化的文本数据可能导致模型在特定任务数据集上无法准确捕捉分布特性。为解决这个问题，使用微调将预训练模型参数适应到特定领域或任务的较小数据集上。这对适应下游任务非常有效，通过直接微调预训练模型或添加可学习层到输出表示中实现。

然而，这也存在一定的问题：
1. 拥有数十亿个参数的语言模型需要大量内存来存储模型参数、模型激活以及梯度和相应统计信息；
1. 内存限制导致无法在单个设备上完成全模型微调，需要使用大型计算集群；
1. 全模型微调在特定任务上效果好，但需要为每个任务存储和加载单独的微调模型，计算和内存开销较大。

近期的研究提出一些方法来降低内存需求，但时间复杂度仍然是个挑战，目前适应 LLM 模型的计算基础设施限制了在小设备上的应用。

为了适应特定数据集或领域，可以使用参数高效的微调方法（PEFT），这是仅更新模型参数的一小部分的方法。
- 一种方法是使用 Adapters，在 Transformer 架构中添加额外的学习层，这些层在微调过程中进行更新，而保持网络的其余部分不变。
- 另一种方法是仅更新模型的偏置项进行微调，这部分参数很小。有几个框架可以将 Adapter 集成到语言模型微调中。
  - 对更大的模型，引入如 prefix-tuning 和 prompt-tuning 方法，通过在输入中添加可学习的 token 嵌入（soft prompts），在微调阶段学习，而模型的其余参数保持不变。这些 soft prompts 的参数较少，存储更加有效。此外，还提出了适用于只具有黑盒 API 访问权限的模型的替代方法。
- 此外还有其他方法，如缩放层激活、内存高效的零阶优化器、低秩自适应等。这些方法改进了内存复杂度，但时间复杂度仍然是一个挑战。即使使用参数高效的微调方法，微调 LLM 仍需要计算完整的前向或反向传播。这限制了在较小设备上进行个性化等潜在应用的可能性。


#### 5 高延迟推理

大语言模型可能需要更长时间来处理输入并生成输出，这可能对其实时应用产生影响。

根据先前研究，导致 LLM 推理延迟高的两个原因是：
- 由于推理过程一次只处理一个 token，导致**并行能力较低**；
- 由于模型大小和解码过程中的**临时状态**（如注意力键和值向量）的缘故，**内存占用量较大**。

作者还讨论了 Transformer 中注意力机制的二次扩展性，以及用于解决这些挑战的技术，包括减少内存占用（大小和/或带宽）、加速特定计算操作。一些加速注意力机制计算的方法包括硬件感知的修改和注意力机制的高级次二次近似。
- **量化**是一种通过降低权重和激活值的计算精度来减少内存占用和/或增加模型吞吐量的后训练技术。
- **修剪**是一种辅助的后训练技术，用于删除给定模型的部分权重，而不会降低性能。
- **混合专家架构**通过同时使用一组专家模块和一个路由器网络来降低推理时间。
- **级联**是使用不同大小的模型对不同查询进行处理的策略，以平衡准确性和计算成本。
- **解码策略**也会对推理的计算成本产生重大影响。

各种框架和库已被设计用于训练和运行大规模语言模型，通过有效实现、降低内存要求或利用分布式计算策略来解决计算成本的挑战。

##### 解决方案

【2024-1-20】[大型语言模型中最大的瓶颈：速率限制](https://www.toutiao.com/article/7325678727781024256)
- [原文](https://www.infoworld.com/article/3712300/the-biggest-bottleneck-in-a-large-language-model.html)

生产环境中严重制约最先进LLM的瓶颈：速率限制。
- OpenAI GPT-4的API调用限制为每分钟3个请求（RPM）、每天200个请求和每分钟最多10000个令牌（TPM）。
- 最高级别允许10000 RPM和300000 TPM的限制。

有些方法可以通过费率限制收费站，但如果没有计算资源的改进，真正的进展可能不会到来。

（1）**绕过速率限制**

完全跳过速率限制技术。

例如，有些特定用途的生成人工智能模型没有LLM瓶颈。
- Diffblue 是一家总部位于英国牛津的初创公司，依赖于不受费率限制的强化学习技术。
- 它以开发人员250倍的速度自主创建Java单元测试，编译速度快10倍。Diffblue Cover编写的单元测试能够快速理解复杂的应用程序，使企业和初创公司都能满怀信心地进行创新，例如，这是将传统应用程序转移到云的理想选择。它还可以自主编写新代码，改进现有代码，加速CI/CD管道，并在不需要手动审查的情况下深入了解与更改相关的风险。还不错。

当然，有些公司不得不依赖LLM。他们有什么选择？

（2）**请多加计算**

一种选择是请求提高LLM服务公司的利率限制。潜在的问题：
- 许多LLM提供商实际上没有额外能力提供服务。
- GPU的可用性取决于从台积电等铸造厂开始的总硅片数量。
- 占主导地位的GPU制造商英伟达无法采购足够的芯片来满足AI工作负载驱动的爆炸性需求，大规模推理需要数千个GPU聚集在一起。

增加GPU供应最直接方法是建造新的半导体制造厂，即**晶圆厂**。但一个新的晶圆厂成本高达200亿美元，需要数年时间才能建成。英特尔、三星铸造、台积电和德州仪器等主要芯片制造商正在美国建造新的半导体生产设施。现在，每个人都必须等待。

因此，利用GPT-4 实际生产部署很少。这样做的范围不大，将LLM用于辅助功能，而不是作为核心产品组件。大多数公司仍在评估试点和概念验证。在考虑费率限制之前，将LLM集成到企业工作流程中所需的提升本身就相当大。

（3）**开源LLM**

许多公司开始使用其他LLM。
- AWS有自己的专门芯片用于训练和推理（训练后运行模型），方便客户。并不是每个问题都需要最强大、最昂贵的计算资源。AWS提供了一系列更便宜、更容易微调的型号，如Titan Light。
- 有的公司微调**开源模型**，比如 Meta的Llama 2。对于涉及检索增强生成（RAG）的简单用例，需要将上下文附加到提示并生成响应，功能较弱的模型就足够了。

（4）**工程技巧**

其它
- 跨多个具有更高限制的旧LLM并行请求
- 数据分块
- 模型提取

（5）**推理加速**

如何让推理更便宜、更快？
- **量化**降低了模型中权重的精度，这些权重通常是32位浮点数字。
- 例如，谷歌推理硬件张量处理单元（TPU）仅适用于权重已量化为八位整数的模型。该模型失去了一些准确性，但变得更小，运行速度更快。
- 一种名为“稀疏模型”技术可以降低训练和推理的成本，而且比蒸馏技术劳动密集度更低。将LLM视为许多较小语言模型的集合。例如，当你用法语问GPT-4一个问题时，只需要使用模型的法语处理部分，这就是稀疏模型所利用的。
- 稀疏训练，只需要用法语训练模型的一个子集进行稀疏推理，只运行模型的法语部分。当与量化一起使用时，这是一种从LLM中提取较小专用模型的方法，LLM可以在CPU而不是GPU上运行（尽管精度损失很小）。
  - GPT-4之所以出名，是因为它是一个通用的文本生成器，而不是一个更窄、更具体的模型。

（6）**硬件优化**

硬件方面，专门用于人工智能工作负载的新处理器架构有望提高效率。
- Cerebras构建一个为机器学习优化的巨大晶圆级引擎
- Manticore正在重新利用制造商丢弃的“被拒绝的”GPU硅来提供可用的芯片。

最终，最大的收益将来自于需要更少计算的下一代LLM。结合优化的硬件，未来的LLM可以突破今天的速率限制障碍。


#### 6 有限上下文长度

大语言模型的处理范围可能受到其上下文长度的限制，这可能影响其理解和生成长文本的能力。

作者在这里重点讨论了解决自然语言处理任务的一些关键问题：
1. 在处理情感识别等任务时，需要考虑更大的上下文。对于包括小说、学术论文等在内的文本段落，仅仅分析几个词语或句子是不够的，必须考虑整个输入的内容。同样，在会议记录中，对某个评论的解读可能会因为之前的讨论而转向讽刺或严肃。
1. 作者评估了一些长上下文模型在处理长文本时的性能，发现许多开源模型虽然声称在处理长上下文时表现良好，但实际上性能严重下降。
1. 限制上下文长度对处理长输入的影响，并介绍了三个允许更长上下文长度的方法：有效的注意机制、位置嵌入方案和不需要注意力和位置嵌入的Transformer替代方法。
  - 有效的注意机制：设计更高效的注意机制来处理长输入，如使用线性嵌套注意机制、等价于点积注意力但占用更少资源的注意机制、Transient Global注意机制、CoLT5和Synthesizer等。
  - 长度推广：作者讨论了位置嵌入的方式，包括绝对位置嵌入和相对位置嵌入，并介绍了RoPE和相对位置偏差等方法。这些方法可以提供更好的长度推广能力，但仍存在一定的挑战。
  - Transformer 的替代方法：作者介绍了使用状态空间模型、卷积和循环神经网络作为 LLM 的替代方案，这些方法在计算效率上具有优势，但仍能保持相对较好的性能。


【2023-11-20】国外某科技大V Greg Kamradt对GPT-4 Turbo进行了压测，结论是：
- 只要问题答案不包含在**开头**，那么 GPT-4 Turbo 并不能保证总能找到答案；
- 更少的上下文长度=更高的准确性，减少向 GPT-4 Turbo 的输入，总会提升其表现（73K后性能下降很快）；
- GPT-4 Turbo 还是偏好于在文档的**开头**与**结尾**寻找答案。

相比 GPT-4，GPT-4 Turbo 的能力有巨大的提升，在上下文长度为 32k 的条件下，GPT-4 Turbo 的平均检索正确 2.4 个人名、城市名与动物名，而 GPT-4 仅为 1.1 个。但是，和 Kamradt 一样，Louis 同样发现，即使是 GPT-4 Turbo，在更大的上下文大小上仍然表现不佳。

斯坦福大学在2023年7月份测试并发布了论文《Lost in the Middle: How Language Models Use Long Contexts》
- 几乎所有大模型都出现了“Lost in the Middle”的现象：中间塌陷问题
- 随着Tokens的长度越来越大，会在中间出现性能（推理速度、准确率等）坍塌。

##### LongLoRA

【2023-10-1】[贾佳亚韩松团队新作：两行代码让大模型上下文窗口倍增](https://www.toutiao.com/article/7284843466167796239)

只要两行代码+11个小时微调，就能把大模型**4k**的窗口长度提高到**32k**。

规模上，最长可以扩展到10万token，一口气就能读完长篇小说的多个章节或中短篇小说。

贾佳亚韩松联合团队提出的这个基于LoRA的全新大模型**微调**方法，登上了GitHub热榜，开源一周时间收获1k+ stars。这种方式叫做 `LongLoRA` ，由来自香港中文大学和MIT的全华人团队联合出品。

在一台8个A100组成的单机上，增大窗口长度的速度比全量微调快数倍。
- [论文地址](https://arxiv.org/abs/2309.12307)
- [GitHub项目页](https://github.com/dvlab-research/LongLoRA)

##### StreamingLLM

【2023-10-6】[StreamingLLM框架问世，号称“可让大模型处理无限长度文本”](https://www.toutiao.com/article/7286763935100240443)

麻省理工学院联合 Meta AI 的研究人员日前开发了一款名为 StreamingLLM 的框架，为大语言模型可能遇到的 RAM 与泛化问题提出了一系列解决方案，号称能够“让语言模型处理无限长度的文本内容”。

StreamingLLM 的研究重点是解决实现**流式语言模型**（Efficient Streaming Language Models，ESLM）的障碍，特别是“长时间互动的多轮对话场景”中可能出现的问题。
- [streaming-llm](https://github.com/mit-han-lab/streaming-llm)
- [Efficient Streaming Language Models with Attention Sinks](http://arxiv.org/abs/2309.17453)
- ![](https://github.com/mit-han-lab/streaming-llm/raw/main/figures/schemes.png)

研究人员指出，这种流式语言模型主要存在两大挑战：
- 第一个挑战：在**解码**阶段，获取 token 的键（Key）值（Value）状态会消耗大量的 RAM。
- 第二个挑战：目前流行的大语言模型，难以泛化适用“超过训练序列长度”的长文本。

过去有许多研究试图解决上述挑战，像是“扩展注意力窗口”，让语言模型能够处理超出预训练序列长度的长文本；或建立一个固定大小的活动窗口，只关注最近 token 的键值状态，确保 RAM 使用率和解码速度保持稳定，但若遇到“序列长度超过缓存大小”时，这个策略就会失效。

而当前流式语言模型最大的挑战是“如何不消耗过多 RAM 且不损害模型性能的前提下，处理长文本输入”。

StreamingLLM 对此采取的策略是“运用**注意力下沉**现象”，研究人员观察到，在自回归语言模型中，无论特定 token 和语言模型本身的相关性如何，如果对代 token 分配了大量的注意力。这些获得高度注意力的 token，就会表现出注意力下沉的现象，即便这些 token 在语义上不重要，但他们仍然获得模型强烈关注（即给予特定 token 内容大量注意力，从而获得模型大部分的关注，而这些特定 token 内容包含“下沉 token 的键值”，从而确保无论输入序列有多长，模型的注意力计算都能维持稳定）

StreamingLLM 的重要贡献在于其提出一个简单且高效的解决方案，使语言模型**不需微调**就可以处理**无限长度**的文本。从而解决当前语言模型在流式应用的困境。虽然未来流式语言模型势在必行，但由于 RAM 效率的限制，以及模型在处理长序列的性能问题，相关模型发展仍受到挑战。

经研究团队证实，StreamingLLM 能够让 Llama 2、MPT、Falcon 和 Pythia 可靠地处理高达 400 万 token 的文本，能够为流式语言模型提供更多部署方面的可能性。


##### 清华 InfLLM

【2024-3-11】[清华NLP组发布InfLLM：无需额外训练，1024K超长上下文100%召回](https://www.toutiao.com/article/7344997939041157647)

超长文本中存在两大挑战：
1. **分布外**长度：直接将LLMs应用到更长长度的文本中，往往需要LLMs处理超过训练范围的位置编码，从而造成Out-of-Distribution问题，无法泛化；
2. **注意力**干扰：过长的上下文将使模型注意力被过度分散到无关的信息中，从而无法有效建模上下文中远距离语义依赖。

清华大学、麻省理工学院和人民大学的研究人员联合提出无需额外训练的大模型长文本理解方法 InfLLM，利用少量计算和显存开销实现了 LLM的超长文本处理。
- 论文地址：[](https://arxiv.org/abs/2402.04617)
- 代码仓库：[InfLLM](https://github.com/thunlp/InfLLM)

InfLLM 在没有引入额外训练的情况下，用一个**外部记忆模块**存储超长上下文信息，实现了上下文长度的扩展。
- InfLLM 无需训练的记忆增强方法，用于流式地处理超长序列。

InfLLM旨在激发LLMs的内在能力，以有限计算成本捕获超长上下文中的长距离语义依赖关系，从而实现高效的长文本理解。
- 外部记忆模块，用于存储超长上下文信息；
- 滑动窗口机制，每个计算步骤，只有与当前Token距离相近的 Tokens（Local Tokens）和外部记忆模块中的少量相关信息参与到注意力层的计算中，而忽略其他不相关的噪声。

整体框架：
- 考虑到长文本注意力的稀疏性，处理每个Token通常只需要其上下文的一小部分。


InfLLM总结为：
1. 在滑动窗口的基础上，加入远距离的上下文记忆模块。
2. 将历史上下文切分成语义块，构成上下文记忆模块中的记忆单元。每个记忆单元通过其在之前注意力计算中的注意力分数确定代表性Token，作为记忆单元的表示。从而避免上下文中的噪音干扰，并降低记忆查询复杂度

InfLLM 能够有效地扩展Mistral、LLaMA的上下文处理窗口，并在1024K上下文的海底捞针任务中实现100%召回。




#### 7 提示脆弱性

大语言模型的回复可能受到提示内容和格式的显著影响，这可能对其稳定性和可预测性产生影响。

提示的**句法**（例如长度、空白、示例的顺序）和**语义**（例如措辞、示例的选择、指令）会显著影响模型的输出。提示的变化也可能会导致输出发生巨大变化，即`提示的脆弱性`（Prompt Brittleness）现象

图示为提示方法的比较。
- ![](https://pic4.zhimg.com/80/v2-529a652b8dda12bef8e40e2d0dbfc377_1440w.webp)
- **单轮提示方法**：通过各种方式改进输入提示以获得更好的单次回答。其中，上下文学习（In-Context Learning）在各种自然语言处理任务中展现出竞争力的结果。这指的是 LLM 通过推理能够仅依靠训练数据的串联来学习新任务，而不需要调整 LLM 的内部工作方式。
  - 提示跟随（Instruction-Following）需要对模型进行监督微调，主要通过在输入提示中添加任务描述性指令来实现。
  - 思维链（Chain-of-Thought）是一种通过一系列中间推理步骤构建少样本提示的技术，最终导致最终输出。
  - 模仿（Impersonation）是一种技术，它要求模型在回答特定领域问题时假装成领域专家。研究发现，提示模型在模仿领域专家时对特定领域问题的回答更准确。
- **多轮提示方法**：通过迭代地连接提示和其答案来生成输出。方法包括 `Ask Me Anything`、`Self-consistency`、`Least-to-Most`、`Scratchpad`、`ReAct` 等。
  - **自动推理与工具使用**（ART）是一种自动生成**多步推理**提示的方法，包括对外部工具的符号调用，如搜索和代码生成或执行。
  - **控制生成**（Controlled Generation）是一种直接修改推理过程的方法，而不是修改输入文本来控制模型输出。在 LLM 中，可以使用无分类器引导采样、提示修改等方法来实现控制生成。

总之，提示的设计和改进对于 LLM 的输出结果具有重要影响，需要进行大量实验来优化提示，并且还有很多提问方法和控制生成方法需要进一步研究和实践。

#### 8 幻觉

大语言模型可能生成与实际情况不符的内容，这可能对其可信度和实用性产生影响。

ChatGPT 常常出现幻觉，即生成不准确的信息，由于文本的流利性，这些错误很难被检测到
- ![](https://pic2.zhimg.com/80/v2-b4a78f021ff1b34c031b46ae91637f91_1440w.webp)

本质幻觉和外在幻觉：
- **本质幻觉**指生成的文本在逻辑上与源内容相矛盾
- **外在幻觉**指无法通过源内容验证输出的正确性，因为源内容提供的信息不足以评估输出结果，因此结果是不确定的。

尽管外在幻觉并不一定是错误的，但由于无法确认提供的信息的真实性，它在一定程度上仍然不可取。

原因
- 传统的解码算法会在<span style='color:red'>每个采样步骤引入均匀随机性</span>，从而导致幻觉的产生。
  - Dziri 等人观察到，回答生成中多样性的增加与幻觉的出现存在正相关关系。

引入随机性和多样性：最有可能的序列通常会导致与人类交流相比较乏味和不自然的文本。Zhang 等人将这个挑战描述为多样性和质量之间的一种权衡。

尽管这个挑战在很大程度上尚未解决，但一些方法，如**多样性束搜索**（Uncertainty-Aware Beam Search）和**自信解码**（Confident Decoding）试图在解码过程中减少幻觉的产生。
- `不确定性感知束搜索`方法基于一个观察结果，即预测的不确定性越高，生成幻觉的可能性越大。因此，在束搜索中引入了**惩罚项**来惩罚解码过程中的高预测不确定性。
- `自信解码`方法则假设**编码器-解码器**模型产生幻觉的原因是在解码时未能正确关注源内容。他们提出了一个基于注意力的置信度评分来衡量模型对源内容的关注程度，并使用变分贝叶斯训练过程确保模型生成高置信度的答案。

#### 9 行为不匹配

大语言模型的行为可能与人类的期望和意图不匹配，这可能对其人机交互的效果产生影响。

**对齐问题**旨在确保 LLM 的行为与人类的价值、目标和期望一致，避免产生意外或负面后果。

如图所示，现有工作可分为两类方法：**检测误对齐行为**和**对齐模型行为**的方法。
- ![](https://pic1.zhimg.com/80/v2-34d77827f84037d564e702031fd404e0_1440w.webp)

预训练与人类反馈（PHF）是一种在预训练阶段引入人类反馈的概念，研究者比较了五种方法，包括过滤、条件训练、非似然、奖励加权回归和优势加权回归。他们发现**条件训练**在训练数据上实现了最好的平衡，但可能存在隐私泄露和在某些应用中使 LLM 变得不安全的风险。

#### 10 知识过时

大语言模型的知识可能随着时间的推移而变得过时，这可能对其应对新情况和新知识的能力产生影响。

在预训练过程中，LLM 所学到的实际信息可能存在不准确或过时的情况（比如无法及时考虑到政治领导层的变动）。然而，重新训练模型需要耗费昂贵的成本，并且在微调过程中很难“遗忘”旧的事实并学习新的事实。

现有的模型编辑技术在更新孤立的知识方面效果有限，这限制了它们在真实世界应用中的适用性。这些应用场景要求仅更新一个错误或过时信息，并且相关信息必须准确地反映这个更新，而不影响其他无关信息。

目前解决这个问题的两种常见方法是：
- **模型编辑**技术：通过修改模型参数或使用外部后编辑模型来改变模型的行为；
- **检索增强**语言模型：利用非参数化的知识源在推理过程中更新以反映底层知识的更新状态。

#### 11 评估脆弱

评估大语言模型的性能可能受到各种因素的影响，这可能导致其评估结果的不稳定和不可靠。

虽然一个模型可能能够轻松解决一个基准问题，却可能在问题稍微变化（甚至只是修改提示）后得到完全相反的结果。与人类不同，我们不容易直观地判断一个语言模型是否具备解决其他相关问题的能力。这导致了对语言模型综合评估的困难，因为需要严格的基准来确定各种输入的弱点。评估过程容易出现脆弱问题，稍微修改基准提示或评估协议可能会导致完全不同的结果。

为了增强基准评估的鲁棒性，全面的基准集试图在所有场景和任务上进行标准化评估，并确保在尽可能多的能力和风险方面进行广泛覆盖。越来越多的模型也开始在人类设计的测试中进行基准化评估，如 SAT、LSAT 和数学竞赛等。

对于传统的基准测试来说，模型对于问题提示或评估方法的选择可能非常敏感。通常情况下，提示的变化也没有进行规范处理，因此模型可能对这种变化非常敏感，比如提示是否添加了“请回答是或否”。Jain 等人发现，规模更大、经过引导微调的模型更容易对提示的微小变化敏感。

#### 12 静态/人工评估

如果评估基于固定和人工编写的标准，可能无法全面、公正地评估大语言模型的性能。

LLM 评估通常依赖于人工编写的“ground truth”文本，但在专业知识的文本往往稀缺。随着模型在某些领域超越人类在基准测试中的表现，无法获得与“人类水平”性能的比较。随着模型能力的提高，旧的基准数据集会变得过时，不再提供有用的信号。社区需要不断适应新的静态基准，同时减少对动态评估的重视，比如对模型输出的人工评估。

为了应对这些问题，一种方法是定期向 BIG-Bench 基准添加新任务，包括进行程序化评估的任务。以下两条研究工作线路使得动态评估在不需要人的情况下成为可能。
- LLM生成的评估任务：随着 LLM 的能力提升，它们可以越来越多地生成有用的基准问题或评估提示。研究表明，LLM 可以用于生成任意维度的静态基准数据集，通过使用基于人类偏好的奖励模型来过滤生成的数据集以确保质量。
- LLM生成的评分：越来越多人使用 LLM 直接对其他模型的性能进行评分，并作为其他模型能力的“裁判”。这个概念的动机是，在许多领域，模型可能很难生成“正确”答案，但评估答案的正确性或判断两个答案之间相对质量往往更容易。然而，这些技术产生的评估结果往往会因为“裁判”模型的不同而有很大差异，并存在鲁棒性问题，不能很好地替代人类判断。

#### 13 文本生成检测

大语言模型生成的文本可能与人类编写的文本相似度极高，这可能导致诸如虚假信息传播等问题。

检测由语言模型生成的文本的重要性体现在防止虚假信息传播、抄袭、冒充或身份窃取以及自动欺诈等方面。然而，随着语言模型流畅度的提高，检测这些文本变得更加困难。

为了解决这个问题，有两种方法：
- **事后检测器**：通过统计不太可能出现的标记来帮助人类检测生成的文本。
- **水印方案**：改变文本生成过程，使其更容易检测。

在事后检测方法中，一些研究探索使用能量模型来区分真实文本和伪造文本，还有人研究使用近似模型对马赛克样本进行判别。在水印方案中，研究者使用隐式模式来标记生成文本，该模式只有计算机能够识别，而人类无法察觉，以便在推理阶段更容易检测出来。

为了避免机器生成的文本被检测出来，可以对生成的文本进行改写，来消除语言模型的特征。研究人员通过训练一个生成近义词的模型，可以重写语言模型生成的文本，保留大致相同的意思，但改变文字或句子结构。对抗这种攻击的方法之一是将模型生成的文本存储在数据库中，并在需要时检索语义上相似的文本。

此外，研究人员还探讨了如何通过多次查询带有水印的语言模型来提取其水印方案，并伪造成被错误分类为模型生成的人类文本的情况。由于水印检测的可靠性不确定，文本检测变得更加困难。

#### 14 规模无法解决的任务

有些任务可能需要更深入、更具针对性的方法，而非仅仅依赖于模型的规模。

LLM 的能力令研究界不断称奇，例如在 MMLU 基准测试上取得高性能，超过了人类预测者的预期。OpenAI 也发布了更新的 GPT 版本，如 GPT-3.5 和 GPT-4，其中 GPT-4 在各种任务上明显优于 GPT-3.5。这些进展引发了对当前的数据或模型扩展范式是否存在克服的限制的质疑。

逆向缩放（IS）是随着模型规模和训练损失的增加，任务性能会变差。某些任务可能不会从进一步的模型或数据集扩展中获益，例如反事实任务。这类任务在改变特定输入输出条件但保持一般推理过程时，LLM 的性能会变差。研究者发现，LLM 对于不常见的反事实条件表现得越差，这被称为“类记忆效应”。作者呼吁进一步研究是否增加模型规模会因为更多的记忆效应而导致性能恶化，还是因为规模优化的预训练方法会扩展数据集，从而包含更多具有不寻常条件的任务。

#### 15 缺乏实验设计

大型语言模型的研究可能缺乏足够的实验设计，这可能对其发现和解决问题的能力产生影响。

首先，如表 2 所示，作者指出许多论文缺乏控制实验，即通过逐个改变一个因素的方式进行实验，这可能是因为所需要的计算成本太高。没有进行控制实验会阻碍对 LLM 性能理解的科学进展。


▲表2 综述中所选的 LLM 概览
其次，LLM 研究的设计空间通常是高维的，这增加了实验的复杂性。为了解决这个问题，作者建议使用贝叶斯优化和维度归约等技术来有效地探索设计空间。

最后，作者还提到 LLM 相比其他领域的模型具有更多的参数，因此计算需求、反馈循环时间和训练成本更高。

#### 16 缺乏可重复性

大语言模型的训练和运行可能缺乏足够的透明度和标准化，这可能影响其结果的可重复性和公正性。

实证结果可重复性对于验证科学主张和排除实验协议中的错误非常重要。在研究人员试图建立在不可重复结果基础上的研究时，可能会浪费资源。然而，在 LLM 研究中存在两个可重复性问题：

训练的可重复性：涉及多个计算节点之间的并行处理。节点之间的调度和通信策略可能是非确定性的，这种变异性可能会影响最终结果，特别是在“非排序不变”算法（如随机梯度下降）中更为明显。此外，由于资金、隐私和法律限制，一些预训练数据集包含用户必须自己爬取的网页内容索引，而非使用静态的独立存档。因此，如果数据集收集者在他们下载数据集时所用的源发生了变化，可重复性就很容易受到损害。
由闭源 API 提供的模型的生成可重复性：是商业 LLM 模型的另一个特殊情况，它们通常在黑盒环境中使用，带来以下挑战：
服务提供者对模型拥有完全的控制权，可以引入未公开的更改，包括重新训练模型、修改参数或完全替换模型；
即使模型更新已经被通知，仍然存在关于是否会继续维持访问特定模型版本的不确定性；
即使将解码温度设置为零，API 模型还经常产生随机输出。有研究人员提供初步证据，证实了 API 提供的模型性能的巨大变化。
因此，API 提供的模型通常是不可重现的。尽管可以依赖开源LLM模型来解决这个问题，但因为算力和资源的限制，目前看来这个方法并不完全可行。





### LLM 真的有智能吗

【2023-6-1】[世界的参数倒影：为何GPT通过Next Token Prediction可以产生智能](https://mp.weixin.qq.com/s/liLVlhzBnQ8WwtvgSYoQkA)

把“章鱼测试”里的章鱼换成 ChatGPT 或 GPT-4，怎么看这个问题呢？
- 一种观点: 与“章鱼测试”看法类似，认为 GPT-4 这种LLM模型仅仅学会了语言中的**单词共现**等浅层的**表面统计关系**，其实并未具备智能，只是类似**鹦鹉学舌**的语言片段缝合怪而已；
  - 代表：除了OpenAI，还有 musk，Hinton，他不仅认为GPT 4具备类人智能，而且觉得将来人类这种碳基智能很可能是LLM这种硅基智能的引导启动程序(Booster)，
- 另外一种: GPT-4 不仅学会了语言元素间的表面统计关系，而且学到了人类语言甚至包括物理世界的**内在运行规律**，文字是由内在智能产生的，所以LLM具备类人智能。
  - 代表： AI大佬是LeCun，语言学界代表人物是乔姆斯基，都否认通过Next Token Prediction这种方式训练出来的大语言模型能够具备智能；


### LLM 是随机鹦鹉吗

【2023-5-28】[数学论证GPT-4不是随机鹦鹉：真如此的话整个宇宙都会坍缩](https://mp.weixin.qq.com/s/NsIaFwDfySNPnrJ2aLR6Fg)

Emily Bender、Timnit Gebru及其同事的著名的批评有关，即
- LLM是“随机的鹦鹉”——粗略地说，它们只是在模仿文本，而不是思考世界。

LLM被训练来最小化字符串匹配中的**预测误差**，但这并不意味着它们的处理只是**字符串匹配**，可能涉及**世界模型**。

随机鹦鹉
- 语言模型只是将其在庞大的训练数据中观察到的语素胡乱拼接在一起，根据概率生成文本，但不清楚文字背后的任何含义，就像一个随机的鹦鹉。
- 出自论文On The Dangers of Stochastic Parrots: Can Language Models Be Too Big

Jacob Bayless的工程师用数学方法得出惊人结论：
>- 根据统计规律预测下一词，所需的信息量50000^8000, 足以让整个宇宙都坍塌成黑洞。
>- 根据`贝肯斯坦上限`(Bekenstein bound)原理，如果把这些信息分配到空间当中，所需要的信息密度已经远超宇宙能承受的最大值。而这仅仅是把数据存储起来的消耗，更不必说还要进行运算了。

GPT-3的token字典中就有超过5万token。如果对每个词都逐一建立统计信息，n-gram模型中n值将高达8000。届时，需要存储的情景数量将达到$50000^8000$。

这是天文数字，足以让整个宇宙坍缩。因此，GPT是“随机鹦鹉”的猜测在理论上得到了一定程度的批驳。

两个实验
- 第一个实验：经典的农夫过河问题，将农夫、船、河分别替换成地球人、虫洞和银河系。狼、羊和菜则分别换成火星人、金星人和月球人。这样现有语料都不存在，可用来判断是否掌握了语言规律
  - GPT-4针对替换后的问题给出了正确的回答，GPT-3.5则没有。但它们并没有犯研究人员预想的“鹦鹉”错误——即在回答中出现狼、船、河等已被替换掉的词语
  - 这些现象都证明了现在的大语言模型的生成方式已经超越了“概率预测”。
- 第二个实验：数字排序。让GPT学习数字排序，究竟是只会记住给出过的数字顺序，还是真的研究出排序算法呢？
  - 从1-100中随机选择10个数字，并将其顺序打乱，将一共有这么多种情形：6.28*10^9
  - 只要GPT能够针对未知的排序问题给出正确的回答，便可以说明它们是真的研究出了排序算法。
  - 用 nanoGPT 做数字排序。结果显示，随着训练步数的增加，模型给出的数字顺序越来越完美。
  - 模型并不是仅仅根据学习的素材对未知的数字进行排序，而是已经掌握了背后的方法。


### LLM 一致性与能力

大型语言模型中的能力与一致性
- 「一致性 vs 能力」可以被认为是「准确性 vs 精确性」的更抽象的类比
- ![img](https://pic3.zhimg.com/80/v2-ea201f656a80f0b8ccbce544ad6f97d6_1440w.webp)

说明
- 模型能力是指模型执行特定任务或一组任务的能力。模型的能力通常通过它能够优化其目标函数的程度来评估。
- 一致性关注的是实际希望模型做什么，而不是它被训练做什么；「目标函数是否符合预期」，根据的是模型目标和行为在多大程度上符合人类的期望。

参考：[深入浅出，解析ChatGPT背后的工作原理](https://zhuanlan.zhihu.com/p/597100830)

### ChatGPT 为什么强

ChatGPT 这么强的原因？
- <span style='color:blue'>因为足够“大”吗？是，但不全是。</span>
  - ChatGPT确实很大，背后模型是一个在有3000亿tokens上预训练的拥有1750亿个参数的大语言模型。但是，ChatGPT并不是目前世界上最大的模型
  - 比如，Google的`PaLM`的参数规模为5400亿，DeepMind的`Gogher`参数规模为2800亿，国内华为`盘古α`的参数规模为2000亿，`百度文心`的参数规模为2600亿。
  - 论参数规模，ChatGPT虽然跻身千亿俱乐部成员，但远远不是最大的那个。
- <span style='color:blue'>因为大量人工标注吗？不是</span>
  - ChatGPT背后的GPT 3.5，仅加入了数万条人工标注数据，相比于其预训练过程使用的3000亿tokens来说，可谓九牛一毛。
  - 目前学界倾向于认为ChatGPT通过海量文本预训练，掌握了基本的语法知识，以及大量世界知识，所谓“**知识注入**”。
  - 比如“地球是圆的”属于常识、或“对位芳纶全球消费量在8-9万吨，国内自给率是20%”属于投研领域专业知识，这些都属于“世界知识”的范畴，都是在模型预训练时注入的。
  - 相对的，人工标注数据，提供的则主要是**人类偏好知识**，比如礼貌的回答是好的，带有歧视性的回答是不好的等等。OpenAI的作者将其戏称为“`对齐税`”（Alignment Tax），即为了使回答满足人类的偏好而牺牲了部分模型的性能。

目前关于ChatGPT模型优秀能力的来源在学界众说纷纭，尚未有定论。但有两种猜想已经得到了绝大多数学者的支持，分别是“**涌现能力**”、以及“**代码训练**”。

邱锡鹏：指令学习加强了语义理解

### LLM 涌现能力

#### 什么是涌现

LLM 的涌现能力定义:
- 「<span style='color:blue'>在小模型中不存在但在大模型中出现的能力</span>」
- 当规模达到一定水平时，性能显著高于**随机**的状态。-- 相变现象

LLM 区别于以前的 PLM 的最显著特征

这种新模式与物理学中的**相变**现象密切相关。


#### 生物现象

【2023-10-1】[什么是涌现？人工智能给你答案](https://mp.weixin.qq.com/s/PmLu2gqDL9Udrf0DCobxjw)

当**蚂蚁聚集成蚁群**时，会展现出一种不可思议的“智能”表现。例如，能够自动发现从蚁群到达食物的最短路径。
- 这种智能表现并不是由于某些个体蚂蚁的聪明才智，因为每只蚂蚁都非常小，不可能规划比它们身长长至少几十倍以上的路径。
- 这种行为是由于许多蚂蚁聚集成一个蚁群，才表现出来的智能。

蚁群发现觅食最短路径包含了以下三点：
1. 蚂蚁找到食物就会释放信息素；
2. 信息素会吸引更多的蚂蚁来聚集，同时信息素也会挥发；
3. 蚂蚁和信息素形成正反馈回路，把路径长短上的细小差异放大，从而筛选出最短路径。

借此大致可以定性地描述涌现发生的机制：**局部作用**产生**正反馈机制**，从而导致宏观上“令人惊异”的现象。

类似的
- 许多小鱼聚成鱼群，便拥有了大鱼一般的威慑力，这是单独一只小鱼所不能拥有的
- 生命游戏：基本元素细胞有着非常简单的交互规则，但当把视点放在全局，却会发现很多有意思的图案（pattern），如静态、周期震荡等
  - 1970年，英国数学家约翰·何顿·康威（John Horton Conway）发明了**元胞自动机**。
- 阿米巴虫：科学家借鉴阿米巴虫的生长来设计城市的交通运输网

这种现象称为**涌现**（Emergence）。

LLM 中的涌现跟自然界中的涌现现象直观上似乎一样，但实际是有差异，因为这里**没有局部正反馈**反映到宏观全局的过程，其背后原因更多和思维链（chain of thoughts）有关

[GPT-4太强，OpenAI也不懂！智能到底是怎么突然「涌现」的？](https://www.toutiao.com/article/7213261622469607992)
- [原文](https://www.quantamagazine.org/the-unpredictable-abilities-emerging-from-large-ai-models-20230316)

内行人也不明白，为什么模型规模在突破某一界限后，突然就「涌现」出了惊人的智能。出现智能是好事，但模型不可控、不可预测、不可解释的行为，却让整个学术界陷入了迷茫与深思。
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/57e02e543e8b4ffcab61659b4f72067f~noop.image?_iz=58558&from=article.pc_detail&x-expires=1680362909&x-signature=piC6%2BOkYbLWM9TzaMmX%2FuvUkV%2BE%3D)

Google Research的计算机科学家`Ethan Dyer`参与组织了这次测试，希望通过204项任务，测试各种大型语言模型能力
- 虽然构建BIG-Bench数据集时已经准备好了迎接惊喜，但当真的见证这些模型能做到的时候，还是感到非常惊讶。这些模型只需要一个提示符：即接受一串文本作为输入，并且纯粹基于统计数据一遍又一遍地预测接下来是什么内容。
- 扩大规模可以提高已知任务的性能，但他们没有预料到模型会突然能够处理这么多新的、不可预测的任务。

`Dyer`最近参与的一项调研结果显示，<span style='color:blue'>LLM 可以产生数百种「涌现」（emergent）能力</span>，即大型模型可以完成的任务，小型模型无法完成，其中许多任务似乎与分析文本无关，比如从乘法计算到生成可执行的计算机代码，还包括基于Emoji符号的电影解码等。[论文](https://openreview.net/pdf?id=yzkSU5zdwD)
- 对于某些任务和某些模型，存在一个复杂性阈值，超过这个阈值，模型的功能就会突飞猛进。
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/83f13abf816c410b8bb37308b6c485d7~noop.image?_iz=58558&from=article.pc_detail&x-expires=1680362909&x-signature=QLNdrMvIxNIcTSGxVAQhU7eKllw%3D)

大模型具有In-Context能力，这种能力不需要针对不同任务再进行适应性训练（微调），用的就是它自己本身的理解力。
- ![](https://qnimg.lovevivian.cn/paper-gpt3-4.jpg)

GPT-3的少样本学习在不同规模模型上的实验对比，提供几个信息：
- X-Shot在不同量级差别巨大，大模型就是有超能力。
- 大模型下，One-Shot效果明显大幅度提升；增加Prompt会进一步大幅度提升。
- Few-Shot的边际收益在递减。大概8-Shot以下时，Prompt作用明显，但从One-Shot到8-Shot，Prompt的作用也在递减。超过10-Shot时，Prompt基本没作用了。

**涌现的涌现**（The Emergence of Emergence）
- 生物学家、物理学家、生态学家和其他科学家使用「涌现」一词来描述当一大群事物作为一个整体时出现的自组织、集体行为。
  - 比如无生命的原子组合产生**活细胞**; 水分子产生**波浪**; 椋鸟的低语以变化但可识别的模式在天空中飞翔; 细胞使肌肉**运动**和心脏**跳动**。
- 涌现能力在涉及大量独立部分的系统中都有出现，但是研究人员直到最近才能够在 LLM 中发现这些能力，或许是因为这些模型已经发展到了足够大的规模。

通过增加模型中的参数数量以及其他因素，Transformer使语言模型的复杂性得以快速扩展，其中参数可以被认为是单词之间的连接，模型通过在训练期间调整这些连接的权重以改善预测结果。模型中的参数越多，建立联系的能力就越强，模拟人类语言的能力也就越强。

OpenAI 研究人员在2020年进行的一项分析发现，随着模型规模的扩大，它们的准确性和能力都有所提高。[论文](https://arxiv.org/pdf/2001.08361.pdf)
- 随着 GPT-3（拥有1750亿参数）和谷歌的 PaLM （可扩展至5400亿参数）等模型的发布，用户发现了越来越多的涌现能力。

与电影Emoji符号任务一样，研究人员没有料到用于预测文本的语言模型可以模仿计算机终端，许多涌现行为都展现了语言模型的Zero-shot或Few-shot学习能力，即LLM可以解决以前从未见过或很少见过的问题的能力。

大批研究人员发现了 LLM 可以超越训练数据约束的迹象，他们正在努力更好地掌握涌现的样子以及它是如何发生的，第一步就是完全地记录下来。

2020年，Dyer 和Google Research的其他人预测，LLM 将产生变革性影响，但这些影响具体是什么仍然是一个悬而未决的问题。他们要求各个研究团队提供困难且多样化任务的例子以找到语言模型的能力边界，这项工作也被称为「`超越模仿游戏的基准`」(BIG-bench，Beyond the Imitation Game Benchmark)项目，名字来源于`阿兰·图灵`提出的「`模仿游戏`」，即测试计算机是否能以令人信服的人性化方式回答问题，也叫做`图灵测试`。

**模型复杂性**并不是**唯一**驱动因素，如果数据质量足够高，一些意想不到的能力可以从参数较少的较小模型中获得，或者在较小的数据集上训练，此外query的措辞也会影响模型回复的准确性。示例：NeurIPS 上发表的CoT思维链技术，[论文](https://neurips.cc/Conferences/2022/ScheduleMultitrack?event=54087)
- **思维链提示**改变了模型的规模曲线，也改变了涌现的点，使用思维链式提示可以引发 BIG 实验中没有发现的涌现行为。

布朗大学研究语言计算模型的计算机科学家Ellie Pavlick认为，这些发现至少提出了两种可能性：
- 第一，如生物系统，大模型确实会自发地获得新的能力，可能从根本上学到了一些新的和不同的东西，而小尺寸模型中没有。当模型扩大规模时，会发生一些根本性的转变。
- 第二，看似突破性的事件可能是一个内部的、由统计数据驱动的、通过思维链式推理运作的过程，大型 LLM 可能只是学习启发式算法，对于那些参数较少或者数据质量较低的参数来说，启发式算法是无法实现的。

涌现导致了不可预测性，而不可预测性也随规模的扩大而增加，使研究人员难以预测广泛使用的后果。

涌现能力的另一个负面影响：
- 随着复杂性的增加，一些模型在回答中显示出新的**偏见**（biases）和**不准确性**。


#### 最新进展

Emergence in science 涌现科学

General defn. in science
> Emergence is a qualitative change that arises from quantitative changes. 量变引起质变

案例
- Given only small molecules such as calcium, you can’t meaningfully encode useful information. Given larger molecules such as DNA, you can encode a genome.
- Popularized by this 1972 piece by Nobel-Prize winning physicist P.W. Anderson.
- With a bit of uranium, nothing special happens. With a large amount of uranium, you get a nuclear reaction.

涌现的问题 Three implications of emergence
- **Unpredictable**. 难以预测
  - Emergence cannot be predicted solely by extrapolating scaling curves from smaller models. 无法通过缩放曲线预测
  - Scaling laws don’t apply for downstream tasks! 缩放定律不适用下游任务
- **Unintentional**. 
  - Emergent abilities are not explicitly specified by the trainer of the language model (next word prediction “only”).
  - In the history of deep learning, has this been true before?
- **One model, many-tasks**. 
  - Since scaling has unlocked emergent abilities, further scaling can be expected to elicit more abilities.
  - Let’s scale more right? (Any undesirable emergent abilities?)

【2023-11-29】Jason wei stanford cs330 talk: [twitter](https://twitter.com/_jasonwei/status/1729585618311950445)
- blog: [Some intuitions about large language models](https://www.jasonwei.net/blog/some-intuitions-about-large-language-models)
- ppt: [Deep Multi-Task and Meta-Learning](https://docs.google.com/presentation/d/1hQUd3pF8_2Gr2Obc89LKjmHL0DlH-uof9M0yFVd3FA4/edit?pli=1#slide=id.g25fd14c24df_3_0)



#### 涌现能力总结

【2023-4-4】LLM 三种代表性的涌现能力：
- **上下文学习**。GPT-3 正式引入了**上下文学习**能力：假设语言模型已经提供了自然语言指令和多个任务描述，可以通过完成输入文本的词序列来生成测试实例的预期输出，而无需额外的训练或梯度更新。
- **指令遵循**。通过对自然语言描述（即指令）格式化的多任务数据集的混合进行微调，LLM 在微小的任务上表现良好，这些任务也以指令的形式所描述。这种能力下，指令调优使 LLM 能够在不使用显式样本的情况下通过理解任务指令来执行新任务，这可以大大提高泛化能力。
- **循序渐进推理**。对于小语言模型，通常很难解决涉及多个推理步骤的复杂任务，例如数学学科单词问题。同时，通过思维链推理策略，LLM 可以通过利用涉及中间推理步骤的 prompt 机制来解决此类任务得出最终答案。据推测，这种能力可能是通过代码训练获得的。


只有大型模型才有的三种突现能力：
- `复杂推理`，大型模型在没有使用全部训练数据的情况下便显著优于以前的小型模型。
- `知识推理`，大型模型可能没有小模型效果好，但大模型不需要额外的知识来源（知识可能很昂贵，或者很难从非结构化数据中抽取）。
- `分布外鲁棒性`，这是之前进行模型精调时需要努力解决的问题。大型模型虽然在同分布情况下的效果不如以前的方法，但非同分布情况下的泛化性能却好得多。

#### （1）复杂推理

下面是一个GSM8K数据集中，用提示词显著超过精调的例子：

```s
问题：
克莱儿每天早饭都用 3 颗蛋做蛋卷，她 4 周会吃掉多少打鸡蛋？

克莱儿每天早饭都用3颗蛋做蛋卷。
一周有 7 天。
所以她一周会吃 3 * 7 = 21 颗蛋。
她4周会吃掉 4 * 21 = 84 颗蛋。
一打里面是 12 颗蛋。
所以 84 / 12 = 7。

答案是7。
```

这道题对于10岁的孩子很容易，但对语言模型却很难，主要是由于**数学和语言混合在一起**。

GSM8K 最初由 OpenAI 于 2021 年 10 月提出。当时用第一版GPT3在全部训练集上进行了精调，准确率约为 35%。这个结果让作者相当悲观，因为结果显示了语言模型的**缩放规律**：
- 随着模型大小呈**指数**增长，性能呈**线性**增长（我之后会讨论）。

因此，第 4.1 节中思考：
- “175B 模型似乎需要至少额外两个数量级的训练数据才能达到 80% 的求解率。”

- 三个月后，即 2022 年 1 月，Wei 等人 基于 540B PaLM 模型，仅使用了8个**思维链提示**示例便将准确率提高到56.6% （无需将训练集增加两个数量级）。
- 在 2022 年 3 月，Wang 等人 基于相同的 540B PaLM 模型，通过多数投票的方法将准确率提高到 74.4% 。当前的 SOTA 来自在 AI2 的工作（Fu et. al. Nov 2022），通过使用复杂思维链在 175B Codex 上实现了 82.9% 的准确率。

从以上进展可以看到，技术进步确实呈**指数级**增长。

思维链提示是一个展示模型随着规模突现出能力的典型例子：
- **突现能力**：尽管不需要 17500B，但模型大小确实要大于 100B ，才能使思维链的效果大于的仅有回答提示。所以这种能力只存在于大型模型中。
- **效果**：思想链提示的性能明显优于其之前的精调方法（目前还没有能公平对比提示词和微调的工作。但当思维链被提出的时候，尽管他们对于提示和精调的比较可能是不公平的，但确实比精调效果要好）。
- **标注效率**：思维链提示只需要 8 个示例的注释，而微调需要完整的训练集。

有些同学可能会认为模型能做小学数学代表不了什么（从某种意义上说，他们确实没有那么酷）。但 GSM8K 只是一个开始，最近的工作已经把前沿问题推向了高中、大学，甚至是国际数学奥林匹克问题。

#### （2）知识推理

下一个例子是需要**知识**的推理能力（例如问答和常识推理）。对大型模型进行提示不一定优于精调小型模型（哪个模型更好还有待观察）。但是这个情况下的注释效率被放大了，因为：
- 在许多数据集中，为了获得所需的背景/常识知识，（以前很小的）模型需要一个外部语料库/知识图谱来检索[13]，或者需要通过多任务学习在增强[14]的数据上进行训练
- 对于大型语言模型，可以直接去掉检索器[15]，仅依赖模型的内部知识[16]，且无需精调

与数学题的例子不同，GPT-3 并没有明显优于之前的精调模型。但它不需要从外部文档中检索，本身就包含了知识（虽然这些知识可能过时或者不可信，但选择哪种可信知识源超出了本文的讨论范围）。

为了理解这些结果的重要性，我们可以回顾一下历史：NLP 社区从一开始就面临着**如何有效编码知识**的挑战。人们一直在不断探究把知识保存在模型外部或者内部的方法。上世纪九十年代以来，人们一直试图将语言和世界的规则记录到一个巨大的图书馆中，将知识存储在模型之外。但这是十分困难的，毕竟我们无法穷举所有规则。因此，研究人员开始构建特定领域的知识库，来存储非结构化文本、半结构化（如维基百科）或完全结构化（如知识图谱）等形式的知识。
- 通常，**结构化知识很难构建**（因为要设计知识的结构体系），但**易于推理**（因为有体系结构），非结构化知识**易于构建**（直接存起来就行），但**很难用于推理**（没有体系结构）。
- 然而，语言模型提供了一种新的方法，可以轻松地从非结构化文本中提取知识，并在不需要预定义模式的情况下有效地根据知识进行推理。

下表为优缺点对比：

| 构建 |	推理 |
|----|--------|
| 结构化知识	| 难构建，需要设计体系结构并解析	容易推理，有用的结构已经定义好了 |
| 非结构化知识	| 容易构建，只存储文本即可	难推理，需要抽取有用的结构 |
| 语言模型	| 容易构建，在非结构化文本上训练	容易推理，使用提示词即可 |

#### （3）分布外鲁棒性

第三种能力是分布外鲁棒性。
- 在 2018 年至 2022 年期间，NLP、CV 和通用机器学习领域有大量关于分布偏移/对抗鲁棒性/组合生成的研究，人们发现当测试集分布与训练分布不同时，模型的行为性能可能会显著下降。
-然而，在大型语言模型的上下文学习中似乎并非如此。Si 等人在2022年的研究显示[17]：虽然 GPT-3 在同分布设置下比 RoBERTa 要差，但在非同分布设置下优于 RoBERTa，性能下降明显更小。
- 同样，在此实验中，同分布情况下基于提示词的 GPT-3 的效果并没有精调后的 RoBERTa要好。但它在三个其他分布（领域切换、噪声和对抗性扰动）中优于 RoBERTa，这意味着 GPT3 更加鲁棒。

此外，即使存在分布偏移，好的提示词所带来的泛化性能依旧会继续保持。

Fu 等人2022年[18]的研究显示，输入提示越复杂，模型的性能就越好。这种趋势在分布转移的情况下也会继续保持：无论测试分布与原分布不同、来自于噪声分布，或者是从另一个分布转移而来的，复杂提示始终优于简单提示。


#### （4）涌现能力推翻比例定律

<span style='color:red'>突现能力推翻比例定律</span>

鉴于上文列出的优点，大家可能会开始觉得大型语言模型确实很好了。再回顾一下之前的工作，就会发现一个很奇怪的问题：
- GPT-3 在 2020 年就发布了，但为什么直到现在才发现并开始思考范式的转变？

这个问题的答案就藏在两种曲线中：`对数线性曲线`和`相变曲线`。图见原文
- ![](https://pic2.zhimg.com/80/v2-6142f0c0df2c189b7f4007ee93745531_1440w.webp)

- 最初，（OpenAI）研究者认为语言模型的性能与模型尺寸的关系可以通过**对数线性曲线**预测，即模型尺寸呈指数增长时，性能会随之线性增加。这种现象被称为语言模型的`缩放定律`，正如 Kaplan 等人在2020年[19]最初的GPT3文章[20]中讨论的那样。重要的是，即便最大的 GPT-3 在有提示的情况下也不能胜过小模型精调。所以当时并没有必要去使用昂贵的大模型（即使提示词的标注效率很高）。
- 直到2021年，Cobbe 等人[21]发现**缩放定律**同样适用于**精调**。这是一个有点悲观的发现，因为它意味着我们可能被锁定在模型规模上——虽然模型架构优化可能会在一定程度上提高模型性能，但效果仍会被锁定在一个区间内（对应模型规模），很难有更显著的突破。
- 在缩放定律的掌控下（2020年到2021），由于GPT-3无法胜过精调 T5-11B，同时T5-11B微调已经很麻烦了，所以NLP社区的关注点更多的是研究更小的模型或者高效参数适应。Prefix tuning[22]就是提示和适应交叉的一个例子，后来由 He 等人在 2021[23]统一。当时的逻辑很简单：如果精调效果更好，我们就应该在高效参数适应上多下功夫；如果提示词的方法更好，我们应该在训练大型语言模型上投入更多精力。
- 2022 年 1 月，`思维链`工作被放出来了。正如作者所展示的那样，思维链提示在性能-比例曲线中表现出明显的相变。当模型尺寸足够大时，性能会显著提高并明显超越比例曲线。当使用思维链进行提示时，大模型在复杂推理上的表现明显优于微调，在知识推理上的表现也很有竞争力，并且分布鲁棒性也存在一定的潜力。要达到这样的效果只需要8个左右的示例，这就是为什么范式可能会转变的原因。

参考：[ChatGPT出来后，我们是否真的面临范式转变?](https://mp.weixin.qq.com/s/q-Ng5uSiR-3EW2Lc6rnr8g)

【2023-2-21】模型应该多大才够？两个数字：<span style='color:blue'>62B 和 175B</span>。
- 模型至少需要62B，`思维链`效果才能大于标准的`提示词`方法。
  - 62B这个数字来自于 Chung 等人 2022 年工作的第五张表
  - 所有小于62B的模型，直接用提示词都好于思维链。
- 模型至少需要175B（GPT3的尺寸），思维链的效果才能大于`精调`小模型（T5 11B）的效果。
  - 理想的尺寸可以小于540B，在 Suzgun 等人2022年[25]的工作中，作者展示了175B的 InstructGPT 和 175B的 Codex 使用思维链都好于直接用提示词。

其他大型模型在思维链下的表现差了很多，甚至不能学到`思维链`，比如 `OPT`、`BLOOM` 和 `GPT-3` 的第一个版本。他们的尺寸都是175B。

两种模型可以做`思维链` (TODO: add discussions about UL2)：
- GPT3系列的模型，包括 text-davinci-002 和 code-davinci-002 (Codex)。这是仅有的两个具有强大突现能力并可公开访问的模型。
- a. 除了以上两个模型，其他GPT3模型，包括原来的 GPT3，text-davinci-001，以及其他更小的GPT-3模型，都不能做`思维链`。
- b. 当说“能做思维链”时，指使用思维链方法的效果比直接用提示词、精调T5-11B效果更好。
- c. 注意: code-davinci-002 在语言任务上的性能始终优于 text-davinci-002。这个观察非常有趣且耐人寻味。这表明基于代码数据训练的语言模型可以胜过根据语言训练的语言模型。
- PaLM系列模型，包括 PaLM、U-PaLM、Flan-PaLM 和 Minerva

详见：[ChatGPT的一小步，NLP范式转变的一大步](https://zhuanlan.zhihu.com/p/595500888)


#### 为什么有涌现能力

【2023-4-4】[涌现能力是玄学吗？](https://www.zhihu.com/question/593496742)

大量个体涌现出单个个体不具备的能力。这是有实验基础的。
- 单个蚂蚁依靠信息素浓度前进，蚁群就有自动寻路的能力，这就是**蚁群算法**。
- 人类遵从简单获取金钱的规则，资本涌现出**羊吃人**的能力。

目前所有解释都是往涌现上一推，似乎问题就混过去了。

GPT 推理能力的产生基于如下原理：
- 记忆是一阶从原始数据到表征数据的相关性连接。
- 推理规则和推理方法本身是二阶记忆内部的相关性连接

小模型在二阶链接上的密度是稀疏的，特定大规模建模可以在二阶连接上超过50%，形成具有连通性的通路，就形成了似乎具备推理能力。

过去所谓的逻辑和原理都是人通过先验知识赋予的似乎不证自明的假设，但是在LLM中，这部分是可以产生的，当然需要正确的调教方法。这挑战了人类几百年来认为是不可动摇的归纳和演绎方法，现在看来归纳和演绎规则并非真正原理，这些其实都是可以解释和可以构造的。

总结一下，就是过去的调教和模型规模，导致其在高阶连接上是稀疏的，而GPT3.5以后高阶相关性的密度达到了全局性联通的边界。所以GPT让人产生了其可以逻辑推理和长程对话的感觉，这是一种表征而已。侧面证明了人类崇拜几千年的逻辑、公理、假设、真理、意义这类东西其实都是语言层面的，不过是形而上学。

从正面看，GPT摧毁了这些虚构的真理，其实是对人类的解放。同时负面看，GPT产生的这类逻辑和推理并非和人类意向完全一致，导致特定全局风险。

[作者](https://www.zhihu.com/question/593496742/answer/2966587547)

大语言模型为什么会产生如此神奇的“涌现能力”呢？
- 【2023-3-6】CoT一作 Jason Wei的ppt [New abilities in big language models](https://docs.google.com/presentation/d/1JyvLrfvLOTfGBWrNl7Gk6Mqn6LIgM2NTeRM2d6oyBow/edit#slide=id.g110339e1e35_0_0)，two new abilities of scale 大模型的两项新增能力
- ① Language models follow instructions. **遵从指令**
  - Finetuned language models are zero-shot learners (ICLR 2022). {J. Wei, M. Bosma, V. Zhao, K. Guu}, A. Yu, B. Lester, N. Du, A. Dai, & Q. Le. 
- ② Language models do chain of thought reasoning. **思维链**
  - Chain of thought prompting elicits reasoning in large language models 
- Emergence and reasoning in large language models - Jason Wei (Google)，[ppt](https://drive.google.com/file/d/1j_CM1fwl_EKB63VlreNUnrKMQsbZHagg/view), [youtube](https://www.youtube.com/watch?v=0Z1ZwY2K2-M)

Chain-of-thought prompting elicits reasoning in large language models (Wei et al., 2022).
- ○ Self-consistency improves chain-of-thought reasoning in language models (Wang et al., 2022).
- ○ Least-to-most prompting enables complex reasoning in large language models (Zhou et al., 2022).
- ○ Language models are multilingual chain-of-thought reasoners (Shi et al., 2022).
- ○ Challenging BIG-Bench tasks and whether chain-of-thought can solve them (Suzgun et al., 2022).

两种猜想已经得到了绝大多数学者的支持，分别是“**涌现能力**”、以及“**代码训练**”。
- （1）大语言模型的**涌现能力**（Emergent Abilities）
  - GPT-3模型其实早在2020年就已经公布，那为什么直到现在才引起大家的充分关注呢？因为2022年前，业界普遍认为GPT模型遵守`Scaling Law`，即<span style='color:blue'>随着模型规模指数级上升，模型性能实现线性增长</span>，所谓服从 `log-linear curve`。实证数据也证明了这一点，当时GPT-3模型的性能并不优于fine-tuned T5-11B 模型。
  - 2022年发生了变化，`CoT`（Chain-of-thought）技术诞生, <span style='color:blue'>直接突破了 `Scaling Law` 的限制，使得大语言模型的性能出现了颠覆式提升</span>。
  - 这项技术其实并不复杂。[图](https://mmbiz.qpic.cn/mmbiz_png/cwUeavcLvr03RJicpcJ0zVdYtvSLbIlDt67iboDFrTAvsC99Lr3pDa9Q6IOmXPlQPKzAgd9XdjIoYaxvNbibVs8zg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
  - ![图](https://pic2.zhimg.com/80/v2-5f91ae17b4e356329fabee97964a3221_1440w.webp)
  - 左侧是一个标准 prompt，模型回答简短且错误的；右侧模型输入加入一个标准的思考过程，然后惊讶地发现，模型的思考能力随之出现了显著提升，能够一步一步得出正确的结果了。
  - 思维链提示在性能-比例曲线中表现出明显的相变。当模型尺寸足够大时，性能会显著提高并明显超越比例曲线。
  - ![](https://image.woshipm.com/wp-files/2023/02/RAPK0MXAYGRvC1zUBS6V.jpg)
  - 这种prompt方式也被称为`one-shot` prompt，与此相对的是`zero-shot` / `few-shot` prompt。当然也可以直接在模型输入的最后，加上“Let's think step by step”来达到类似的效果。[img](https://pic2.zhimg.com/80/v2-5f91ae17b4e356329fabee97964a3221_1440w.webp)
  - ![img](https://pic2.zhimg.com/80/v2-5f91ae17b4e356329fabee97964a3221_1440w.webp)
  - 论文：
    - 2023.1.30, [Specializing Smaller Language Models towards Multi-Step Reasoning](https://arxiv.org/pdf/2301.12726.pdf), This paper addresses the problem of CoT reasoning for smaller models by model specialization. 
- （2）通过代码训练得到的**复杂推理能力**（Complex Reasoning）. 这个能力的奇妙程度相比第一点而言，可以说有过之而无不及。
  - ChatGPT 背后是Text-davinci-002模型，回溯ChatGPT的“模型家谱”，不难发现，Text-davinci-002 模型其实是基于 Code-davinci-002 模型经过指令微调的产物。
  - GPT-3模型复杂推理能力很弱。因为没有接受过代码数据训练
    - GPT-3的一个分支对**代码数据**进行了专项训练，Codex 模型中代码数据量约为 159G，基于此产生的 Code-davinci-002 模型神奇的具备了**思维推理能力**。
  - 不难看出，模型训练过程中，<span style='color:red'>是否引入“代码数据集”很有可能是模型是否具备复杂思维能力的关键变量</span>。

为什么？
- （1）“代码”是一种建立在具备高度**抽象性**和**逻辑性**的思维模式下的“语言”，人类创造了这些语言（C、Python、Java等等），编写了大量代码。现在把这些海量代码喂给大语言模型，模型从对大量代码的学习过程中，逐渐掌握了隐藏在代码背后的**抽象能力**与**逻辑能力**，进而涌现出在ChatGPT上感受到的“智能”。
  - “代码”可以理解为一种具备**高度逻辑性**的文本语料。因为不具备强逻辑性的代码会无法执行，而不像普通文本语料那样有着较高的逻辑自由度。
    - `面向对象编程`（OOP）是把客观世界中的实体抽象为**类**，对象则是类的实例化。对象与对象之间可以互相通信，从而来模拟了现实世界中不同实体之间联系；
    - `面向过程编程`（POP）则是把一个复杂的任务拆分为若干个步骤，然后一步一步加以实现。
- （2）由于代码中含有大量注释信息，<span style='color:blue'>注释信息与代码之间形成了（代码，描述）的数据对，意外的实现了多模态对齐的工作</span>，从而使得模型的推理能力大幅提升。

但是目前已经有大量实证证据表明“涌现能力”真实存在。
- 当模型规模达到某个阈值时，模型对某些问题的处理性能突然呈现快速增长，就像突然解锁了某种特殊能力一般。

最新研究表明，随着模型规模的进一步增长，还可能涌现出各式各样的特殊能力，其中有些能力并不关注（比如5位数加法的准确率大幅提升），但有一些能力则直接解决了NLP领域困扰大家多年的心头大患，比如**复杂推理能力**、**OOD鲁棒性**等。

其实学界每个概念都很直白且容易理解，比如
- OOD鲁棒性: `OOD`指 Out-Of-Distribution，即当**测试**数据集分布显著有别于**训练**数据集分布时，模型性能是否会出现大幅下降。由于现实世界是充满不确定性的，真实环境数据集遵循的分布完全可能发生偏移，因此OOD鲁棒性对于一个语言模型能否投入到真实环境使用而言非常重要。

如此棘手的难题，大语言模型直接通过“涌现能力”意外地解决了。
- 如图所示，GPT-3在OOD情形下显著超过 RoBERTa baseline。

这不禁让我们对未来充满了乐观的预期，随着模型规模的提升，是否会有更多NLP难题自动迎刃而解，“模型规模”难不成就是人类通向AGI（通用人工智能）的钥匙？
- 【2023-2-12】[ChatGPT在投资研究领域的应用初探及原理分析](https://mp.weixin.qq.com/s/lVBrKGthLxjtahYVjnR7jQ)

### LLM 为什么都是 6b/13b/52b...

总结
> scaling law 的指导下，匹配当前的显卡资源和数据资源

- [现在LLM 的大小为什都设计成6/7B、13B和130B几个档次？](https://www.zhihu.com/question/627258986/answer/3260798103?utm_psn=1733426493282344961)

[方佳瑞](https://www.zhihu.com/question/627258986/answer/3261239043)

最大尺寸的版本确定的核心逻辑是: DeepMind的`Chinchilla Scaling Law`。

开发大模型时候，清洗出来的开源数据数量是离散值。
- LLaMA-1预训练时，从各种开源数据集凑够了1.4T的tokens，所以最大的版本是70B，很接近`Chinchilla Scaling Law`的计算结果。
- 用1024张A100，MFU=0.55情况下，训练时长大概是38天，这是一个比较可行的预训练方案。至于更小版本的选型，这个比较随意，主要考虑调试时计算量要控制在一个可控范围，比如一般会选择一个10^22 FLOPs计算量（差不多256卡两三天出结果）下的最优模型尺寸，因此最优尺寸肯定是在10B以内。由于一些矩阵维度的限制，一般都是6B，7B。
- ![](https://pic1.zhimg.com/50/v2-df87270c8e67f83b38b584f720b8cd95_720w.jpg)

当然，`Chinchilla Scaling Law`有些争议，正溯还是得看OpenAI的文章[Scaling laws for neural language models]()，不过过去一年内大家还是会follow这套理论。


[刘聪NLP](https://www.zhihu.com/question/627258986/answer/3260798103)

LLM一般都是基于Transormer结构，**参数总和** = **Embedding部分**参数 + **Transormer-Decoder部分**参数
- Embedding 部分参数由词表大小和模型维度决定；
- Decoder 部分参数由模型层数和模型维度决定。

决定参数的几个因素有：**词表大小**、**模型层数**（深度）、**模型维度**（宽度）。
- 关于词表大小设置，越大的词表的压缩会更好，但可能导致模型训练不充分；越小的词表压缩会比较差，导致模型对长度需求较高。
- 关于层数设置问题，其实模型层数和维度具体设置成多少是最优的（但一般层数变大，维度也会变大），目前没有论文明确表明，但绝大多数感觉跟着GPT3的层数和维度来的。
- ![](https://picx.zhimg.com/50/v2-757af3b0e13e0d76d8bb1c75018a8b44_720w.jpg)

所以常见的模型6/7B是**32层**、13B是**40层**。

PS：由于GPT3模型先出，让OPT、Bloom等都是为了做开源的GPT3所提出的，因此参数规模是一致的。
- llama也是为了对标GPT3，不过为了证明效果更好，也在中间多了33B和65B规模。
- 130B 只有GLM大模型是这个参数。

现在流传甚广的其实是6/7B(小)、13B(中)，主要是由于更大的模型训练成本会更高，并且对于很多人来说13B的模型已经算顶配了（消费显卡跑得了）。


#### Scaling Law 缩放定律

OpenAI的文章 [Scaling laws for neural language models](https://openai.com/research/scaling-laws-for-neural-language-models)
- 【2020-1-23】[Scaling Laws for Neural Language Models](https://arxiv.org/pdf/2001.08361.pdf)

DeepMind 论文
- [Training Compute-Optimal Large Language Models](https://arxiv.org/pdf/2203.15556.pdf) 根据`Scaling Law`，给定计算量（FLOPS）训练出来的最优模型（达到最好模型效果）的训练数据集的token数和模型参数数目是确定的。
- Gopher 模型计算量预算是 5.76 × 10^23 FLOPs，那么达到最优效果的参数量是63B，数据集中Token数目为**1.4T**。
- ![](https://pic1.zhimg.com/50/v2-2d9fd7904ce7c251767a82f586a53a27_720w.jpg)


#### Scaling Law 观点

【2024-4-1】[Scaling Law被证伪，谷歌研究人员实锤研究力挺小模型更高效](https://www.toutiao.com/article/7354993866975805990)
- 论文 [Bigger is not Always Better: Scaling Properties of Latent Diffusion Models](https://arxiv.org/pdf/2404.01367.pdf)

Scaling Law再次被OpenAI带火，人们坚信：“模型越大，效果越好”

但谷歌研究院和约翰霍普金斯大学的研究人员对人工智能 (AI) 模型在图像生成任务中的效率有了新的认识：并非“越大越好”

实验设计 12 个文本到图像 LDM，其参数数量从 3900 万到惊人的 50 亿不等。然后，这些模型在各种任务上进行了评估，包括文本到图像的生成、超分辨率和主题驱动的合成。
- 给定推理预算下（相同的采样成本）运行时，较小模型可胜过较大的模型。
  - 当计算资源有限时，更紧凑的模型可能比较大、资源密集的模型能够生成更高质量的图像。
  - 这为在模型规模上加速LDMs提供了一个有前景的方向。
- 采样效率在多个维度上是一致的

### Yann LeCun：机器学习不是AGI

【2023-3-24】Yann LeCun， 大型语言模型的意义和理解需要感官基础吗? 剧透: 是的!
- 纽约大学深度学习哲学 [The Philosophy of Deep Learning](https://phildeeplearning.github.io/)
- ppt: “[Do large language models need sensory grounding for meaning and understanding?](https://drive.google.com/file/d/1BU5bV3X5w65DwSMapKcsr0ZvrMRU_Nbi/view?fbclid=IwAR2itiKMdM7LbpRs-YSKtLVFrHQLXKEEmNFAMI4xTY0SvROLJwN4bVKhs7M)”
- 【2023-3-27】评论：[GPT-4的研究路径没有前途？Yann LeCun给自回归判了死刑](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650871958&idx=2&sn=0464339517424e3a18041f265551f9f9), Yann LeCun 延续了一贯的犀利风格，直言不讳地指出「Machine Learning sucks!」「Auto-Regressive Generative Models Suck!」最后话题自然是回到「世界模型」

Machine Learning sucks! (compared to humans and animals)
- `Supervised learning` (SL) requires large numbers of labeled samples.
- `Reinforcement learning` (RL) requires insane amounts of trials.
- `Self-Supervised Learning` (SSL) requires large numbers of unlabeled samples.

Most current ML-based AI systems make stupid mistakes, do not reason nor plan

Animals and humans:
- Can learn new tasks very quickly.
- Understand how the world works
- Can reason and plan

Humans and animals have common sense, current machines, not so much (it’s very superficial).

与人、动物相比，机器学习为什么很差？
- 监督学习需要大量标注样本
- 强化学习需要大量试错样本
- 自监督学习需要大量非标注样本

而当前大部分基于机器学习的AI系统常常出现愚蠢错误，不会推理、规划

动物或人：
- 快速学习新任务
- 理解环境运行逻辑
- 推理、规划

人和动物具备常识，而机器表现得很肤浅

Auto-Regressive Large Language Models (AR-LLMs)
- Outputs one text token after another
- Tokens may represent words or subwords
- Encoder/predictor is a transformer architecture
  - With billions of parameters: typically from 1B to 500B
  - Training data: 1 to 2 trillion tokens
- LLMs for dialog/text generation:
  - BlenderBot, Galactica, LLaMA (FAIR), Alpaca (Stanford), LaMDA/Bard(Google), Chinchilla (DeepMind), ChatGPT (OpenAI), GPT-4 ??...
- Performance is amazing ... but ... they make stupid mistakes
  - Factual errors, logical errors, inconsistency, limited reasoning, toxicity...
- LLMs have no knowledge of the underlying reality
  - They have no common sense & they can’t plan their answer

Three challenges for AI & Machine Learning
1. Learning representations and predictive models of the world
  - Supervised and reinforcement learning require too many samples/trials
  - Self-supervised learning / learning dependencies / to fill in the blanks
    - learning to represent the world in a non task-specific way
    - Learning predictive models for planning and control
2. Learning to reason, like Daniel Kahneman’s “System 2”
  - Beyond feed-forward, System 1 subconscious computation.
  - Making reasoning compatible with learning.
  - Reasoning and planning as energy minimization.
3. Learning to plan complex action sequences
  - Learning hierarchical representations of action plans

当前机器学习研究者面前的有三大挑战：
- 一是学习**世界表征**和**预测模型**；
- 二是学习**推理**（LeCun 提到的 System 2 相关讨论参见 UCL[汪军教授报告](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650866823&idx=3&sn=acab8851959257d96ab50ad8d1e48bcd&chksm=84e4c0f9b39349ef5eadf3343495c1c104cb952ab17d5f8e36826530c40fbebbe8ac2783fd1c&scene=21#wechat_redirect)）；
- 三是学习计划复杂的动作序列。


### 正方

#### 苦涩的教训

【2024-2-24】《苦涩的教训》 OpenAI工程师的作息时间，其中有一项就是背诵强化学习之父、加拿大计算机科学家理查德·萨顿（ Richard S. Sutton ）的经典文章《**The Bitter Lesson**（**苦涩的教训**）》。
- 过去 70 年来，AI 研究走过的最大**弯路**，就是过于重视人类既有经验和知识，而他认为最大的解决之道是**摒弃人类在特定领域的知识、利用大规模算力**的方法，从而获得最终胜利。


### 可解释

#### CRATE 白盒 Transformer


【2023-11-30】[「GPT-4只是在压缩数据」，马毅团队造出白盒Transformer，可解释的大模型要来了吗？](https://mp.weixin.qq.com/s/ErrCWbz8zDqSYkC9DH79Mg)

伯克利和香港大学的`马毅`教授领导的一个研究团队给出了自己的最新研究结果：
> 包括 GPT-4 在内的当前 AI 系统所做的正是压缩。

提出的新深度网络架构 CRATE，通过数学方式验证了这一点。
- CRATE 是一种**白盒 Transformer**，其不仅能在几乎所有任务上与**黑盒 Transformer** 相媲美，而且还具备非常出色的**可解释性**。

#### Anthropic 可解释性

【2023-12-1】[Anthropic训练AI拆解LLM黑箱，意外看到了大模型的"灵魂"](https://www.toutiao.com/article/7307507246940914191)

Anthropic可解释性团队论文讲述了通过训练一个新模型去理解一个简单模型的方法。
- [Towards Monosemanticity: Decomposing Language Models With Dictionary Learning](https://transformer-circuits.pub/2023/monosemantic-features/index.html#phenomenology-fsa), 包含交互可视化

新模型能准确地预测和理解原本模型中神经元的工作原理和组成机制。
- 训练了一个非常简单的512神经元AI来预测文本
- 然后训练另一个名为「自动编码器」的AI来预测第一个AI的激活模式。
  - 自动编码器被要求构建一组特征(对应更高维度AI中的神经元数量)，并预测这些特征如何映射到真实AI中的神经元。
- 尽管原始AI中的神经元本身不易理解，但是新的AI中的这些模拟神经元(也就是「特征」)是单义的，每特征都表示一个指定的概念或功能。

Anthropic发表的一项研究声称能够看到了人工智能的灵魂: 成功分解了一个模拟AI系统中的抽象高维特征空间。

#### OpenAI: Transformer Debugger

【2023-5-12】[OpenAI官宣开源Transformer Debugger！不用写代码，人人可以破解LLM黑箱](https://mp.weixin.qq.com/s/RSFvSXUBKOy59zFV79k1BQ)
- 2023年5月，OpenAI团队发布令人震惊的发现：GPT-4竟可以解释GPT-2的三十万神经元！
- 【2024-3-12】OpenAI 超级对齐团队负责人开源内部一直使用的大杀器——`Transformer调试器`（[Transformer Debugger](https://github.com/openai/transformer-debugger)）。
- [论文地址](https://openaipublic.blob.core.windows.net/neuron-explainer/paper/index.html#sec-intro)

功能
- 用TDB工具分析Transformer的内部结构，从而对小模型的特定行为进行调查。
- TDB能支持神经元和注意力头，所以就可通过消融单个神经元来干预前向传递，并观察发生的具体变化。
- 不用写代码，就能快速探索LLM的内部构造

Transformer调试器将稀疏自动编码器，与OpenAI开发的「自动可解释性」——即用大模型自动解释小模型，技术相结合。

可以回答
- 为什么模型会输出token A而不是token B
- 为什么注意力头H会关注token T


#### Patchscopes

【2024-1-12】[开箱黑盒LLM！谷歌大一统框架Patchscopes实战教程来了](https://zhuanlan.zhihu.com/p/694089284)
- 使用LLMs来提供有关模型本身内部隐藏表征的自然语言解释。
- [Patchscopes: A Unifying Framework for Inspecting Hidden Representations of Language Models](https://arxiv.org/pdf/2401.06102.pdf)

Patchscopes统一并扩展了现有的可解释性技术，能够让模型回答出之前无法解决的问题，比如模型可以说出关于「LLM的隐藏表征如何捕捉模型输入中含义的细微差别」的见解和想法，从而帮助开发人员更容易地修复某些特定类型的推理错误。
- ![](https://pic2.zhimg.com/80/v2-ee9797761eeb4c710eb60049fdd8cfad_1440w.webp)


### 世界模型

#### 双系统：快思考 & 慢思考

人脑思维双系统模型理论（Dual Process Theory）

认知心理学名著《**思考，快与慢**》（Thinking, Fast and Slow）中介绍 `双过程理论`（dual propcess theory）。人类认知过程需要两个密不可分的系统，其中
- System 1 负责**快速直觉式**思考 -- 感性
- System 2 则负责**慢速分析式**思考 -- 理性

人类认知过程可分为两个相互关联但独立运作的系统：直觉型思维系统（**系统 1**）和反思型思维系统（**系统 2**）
- **直觉型**思维（系统 1）是一种**快速、直观且自动**的思考方式，主要依赖于个体的**经验、情感和直觉**。
  - 这种方式对于解决**简单**问题和**日常决策**具有较高的效率，但在面临复杂问题和重大决策时可能导致偏差和错误。
- **反思型**思维（系统 2），则是一种**深思熟虑、有意识且理性**的思考方式。该方式通过运用**逻辑推理、规则和分析**，为决策和问题解决提供了更加准确和合理的结果。
  - 然而，这种思维方式需要较多的认知资源和时间。

一些神经科学家包括研究深度学习的科学家提出了 `System 1` 和 `System 2` 的概念, 有`慢思考`（slowthinking）和`快思考`（fastthinking），`慢思考`是比较有**主观**意识的，可以进行规划、推理等。
- System 1 是应激性的、非常快的，同时是没有主观意识的。虽然可以解决一些问题，但无法解决所有问题。

大脑在人进行 System 1、System 2 或无意识、有意识做决策时，是不是用到了同一种机制呢？
- 它在大脑里反映的东西是不是在同一个区域呢？答案是否定的。

人类思维和决策过程并非单一系统所驱动，而是两个系统之间相互作用、互补和竞争的结果。在许多情况下，直觉型思维系统在决策中发挥主导作用；而在需要深入思考和理性判断的场合，反思型思维系统的作用则变得更为重要。

打电话时开车，开车这个动作只激活了大脑的一部分。当要有主观意识时，就变成了**全局性**的，即大脑的所有地方都被激活了。这时用现在的一些手段，比如 EEG、核磁共振大脑切片等，观察大脑哪个地方被激活以及哪个地方没有被激活。可以明显地观察到差别。

【2023-9-11】[大模型为啥这么慢，原来是想多了：新方向是和人一样的思维算法](https://www.toutiao.com/article/7277447969819918906)

弗吉尼亚理工大学和微软的一个研究团队在近日的一篇论文中提出了思维算法（AoT），其组合了直觉能力与算法方法的条理性，从而能在保证 LLM 性能的同时极大节省成本。
- 当前研究则转向了**线性推理**路径，将问题分解成**子任务**来发现解决方案，或通过修改上下文来利用外部机制来改变 token 的生成。
- 早期的 LLM 策略模仿即时的 `System 1`（**快速**反应），特征是通过**脉冲决策**实现。
- 相较之下，`思维链`（CoT）和 `least-to-most prompting`（L2M）等更新的一些方法则反映了 `System 2`（**慢速**思考）的内省式本质。通过整合中间推理步骤，可让 LLM 的算术推理能力获得提升。
- ![img](https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/3287271b37be485b93eefcc51099d8fc~tplv-tt-origin-asy2:5aS05p2hQOacuuWZqOS5i-W_g1Bybw==.image?_iz=58558&from=article.pc_detail&x-expires=1695195866&x-signature=L%2FFFB5bS78GEXXKy74Hha64o3CM%3D)


#### 什么是世界模型

【2024-2-22】[什么是world models/世界模型](https://zhuanlan.zhihu.com/p/661768957)
- OpenAI的介绍材料中称Sora是 “world simulator”

AI领域提到 **世界**/world、**环境**/environment 这个词时，通常是为了与 **智能体**/agent 加以区分。

研究智能体最多领域，一个是`强化学习`，一个是`机器人`领域。
- 因此，world models、world modeling最早常出现在**机器人**领域的论文中。

而world models这个词影响最大的可能是Jurgen 2018年放到arxiv的论文, 以“world models”命名，该文章最终以 “Recurrent World Models Facilitate Policy Evolution”的title发表在NeurIPS‘18。
- 论文没有定义什么是World models，而是类比了认知科学中人脑的mental model，引用了1971年的文献
- Wikipedia中介绍mental model是很明确的指出其可能参与认知、推理、决策过程。
  - mental model 主要包含 mental representations 和 mental simulation 两部分。

论文里的截图
- ![](https://pic1.zhimg.com/80/v2-c842083297df6e7c578ecc3c45680d84_1440w.webp)
- 纵向 V->z: 观测的低维表征，用VAE实现
- 水平的M->h->M->h: 序列预测下一个时刻的表征，用RNN实现
- 这两部分加起来就是World Model。

World model 主要包含**状态表征**和**转移模型**，正好对应mental representations 和 mental simulation。

这不是所有的序列预测都是world model了？
- 熟悉强化学习的同学能一眼看出来，这张图的结构是错误（不完整）的，而真正的结构是下面这张图
- RNN的输入不仅是z，还有动作action，这就不是通常的序列预测了
- ![](https://pic1.zhimg.com/80/v2-76e9b6a8f3aa22b737b293c3b22c6a18_1440w.webp)
- 强化学习里有很多model-based RL，其中的model跟world model一回事儿

model-based RL这个方向长久以来的无奈：
- model不够准确，完全在model里训练的RL效果很差。

这个问题直到近几年才得到解决。
- Sutton 很久以前就意识到model不够准确。
- 在1990年提出`Dyna`框架论文Integrated Architectures for Learning, Planning and Reacting based on Dynamic Programming（发表在第一次从workshop变成conference的ICML上），管这个model叫action model，强调预测action执行的结果。RL一边从真实数据中学习（第3行），一边从model中学习（第5行），以防model不准确造成策略学不好。

world model 对决策十分重要。
- 如果能获得准确的world model，那就可以通过在world model中就反复试错，找到现实最优决策。

world model 核心作用：反事实推理/Counterfactual reasoning
- 即便对于数据中没有见过的决策，在world model中都能推理出决策的结果。

图灵奖得主`Judea Pearl`的科普读物**The book of why**中绘制了一副因果阶梯
- 最下层是“关联”，也就是今天大部分预测模型主要在做的事；
- 中间层是“干预”，强化学习中的探索就是典型的干预；
- 最上层是反事实，通过想象回答 what if 问题。

Judea为反事实推理绘制的示意图，是科学家在大脑中想象，这与Jurgen在论文中用的示意图异曲同工。
- ![](https://pic2.zhimg.com/80/v2-62830c83e6df7db10a4053339e908df9_1440w.webp)

AI研究人员对world model的追求，是试图超越数据，进行反事实推理，回答what if问题能力的追求。这是一种人类天然具备，而当前的AI还做得很差的能力。一旦产生突破，AI决策能力会大幅提升，实现全自动驾驶等场景应用。




A Cognitive Architecture capable of reasoning & planning

LeCun 提出了构建「世界」模型的想法，并在一篇题为《A path towards autonomous machine intelligence》的论文中进行了详细阐述
- [原视频链接](https://www.youtube.com/watch?v=DokLw1tILlw)
- [PPT 链接](https://drive.google.com/file/d/1Txb9ykr03Lda-oTLXbnlQsEe46V8mGzi/view)

构建一个能够进行推理和规划的认知架构。这个架构由 6 个独立的模块组成：
- 配置器（Configurator）模块；
- 感知模块（Perception module）；
- 世界模型（World model）；
- 成本模块（Cost module）；
- actor 模块；
- 短期记忆模块（Short-term memory module）。

这些模块的具体信息参考：[图灵奖获得者 Yann LeCun：未来几十年 AI 研究的最大挑战是「预测世界模型」](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650839081&idx=1&sn=f014b639541de68d7a115aa1ad96b33f&chksm=84e55c57b392d54104e20026682164235cc95892c7313c12bc7219ca0010982de9d3afb6a9db&scene=21#wechat_redirect), 文章中包含视频讲解

#### 如何构建世界模型

如何构建、训练世界模型？
- 未来几十年阻碍人工智能发展的真正障碍是为**世界模型**设计架构以及训练范式。
- 训练世界模型是自监督学习（SSL）中的一个典型例子，其基本思想是**模式补全**。对未来输入（或暂时未观察到的输入）的预测是模式补全的一个特例。

世界只能部分地预测。首先，如何表征预测中的不确定性。一个预测模型如何能代表多种预测？

**概率模型**在连续域中是难以实现的，而**生成式模型**必须预测世界的每一个细节。

基于此，LeCun 给出了一种解决方案：`联合嵌入预测架构`（Joint-Embedding Predictive Architecture，JEPA）。
- JEPA 不是生成式的，因为不能轻易地用于从 x 预测 y, 仅捕获 x 和 y 之间的依赖关系，而不显式生成 y 的预测。

生成式架构会预测 y 的所有的细节，包括不相关的；而 JEPA 会预测 y 的抽象表征。

有五种思路是需要「彻底抛弃」的：
- 放弃生成式模型，支持联合嵌入架构；
- 放弃自回归式生成；
- 放弃概率模型，支持能量模型；
- 放弃对比式方法，支持正则化方法；
- 放弃强化学习，支持模型预测控制。

他的建议是，只有在计划不能产生预测结果时才使用 RL，以调整世界模型或 critic。

与能量模型一样，可以使用对比方法训练 JEPA。但是，对比方法在高维空间中效率很低，所以更适合用非对比方法来训练它们。在 JEPA 的情况下，可以通过四个标准来完成，如下图所示：
1. 最大化 $s_x$ 关于 x 的信息量；
2. 最大化 $s_y$ 关于 y 的信息量；
3. 使 $s_y$ 容易从 $s_x$ 中预测；
4. 最小化用于预测潜在变量 z 的信息含量。

迈向自主式 AI 系统的步骤都有哪些？LeCun 也给出了自己的想法：
- 1、自监督学习
  - 学习世界的表征
  - 学习世界的预测模型
- 2、处理预测中的不确定性
  - 联合嵌入的预测架构
  - 能量模型框架
- 3、从观察中学习世界模型
  - 像动物和人类婴儿一样？
- 4、推理和规划
  - 与基于梯度的学习兼容
  - 没有符号，没有逻辑→向量和连续函数

其他的一些猜想包括：
- 预测是智能的本质：学习世界的预测模型是常识的基础
- 几乎所有的东西都是通过自监督学习得来的：低层次的特征、空间、物体、物理学、抽象表征...；几乎没有什么是通过强化、监督或模仿学习的
- 推理 = 模拟 / 预测 + 目标的优化：在计算上比自回归生成更强大。
- H-JEPA 与非对比性训练就是这样的：概率生成模型和对比方法是注定要失败的。
- 内在成本和架构驱动行为并决定学习的内容
- 情感是自主智能的必要条件：批评者或世界模型对结果的预期 + 内在的成本。

LeCun 总结了 AI 研究的当前挑战：（推荐阅读：[思考总结 10 年，图灵奖得主 Yann LeCun 指明下一代 AI 方向：自主机器智能](http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650849483&idx=2&sn=8fff61962a8a2eb02cda90cdedadf26d&chksm=84e504b5b3928da3f557ec2c0c2ed7edfb3769d33ccad48ab270479949eaddc44bd56d017309&scene=21#wechat_redirect)）
- 从视频、图像、音频、文本中找到训练基于 H-JEPA 的世界模型的通用方法；
- 设计替代成本以驱动 H-JEPA 学习相关表征（预测只是其中之一）；
- 将 H-JEPA 集成到能够进行规划 / 推理的智能体中；
- 为存在不确定性的推理程序（基于梯度的方法、波束搜索、 MCTS....) 分层规划设计推理程序；
- 尽量减少在模型或批评者不准确的情况下使用 RL（这是不准确的，会导致不可预见的结）；

Position paper:
- [A path towards autonomous machine intelligence](https://openreview.net/forum?id=BZ5a1r-kVsf)
- Longer talk: search “LeCun Berkeley” on YouTube

Modular Architecture for Autonomous AI
- `Configurator` 配置器
  - Configures other modules for task
- `Perception` 感知器
  - Estimates state of the world
- `World Model` 世界模型
  - Predicts future world states
- `Cost` 计算不舒适度
  - Compute “discomfort”
- `Actor` 演员
  - Find optimal action sequences
- `Short-Term Memory` 短时记忆
  - Stores state-cost episodes
- ![](https://i0.wp.com/bdtechtalks.com/wp-content/uploads/2022/03/Yann-LeCun-Meta-AI-world-model-architecture.jpeg?w=1392&ssl=1)
- 详见博文：[Meta’s Yann LeCun on his vision for human-level AI](https://bdtechtalks.com/2022/03/07/yann-lecun-ai-self-supervised-learning/)

#### I-JEPA

【2023-6-14】[LeCun世界模型出场！Meta首个“类人”模型，自监督学习众望所归](https://www.toutiao.com/article/7244395665281811005), [META官方](https://ai.facebook.com/blog/yann-lecun-ai-model-i-jepa)

LeCun在公开演讲中，再次批评了GPT大模型：<span style='color:red'>根据概率生成自回归的大模型，根本无法破除幻觉难题</span>。甚至直接发出断言：<span style='color:red'>GPT模型活不过5年</span>。

Meta震撼发布了一个「类人」的人工智能模型 I-JEPA，它可以比现有模型更准确地分析和完成缺失的图像。
- 论文地址: [Self-Supervised Learning from Images with a Joint-Embedding Predictive Architecture](https://arxiv.org/abs/2301.08243)
- 图像联合嵌入预测架构`I-JEPA`模型，是史上第一个基于LeCun世界模型愿景关键部分的AI模型。

自监督学习的通用架构中，系统会学习捕捉不同输入之间的关系。目标是将高能量分配给不兼容的输入，将低能量分配给兼容的输入。

自监督学习的常见架构
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/bcd01573c416423ab32891b8175296c8~noop.image)

这三种架构的区别
- (a) 联合嵌入（不变）架构会学习为兼容的输入x、y输出相似的嵌入，为不兼容的输入输出不相似的嵌入。
- (b) 生成式架构会学习直接从兼容的信号x重建信号y，使用以附加变量z（可能是潜变量）为条件的解码器网络，以促进重建。
- (c) 联合嵌入预测架构学习从兼容信号x中预测信号y的嵌入，使用以附加变量z（可能是潜变量）为条件的预测网络，来促进预测。

划重点：
- I-JEPA 填充缺失片段时，用的就是有关世界的背景知识！而不是像其他模型那样，仅仅通过查看附近的像素。
- I-JEPA就是通过创建外部世界的内部模型来学习。在补全图像的过程中，它比较的是图像的抽象表征，而不是比较像素本身。

在多个计算机视觉任务上，`I-JEPA`都表现出了强大的性能，并且比其他广泛使用的CV模型计算效率高得多

CVPR 2023, 距离提出「世界模型」概念一年多，眼看着LeCun就要实现自己的星辰大海了。训练代码和模型已经开源。
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/62697ade45094eee86c9ec90d5f5e185~noop.image)
- 创造出一个机器，学习世界如何运作的内部模型，更快速地学习，为完成复杂任务做出计划，并且随时应对不熟悉的新情况。

> 联合嵌入架构是人工智能的未来，而不是生成式

#### LLM 是世界模型

【2023-10-18】MIT 的 Max Tegmark 认为有世界模型
- MIT 和 东北大学的两位学者发现 大语言模型内部有一个世界模型，能够理解空间和时间
- LLM绝不仅仅是大家炒作的「`随机鹦鹉`」，它的确理解自己在说什么！
- 杨植麟：“Next token prediction（预测下一个字段）是唯一的问题。”“只要一条道走到黑，就能实现通用泛化的智能。”

【2023-10-20】[再证大语言模型是世界模型！LLM能分清真理谎言，还能被人类洗脑](https://www.toutiao.com/article/7291922903505830436)
- 【2023-10-10】[The Geometry of Truth: Emergent Linear Structure in Large Language Model Representations of True/False Datasets](https://arxiv.org/abs/2310.06824)
- [dataexplorer](https://saprmarks.github.io/geometry-of-truth/dataexplorer)
- MIT等学者的「世界模型」第二弹来了！这次，他们证明了LLM能够分清真话和假话，而通过「脑神经手术」，人类甚至还能给LLM打上思想钢印，改变它的信念。

新发现: LLM还可以区分语句的真假！
- 研究人员建立了简单、明确的真/假陈述数据集，并且把LLM对这些陈述的表征做了可视化。清晰的线性结构，真/假语句是完全分开的，线性结构是分层出现，如果是简单的陈述，真假语句的分离会更早出现，如果是「芝加哥在马达加斯加，北京在中国」这类复杂的陈述，分离就会更晚
  - 第0层时，「芝加哥在马达加斯加」和「北京在中国」这两句话还混在一起。随着层数越来越高，大模型可越来越清晰地区分出，前者为假，后者为真
  - ![](https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7273f53308fb4467b5d0c8267df940b6~tplv-tt-origin-asy2:5aS05p2hQOaWsOaZuuWFgw==.image?_iz=58558&from=article.pc_detail&x-expires=1698506420&x-signature=eGcsdZERd2A7u4tFr5EGKw9ZAsk%3D)

证明了两点——
1. 从一个真/假数据集中提取的方向，可以准确地对结构和主题不同的数据集中的真/假语句进行分类。
  - 仅使用「x大于/小于y」形式的语句找到的真值方向，在对西班牙语-英语翻译语句进行分类时的准确率为97%，例如「西班牙语单词『gato』的意思是『猫』」。
2. 更令人惊喜的是，人类可以用确定的**真相方向**给LLM「洗脑」，让它们将虚假陈述视为真实，或者将真实陈述视为虚假。
  - 「洗脑」前，对于「西班牙语单词『uno』的意思是『地板』」，LLM有72%的可能认为这句话是错误的。
  - 但如果确定LLM存储这个信息的位置，覆盖这种说法，LLM就有70%的可能认为这句话是对的。
  - ![](https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6db3629e7fdb495580f6801f2fc56030~tplv-tt-origin-asy2:5aS05p2hQOaWsOaZuuWFgw==.image?_iz=58558&from=article.pc_detail&x-expires=1698506420&x-signature=xOozb5G6zTvWyAtRE4yTW6kqEpE%3D)

这种办法来提供模型的真实性，减轻幻觉。


### 推理

什么是推理？
- 推理是运用合理的逻辑步骤从现有信息中得出结论的过程。

推理的核心是两个概念: `事实`和`规则`。
- `事实`是描述问题当前状态的信息片段
- `规则`是在特定条件下将事实转化为新事实的函数。

以著名的三段论为例：
> 苏格拉底是一个人。所有人都是会死的。因此，苏格拉底是会死的。

从“苏格拉底是会死的”和“苏格拉底是一个人”这两条事实推理出“所有人都是会死的”这一条规则。后面所说的规则库则包含了众多这样由事实推理出来的规则。

归纳推理就是是从许多**观察事实**中推出**普遍规则**。
- “苏格拉底是人”和“苏格拉底是会死的”这些事实，而这些事实也适用于亚里士多德，那么可能会推出一个规则：“所有人都是会死的”。

而演绎推理的目标是**根据已知的事实和规则推出新的事实**。


#### 简单推理

【2023-10-18】[让大模型真正学会1+1=2！谷歌教会模型自动学习推理规则，大模型的幻觉有救了](https://mp.weixin.qq.com/s/b1rgKoMSvDwegU9oTh5wSQ)

我们通过**数小棍**的方式逐步从 1+1=2，1+2=3 等例子中得出 1+3=4，这是一种依赖记忆中的**数学表格**进行演绎推理的过程。

后来前辈们总结了一套完备的**求和**或**乘法表**，只要背住，做简单算术题根本不成问题，也不需要数小棍

这样一套完备的求和或乘法表可以看做是一套**规则库**，从大量的演绎推理中总结出来的。

如果大模型也掌握了这样一套规则库，那么即使当任务偏离常规知识，大模型也能hold住，大大减少“幻觉”的问题，即减少生成看似合理，但与现实世界知识相矛盾的输出。



##### 谷歌 HtT 框架

谷歌团队提出了一种"Hypotheses-to-Theories"（HtT）框架，让LLMs在推理任务中**自动形成规则库**，来减少语言模型中的"幻觉"现象。
- 论文链接：[Large Language Models can Learn Rules](https://arxiv.org/abs/2310.07064)

HtT方法包括`归纳`阶段和`演绎`阶段，两者都通过少样本提示 few-shot prompt来实现。
- `归纳`阶段，让LLMs为训练集中的问题-答案对生成规则并进行验证，然后根据出现次数和与正确答案的关联频率进行筛选，形成演绎阶段的规则库,即 HtT中的Hypotheses（`假说`）。
- `演绎`阶段，让LLM从规则库中检索适合的规则（Theories 理论）来解决推理问题，以减少LLM生成幻觉的可能性。

对于语言模型LLM，大部分提示技术都是为了引发**演绎推理**。
- 比如，思维链CoT和Less_to_More的提示方法，都是教导LLM如何从给定的事实中推导出结论。这些方法可以归类为**隐式推理**方法，因为依赖于LLM中储存的隐式规则。

而本文直接给出归纳阶段获得的**规则库**（是一种**显示规则**），LLM的主要目标就变成了选择最优的规则与最优的推理顺序。

HtT提示基于两个猜想：
- 尽管LLMs有时会产生错误的规则，但它们能在一部分示例上以合理的概率生成正确的规则。因此，只要有足够的训练示例，LLMs就能找出问题类别中的大部分必要规则。
- 对于LLMs来说，检索规则比生成正确规则更简单。所以，当LLMs被明确的规则引导时，它们在演绎推理方面的表现会更好。

两个对当前的少样本提示方法来说较为困难的多步推理数据集 Arithmetic (数字推理) 和 CLUTRR，在GPT3.5和GPT4两个模型上采用了三种基准提示方法，包括zero-shot CoT,5-shot CoT,5-shot LtM（less is more）进行实验。

**数字推理**
1. 无论是CoT还是LtM的提示，HtT都能显著提升准确性。
2. 特别值得关注的是，HtT在GPT4上使CoT的平均准确性提高了21.0%。

然而，对于GPT3.5，性能提升并不明显，它在诱导正确规则和执行推理阶段的表现较差。

使用强大的模型来诱导规则，然后使用较弱的模型来执行推理，在表中（+HtT(GPT4)）体现。

在从GPT4获取更好的规则后，LtM + HtT有了显著的改进,但是CoT + HtT并没有看到性能的提升，这是因为GPT3.5更倾向于依赖自己的信念（主要是十进制规则），而不是从带有CoT的知识块中检索规规则库。

**关系推理**

数据集选取的是CLUTRR。在CLUTRR中，每个示例都由家庭成员之间的亲属关系链构成，目标是推断链中头实体和尾实体的关系。CLUTRR有两种形式：一种是仅包含实体和关系的符号版本，另一种是包含无关上下文的文本版本。本文对这两种版本进行了HtT评估，并在表2中分别报告了结果：
- 无论是在GPT3.5还是GPT4上，0-shot CoT的表现都是最差的。对于few-shot，CoT和LtM的表现相当。在这其中，HtT的加入都很好的改善这两种提示方法。
- GPT3.5+HtT在检索CLUTRR规则方面并不逊色，而且比起GPT4， GPT3.5涨幅更大，这可能是因为CLUTRR的规则比Arithmetic的规则少。
- 当使用GPT4总结的规则库时GPT3.5+HtT（GPT4），CoT在GPT3.5上的表现提高了27.2%，这是CoT原来性能的两倍多，且接近于CoT在GPT4上的表现。因此，作者认为HtT可能是一种新型的从强到弱的LLM知识蒸馏形式。
- 与监督基准模型EdgeTransformer相比,LLMS+HtT还有所差距，但这个结果是合理的，因为EdgeTransformer利用了前向链接作为强烈的归纳偏见。但HtT相比这类特定领域的监督模型仍然有两个优势：首先，HtT在训练前不需要预定义的关系词汇。其次，HtT学习到的规则可以直接应用于文本输入，无需区分是符号还是文本输入，可扩展到不同领域而无需重头训练模型。

**消融实验**
1. HtT是否能降低规则的幻觉现象？
  - 尽管HtT提升了解决推理问题的整体性能，但还不清楚这种提升是由于减少了幻觉，还是有其他的改进。本文对来自Arithmetic（16进制）和CLUTRR的100个测试示例上的CoT和CoT + HtT的预测进行了手动分析，并将预测结果分为三类：正确、规则幻觉和其他。
2. 模型学习的规则只是对规则空间的提示吗？
  - 在上下文学习中，随机标签的表现与黄金标签相似。如果本文的问题也存在这种情况，那么可以只生成随机规则，而不必依赖HtT来学习规则库。为了探究这个问题，作者在学习规则中用随机答案替换结论。例如，在16进制的数据集中，将5 + A = E替换为5 + A = 7。从表4中可以看到，所及规则使得准确率大大降低，这说明HtT来学习规则库是有必要的。
3. XML标签如何提升演绎推理的能力？
  - 在Arithmetic中使用了三级层次结构，包括进位、第一个加数和第二个加数。在CLUTRR中使用了两级层次结构，包括第一个关系和第二个关系。本文验证了具有不同层次结构的XML标签的重要性。由于XML标签需要规则排序，同时考虑了一种未排序（也就是随机排序）规则的变体。
  - 根据表4的数据，XML标签技巧显著提升了性能。这说明，即使有了好的规则，检索在演绎推理中仍然是重要的能力。因此后续可以进一步微调LLM，以实现更好的检索能力。
4. HtT在归纳阶段需要多少样本呢？
  - 作者还对HtT与样本数量的关系以及所需最小样本数量进行了探索，在归纳阶段使用不同数量的样本。如图4所示：
  - 性能与样本数量之间呈对数线性趋势，这与监督学习的缩放定律是一致的。最小样本数量会因数据集的不同而变化。
  - 在base-16和base-9的数据集上，只需100个样本，CoT + HtT就能超过CoT的表现。而在base-11和CLUTRR的数据集上，至少需要500个样本。
5. HtT能发现多少规则？
  - 归纳阶段本文利用CoT提示生成并验证规则，但由于规则本身的不完美性，LLM可能无法发现所有规则。为了知道HtT能发现多少比例的规则，作者将HtT和包含了示例中所有必要规则的真实规则集合进行比较。


##### ART

【2023-11-28】[大模型没有自我改进能力？苏黎世理工联合Meta AI提出小模型架构](https://www.toutiao.com/article/7306345044045251083)

多位大佬发文指出大模型没有自我改进的能力，甚至自我改进之后，回答质量还会明显下降。
- 因为LLM并不能准确判断原答案是否错误以及是否需要改进。

近日，苏黎世理工与Meta AI提出一种改进大模型推理答案的策略——ART: Ask, Refine,and Trust，该方法通过提出必要的问题来决定LLM是否需要改进原始输出，并通过对初步输出和改进输出进行评估确定最终的答案，在两个多步推理任务GSM8K和StrategyQA中，ART相对于之前模型自我改进的方法，提升了约5个百分点。
- 论文标题：[The ART of LLM Refinement: Ask, Refine, and Trust](https://arxiv.org/pdf/2311.07961.pdf)

分别使用与任务相关的语料训练了两个小模型作为Asker和Truster，其中Asker负责对原始问题与输出提出问题，询问原输出是否已经回答了子问题，如果未正确回答，将流转到一下步改进原输出。第四步使用Truster判断原输出与改进后的输出孰优孰劣，确定最后的结果。



#### 复杂推理

复杂交互式任务（complex interactive tasks）具有很大的挑战性，因为要求 LLM 不仅能理解动态变化的真实场景，还需要具备诸如多种高阶认知和推理能力
- 长期规划（long-horion planning）
- 任务分解（task 的 composition）
- 记忆储存（memorization）
- 常识推理（commonsense reasoning）
- 异常处理（exception handling）。

复杂的交互推理任务，传统智能体训练方法包括
- 1）**强化学习**（Reinforcement Learning）
  - 将交互式推理任务建模为**部分可观察的马尔可夫决策过程**（Partial Observable Markov Decision Process, `POMDP`），智能体通过反复尝试和学习最佳行动策略。常见的方法有 `DRRN`， `KG-A2C`，`CALM` 等。
- 2）**模仿学习**（Imitation Learning）
  - 将交互式推理任务建模为**序列到序列**（Seq2Seq）任务，将过去行动和当前环境观察作为输入，当前的行动作为输出，智能体被训练以模仿人类或专家的行为。Text Decision Transformer 是这个方向的基准方法。
- 3）利用**大型语言模型**（Large Language Model，简称 `LLM`）提示
  - 随着 LLM 的快速发展，尤其是 GPT-4 的出现，将 LLM 应用于复杂的交互式推理任务取得了显著的成果。除了通过传统方法直接让 LLM 根据过往行动和当前环境观察生成行动外，有研究
  - 直接调用 LLM 生成 action 候选池再结合环境重排序（SayCan）
  - 引入虚拟的 "think" 行动来生成子目标以实现更高效的行动（ReAct）
  - 任务失败后利用 LLM 总结原因并生成反思以提高下一次尝试的成功概率（Reflection）等多种方式。
  - ![img](https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/97a50ea6333a42b3a1037fe94988736f~noop.image)

虽然传统方法在简单任务中表现优异，但更复杂和具有挑战性的任务中的泛化能力受限
- 无论是基于**强化学习**的方法还是**行为克隆**（Behavior Cloning），在将大目标分解为多个子任务、实现长期记忆和处理环境中的未知异常（比如在导电性测试中找不到可以使用的灯泡）方面都面临诸多挑战。

LLM 提示方法展示出复杂任务中生成合理计划和根据人类反馈进行调整的能力，但同样存在一些问题和局限性。
- 每次预测行动都需要调用 LLM，导致整体推理效率低下且成本较高。
- 此外，ReAct 和 Reflection 两种方法还要针对每种未知任务类型进行适当的子目标人工标注，否则在现实世界情境中的推广可能会比较困难。

如何将 LLM 生成的计划转化为真实?
- SwiftSage：融合模仿学习与大模型规划的全新框架


##### SwiftSage

【2023-6-15】[LLM+模仿学习，解决真实世界中的复杂任务：AI2提出SwiftSage](https://www.toutiao.com/article/7244800572787589690/)

AI2 (Allen Institute for AI) 的研究人员提出了 SwiftSage 智能体框架。通过`模仿学习`得到一个小型模型，然后将其与 LLM 进行融合。这样可以利用大量数据对小型模型进行微调，使其具备环境和任务相关的知识，并仅在需要时调用大型模型进行高阶推理。
- [论文链接](https://arxiv.org/abs/2305.17390)
- [项目网站](https://yuchenlin.xyz/swiftsage)

受到人脑思维双系统模型理论（Dual Process Theory）的启发，提出一种全新的结合模仿学习和语言模型（LLM）方法的框架 —— SwiftSage
- 将模仿学习和 LLM 方法的优势相互结合，以解决现实世界中的复杂数字任务，展现出了巨大的潜力和前景。

双模块推理系统：迅速决策的 `Swift` + 深思熟虑的 `Sage`

SwiftSage 是一个由两个主要模块组成的框架：**迅速决策**（Swift）模块和**深思熟虑**（Sage）模块。
- Swift 模块: 基于 encoder-decoder 的小型语言模型，它能编码短期记忆内容，例如先前的动作、当前观察结果、已访问的位置以及当前环境状态，并解码出下一步的行动。
  - 该模块模拟了系统 1 中快速、直观的思维特点。它的优势来自于大量的离线数据，通过在模仿学习中采用 behavior cloning 方法，Swift 模块可以充分了解目标环境中的设定以及更好地掌握任务的定义。
- Sage 模块: 类似系统 2 中深思熟虑的思维过程，利用 LLM（例如 GPT-4）来更好地进行规划。
  - Sage 模块包含两个 LLM Prompting 阶段，分别称为规划（planning）和融合（grounding）

为了协调 Swift 和 Sage 模块，研究者们提出了一种**启发式算法**，用于确定何时激活或停用 Sage 模块以及如何有效地将输出与动作缓存机制相结合。
- 默认情况下，智能体通常会采用 Swift 模块。
- 当 Swift 模块遇到困难时（例如，出现如下图的四种情况），智能体会改为执行 Sage 模块产生的动作缓存。

评测
- 30 个任务上的评估中，SwiftSage 的表现超过了之前的 SayCan、ReAct 和 Relfexion 等方法近 2 倍，并且大幅降低了 LLM 部分的计算成本。
- SwiftSage 在 LLM 推理中所需的每个行动的令牌数量大幅减少，因此在成本效益和效率方面，它比单纯依靠 Prompting LLM 方法表现得更为出色。平均来看，为了产生一个行动，Saycan 和 ReAct 需要近 2000 个 token，Reflexion 需要接近 3000 个 token，而 SwiftSage 仅需约 750 个 token。

### LLM 有意识吗

OpenAI Ilya Sutskever 发布一条臭名昭著的推文：
> 这可能意味着今天的大型神经网络具有初步的意识。

几个月后, 谷歌开除了软件工程师Blake Lemoine，他声称在他们的语言模型系统LaMDA 2中检测到了感知能力。这引起了一些头条报道。
- 谷歌: 团队已经审查了Blake的担忧，并告知他证据不支持他的说法。他被告知没有证据表明LaMDA具有感知能力（并且有很多证据反对它）。”

有哪些证据支持大型语言模型（Large Language Model，简称为LLM，下同）可能具有意识？又有哪些证据反对它？

【2023-4-3】[David Chalmers: 大型语言模型可以有意识吗](https://mp.weixin.qq.com/s/zq0UPqXuJuwIWTfD_3MbjA)
- 作者: David Chalmers, 澳大利亚哲学家、认知科学家，专攻心灵哲学、神经科学，纽约大学教授

问题
- 目前的LLM是否具有意识？
- 未来的LLM及LLM+是否可能具有意识？
- 实现具有意识的机器学习系统需要克服哪些挑战？

Thomas Nagel
> 一个生物如果具有某种感觉，那么就可以说是有意识的（或具有主观经验）

Nagel 写过一篇著名的文章《成为蝙蝠是什么感觉？》
- 我们很难确切地知道蝙蝠在使用声纳四处走动时的主观体验是什么样的，但我们大多数人都相信作为一只蝙蝠是有某种感觉的。它是有意识的。它有主观经验。
- 大多数人认为，做一个水瓶不会有任何感觉。瓶子没有主观体验。

意识有许多不同的维度。
- 有与**知觉**相关的感官体验，比如看到红色。
- 有与**感觉**和**情绪**相关的情感体验，比如感觉疼痛。
- 有与**思想**和**推理**相关的认知体验，比如认真思考一个问题。
- 有与**行动**相关代理体验，比如决定采取行动。
- 还有**自我意识**和**自我注意**。

每个都是意识的一部分，尽管它们都不是意识的全部。这些都是主观体验的维度或组成部分。

没有强有力的证据表明当前的LLM是有意识的。尽管如此，他们令人印象深刻的通用能力至少提供了一些有限的初步支持。这足以让我们考虑反对LLM拥有意识的最强烈理由。

## NLP发展

【2024-4-5】[刘群](https://weibo.com/1917491813/5019772179187498)：感慨一下技术进步给研究和教学带来改变和失落：
- 当年我们做NLP研究，要学习很多语言处理的技术，包括word segmentation, POS-tagging, parsing, semantic role labeling, co-reference, RST等等
- 深度学习流行以后，发现这些内容已经没有人感兴趣了，Stanford NLP的课程都抛弃了这些内容。
- 现在大语言模型又带了一轮巨大的变化，看现在的论文，发现很多论文本质上就是做prompt engineering加数据和评测，甚至连机器学习的基础技术都不需要具备，也可以做出很好的工作并在顶会上发表论文。

真不知道这是好事还是坏事

### LLM 时代 NLP何去何从

【2023-6-18】脉脉：[NLP只能做LLM吗](https://maimai.cn/web/gossip_detail/31940198?egid=2a0535dfa08543d590c87f95705396ef&gid=31940198&operation_id=YbqWJ5LswJsiGpT7FylvI&share_channel=2&share_euid=xIzg0vvUrlZY90OoDU4o74eiVcgaIvebMhYHAaiv2szYLE2rY_IWkCIY3llDXJIB)，[小红书地址](https://www.xiaohongshu.com/explore/641d48e0000000000800c757)

总结
- 果断甩掉包袱（过时技术）
- 深刻认知GPT的强大
  - 亲自体验GPT，掌握一手资料
  - 从小模型开始一步步验证
- 思考下一步：有模型、资源后能做什么
- 避开OpenAI正面竞争，寻找共赢，站在巨人肩膀上
  - 不做OpenAI已经做到、懒得做的事情
  - 做OpenAI想做但还没做到的事情
- 尽力争取资源：多卡，哪怕换导师、实验室甚至从学界切换到工业界
- 加强工程能力
  - science 和 engineering 和 product 三合一

<span style='color:blue'>LLM 时代，学术界 Dos and Don'ts</span>

- 不要背**历史包袱**
  - 如果自己的工作被颠覆了，直接扔掉，不用可惜，不要浪费时间续命
  - 旧技术必定被新技术颠覆，这是历史必然
- 不要做 OpenAI **已经做到**的事情，不要做OpenAI 能做只是**懒得做**的事情
  - 否则会被 OpenAI 降维打击
- 深刻地认识 GPT 的强大
  - 对 GPT 的负面批评，很多时候都是错的，这不是大模型的缺点，而是批评者对于大模型认知浅薄所致
  - 自己变成一个熟练的prompt engineer，花个一两周时间天天prompt GPT，这样才知道哪些不行，哪些只是觉得不行但其实它行
- 假设已经有了 GPT-3.5 **基础模型**，假设自己有**1k张卡**，思考能做什么
  - 用小模型（如LLaMA 7B）去验证，如果成功，再慢慢加大到 13B-30B，画出一条上升的曲线
  - 不一定要 scale 到最大的模型，只要自己的结论能够画出一条上升曲线，那么可以外推更大范围
- 做一点 OpenAI **想做但还没做到**的事情
  - 去 prompt GPT，看看哪里做不好，思考怎么做让它更好
- 哪些事情是 OpenAI **很难做到**的事情
  - 面向未来，思考哪些问题即使把现有技术全部拉满，依然做不好，然后去尝试解决这些问题
- **搞卡**
  - 无论如何都要有八卡 A100
  - 如果**导师**不给，可以考虑换导师
  - 如果**实验室**不给，可以考虑换实验室
  - 如果**学术界**怎样都没有，可以考虑换到**工业界**
- 不要再 care 刷 paper，只发最低数量能毕
  - 如果一篇能毕业，发一篇就行，如果三篇毕业，发三篇就行
  - 但是发出来的 paper一定要**保证质量**，尽量做到每篇 paper 质量**单调上升**
  - 不要把时间花在与 reviewer 相互拉扯上面，要把时间花在真正有意义的事情
- 加强**工程能力**，加强工程能力，加强工程能力能
  - 水 paper 但代码写得差的人非常多;
  - 代码写得好的 research 怎样都不会差
- 不要再纠结 science 和 engineering 和 product 的区别
  - 在现代 LLM 的视角下，这几个是**三位一体**

### LLM 研究方向

【2023-9-24】详见知乎专题总结：[大模型LLM领域，有哪些可以作为学术研究方向？](https://www.zhihu.com/question/595298808/answer/3206297142)

## LLM 问题

斯坦福 CS224N 课程
- ICL中的Zero-Shot Learning（零样本学习）和Few-Shot Learning（少样本学习）
- Instruction Finetuning 指令微调
- RLHF
  - 人工（human-in-the-loop）昂贵 → 建模人类偏好变成独立的NLP问题
  - 人工评判有噪声、错误 → 将集合直接排序问题变成pair-wise（点对）的对比问题，更可信
  - 优点：直接建模人类偏好，易于泛化
  - 问题：人类偏好不可信，据此建立的模型偏好更不可信
    - RL里常见问题是奖励破解（reward hacking）
    - 模型被鼓励输出看似权威、有用但枉顾事实的结果，导致编造事实、出现“幻觉”(hallucination)
    - 因此，模型的错误对齐问题值得研究
  - 改进：
    - RL from AI feedback
    - Finetuning LMs on their own outputs

|技术点|介绍|优点|缺点|
|---|---|---|---|
|ICL小样本学习|ICL中的零样本和少样本|不需要微调，只需提示工程、CoT就能提升效果|① context输入限制 <br>② 复杂任务还是需要梯度更新|
|指令微调|通过指令集进行参数更新|简单直接，容易泛化到新任务|① 众多任务的示例数据收集成本高<br>② LM优化目标与人工偏好错配|
|RLHF|基于人类反馈的强化学习训练|直接建模人类偏好，易于泛化|① 人类偏好不可信，据此建立的模型偏好更不可信<br>② 模型被鼓励输出看似权威、有用但枉顾事实的结果，导致编造事实、出现“幻觉”(hallucination)|
|||||

### 总结

|问题|介绍|思路|备注|
|---|---|---|---|
|幻觉|有时会编造事实|引入事实信息矫正？||
|ICL不受控|prompt里的作答要求不一定起作用|||
|prompt模板瓶颈|回复质量严重依赖prompt模板|||
|agent|agent不可控|||
|||||
|||||


### 九问中国大模型掌门人

【2023-11-8】[九问中国大模型掌门人](https://mp.weixin.qq.com/s/2_2CBSGF0sJo7O80_AtRsQ)

「九问中国大模型掌门人」重磅对话。
- 主持人：王咏刚，SeedV 实验室创始人兼 CEO，创新工场 AI 工程院执行院长
- 张家兴，封神榜大模型，IDEA 研究院
- 张鹏，GLM 大模型，智谱 AI 
- 李大海，CPM 大模型，面壁智能
- Richard，百川大模型，百川智能
- 王斌，MiLM 大模型，小米集团
- 康战辉， 腾讯混元大模型

从模型技术、算力基建、开源开放、商业化四个方向
- 基础大模型发展的技术突破口是什么？
- Transformer 未来将如何演进？
- 如何让大模型远离「幻觉」，安全可控？
- 自研的 AI 算力基建与服务如何发展？
- 大模型的开源生态如何发展？
- 自研大模型如何取得领先地位？
- 如何看待互联网大厂与创业公司之间大模型的竞争？
- 大模型如何在行业落地，实现商业化？
- 套壳 ChatGPT 的产品有价值么，大模型 C 端应用，机会在哪里？


#### 基础大模型发展的技术突破口是什么？ 

张鹏（GLM 大模型）
- 大模型最强的就是认知能力，比过去所有的模型能力都要强，强于上一代**判别式**模型的能力
- 跨模态能力对于突破模型认知上限很关键，因为语言是抽象的、人造的，自然界不存在的东西。
- 如何把这些**跨模态**能力综合打通，是真正迈向人类大脑认知能力的关键。

王斌（MiLM 大模型）：
- 大模型真正要使用或发展，得有**逆向思维**，就是将**大模型小型化**。
- 小米通过「轻量化」和「本地化」部署，让模型在保持相当能力的同时，能够变小、降低使用成本，让更多用户得以使用。

张家兴（封神榜大模型体系）：
- 目前有很多通用预训练大模型，但到具体场景中，仍需继续微调。
- 基础大模型达到高中或大学毕业生的知识水平，但需要持续学习，才能让其在实际场景中掌握具体技能，这就是对齐技术。
- 寻求突破，有两点很重要。
  - ① 对齐技术，在未来能否不依赖于梯度下降。
    - 传统机器学习基于梯度下降实现自动化训练系统。但梯度下降带来很大的不稳定性，且极难实现自动化。
    - 人脑中并没有这样的机制，并不是靠梯度下降的逻辑来学的，至少说不完全依赖梯度下降机制。
    -  ICL（In-Context Learning）是非梯度下降探索的一个方向。
  - ② 能否实现一种彻底无人、没有老师提示的学习方式。
    - 设想：能否让多个模型完全形成闭环，互相教导对方。当多个模型达成自洽时，所形成的知识和技能就是我们想要的。
    - 人类社会就是这样，并没有上帝教授人类知识，但人类已经形成闭环和自洽，到达目前的知识水平，大模型是否能具备这样的技术。
- 第一点技术已经有雏形，第二点无人学习方式，会更科幻一点

李大海（CPM 大模型）：
- 同意家兴老师让模型实现**无人学习**的观点，该方向没有那么快实现，当下比较可行的是 **Agent方式** 推进。
- 人类本身具有快和慢的思维，将问题对应到模型中。现在模型通过问答的方式，用文字组成回答。尽管逻辑上一致，但实际上在答案生成过程中，通过 COT（Chain of Thoughts）等方式，让回答质量变得更高。
- 那么基于 Agent 技术将规划做得更好，再将各种技术应用起来，使得能将场景中任务得到更好的拆解和分步交付。打通 Agent 环节需要大模型自身结合外部框架一起实现，大模型本身也需要有相应的数据来训练，让能够有效地了解 Agent 在场景中的具体行为。
- 在未来一两年内，用较小的模型能够做到大参数模型的效果，是一个可以探索和突破的方向。

康战辉（腾讯混元大模型）：
- 目前大模型还不够成熟，主要聚焦两个问题。
- 第一，现在大模型更适合**任务难度较低、容错率较高**的场景。
  - 例如闲聊，闲聊的场景没有预期，能聊天就好。
  - 但如果涉及到专业翻译、客服或做一些个人助理这类复杂任务，目前大模型还不能满足需要，本质上还是大模型本身存在**幻觉**。
- 第二，刚才没有提到现阶段技术对复杂程度的跟随能力。
  - 人与人之间的交互，不可能像人机一样，每句话只有一个指令。很多时候是复杂的指令，包括多模态。人类的交互也不仅仅通过语言，这也是个挑战。
- 架构上的突破，学界已经进行了许多探索。未来应该两个架构走向统一，模型通过一个架构实现能听会说、能读会写的功能和服务。

Richard（百川大模型）：
- OpenAI 角度，从人类目前大模型技术最高水平看下一步的突破。
  - Ilya（Ilya Sutskever，OpenAI 首席科学家）说如果能做到预测 Next Token，就离通用人工智能不远了。OpenAI 正在做的 GPT-5，号称把十万台 GPU 连在一起，预测 Next Frame（下一帧），如果得以实现，大模型的技术会进一步突破。
- 站在近期国内模型应用落地的视角，面临两个必须要突破的点：
  - 一是如何解决大模型的幻觉问题。大模型在行业落地过程中，准确率是最受关注的问题。如何利用好大模型能够压缩人类知识的优势，同时由于人类知识是持续变化的，需要与搜索引擎进行更深入的联合，让模型技术在原生状态下更好解决幻觉，是未来行业落地中亟需突破的点。
  - 二是可以把大模型看作人或计算机，它有内存（短期记忆）和硬盘（长期记忆），对应到模型中就是上下文窗口，Claude 目前突破了 100K，我们也推出了超过 100K 的上下文长窗口模型。



#### Transformer 未来将如何演进？  

大模型都脱胎于名为 Transformer 的核心算法。近年，Yann LeCun 等学者也经常提出非常新颖且独特的科研方向，许多中国和美国等世界各地的科研工作者也在尝试优化，甚至彻底改变 Transformer 架构。

那么未来，架构该如何发展？

张家兴（封神榜大模型体系）：
- 大模型领域要区分两个方向
  - 一是设计**模型结构**，Transformer 架构自 2017 年提出，到现在已经有六年了，但还是如日中天，也是很罕见的。
  - 另一条路是**训练**层面，模型如何持续学习，也是刚才提到的对齐技术，是在训练层面的科研方向。

那么 Transformer 的结构已经有 6 年历史了，如果它被取代，一定是 Transformer 模型结构遇到了**无法解决的问题**，但又极其紧迫。就像当年Transformer 提出来时，是为了解决 LSTM 太慢的问题。

Transformer 已经证明了能够支撑足够大参数量的模型，那还有什么问题呢？
- 比如幻觉问题，是否 Transformer 的模型结构就是容易产生幻觉？

无论 100k 的上下文窗口，还是 1 million 的上下文窗口，都是 Working memory，而不是 Long-term memory。

下一代模型结构，的确现在不知道是什么样子。但是，它的出现一定能解决现在 Transformer 结构无论如何解决不了的问题。

在这方面的探索中，我们和大海的方向是相同的，可能采用 **Agent 的方式**来解决问题，但如果模型结构能够解决，那将是最好的方案。


王斌（MiLM 大模型）：
- 学术界大部分工作还是围绕如何提高 Transformer 的**效率**展开。
  - 比如，如何简化注意力机制的计算，如何降低 FNN 的维数，如何对参数矩阵分解来用更小的矩阵代替大矩阵。
- 但真正要从架构上对 Transformer 进行大的改进，确实需要勇气。
  - 因为当下硬件的结构都是围绕如何优化 Transformer 的方式设计。
  - 未来较长时间里，Transformer 也都会是 AI 芯片设计中的公共结构，基于此再进行优化和设计。
- 所以突破 Transformer 架构的挑战非常大。
- 但是大模型的出现，在一夜之间颠覆了大家的想象，也证明了 Nothing is impossible。因此，可能也会在某一天突然间出现一个新的架构，替代掉原来的 Transformer 架构。

张鹏（GLM 大模型）：
- 以 Transformer 为例，现在大家的注意力都集中在这件事上。
  - 深度学习之父 Geoffrey Hinton 最根本的算法 bp（反向传播），在八几年就已经提出，但在之后的几十年里，并没有引起太大影响。甚至在学术界受限于一些客观条件，也没有太多人使用。
  - 当时来说，反向传播算法计算量过大且复杂，硬件无法支持过大的计算量。
  - Transformer 也是如此，为什么在 2017 年提出，到近年才大行其道？这是因为 AI 算力芯片的能力得到了十倍甚至百倍的增长，足以支撑大规模计算量。
- 所以，下一代的算法结构可能已在身边，只是受限于客观条件，无法实现跑通新的算法或者扩大规模，来证明新结构的价值。

#### 如何让大模型远离「幻觉」，安全可控？

李大海（CPM大模型）：
- 幻觉问题确实是当前影响应用落地的一个绊脚石。
- 实践角度
  - 目前比较好的方法是 `RAG`（外挂知识库）来引入外部知识，改善幻觉问题。
  - 如果让模型学习足够多的知识，对于学过的知识，出现幻觉的概率会变小。

然而，目前大模型整体基础设计是通过**压缩知识**产生的**通用智能**。压缩就会产生一定概率的错误，也就是**幻觉**。

【2023-11-30】[「GPT-4只是在压缩数据」，马毅团队造出白盒Transformer，可解释的大模型要来了吗？](https://mp.weixin.qq.com/s/ErrCWbz8zDqSYkC9DH79Mg)

伯克利和香港大学的`马毅`教授领导的一个研究团队给出了自己的最新研究结果：
> 包括 GPT-4 在内的当前 AI 系统所做的正是压缩。


因此，通过外挂知识库和学习更多知识的方法，尽可能减少幻觉，但**完全避免幻觉**目前还不太可能。

另一方面，应该关注更具探索性的方向
- 例如类似于 Agent 技术。在这个方向上，目前收益仍然相对有限。

如果客户让我在幻觉率上作保证的话，大模型在实际运用上，未必一定是纯粹大模型形态的落地产品。用大模型技术与其他技术结合在一起并不令丢人。在当前阶段，应该鼓励将大模型视为变量，而非将其视为核心，更加因地制宜地使用大模型技术。

Richard（百川大模型）：
- 现在大模型的建模方式是 Next Token 的 Prediction（下一个词预测），因此它必须说话。
- 大模型现在尽力压缩更多的知识，但一定是**有限**的。这包括也引入了知识具有**时效性**的问题，如果今天出现了一个新的知识，之前肯定没有训练过，或者之前漏了某些知识导致模型效果不好
- 幻觉产生原因
  - 大模型的知识并不能包含所有知识，而且还不支持**高频更新**。
  - 更本质的幻觉产生的原因：**不自知**。如果大模型知道自己不知道，就不会胡说八道了。
- 幻觉的解决方案
  - 谈到大模型的知识容量问题，类比一下人，人类已经很聪明了，但没有一个人能聪明到掌握所有知识，人也是通过查资料来扩大知识容量。
  - 解决「幻觉问题」非常重要的路径是与**搜索引擎**结合。搜索引擎作为网罗天下最大的数据和知识的工具，它能够与大模型深度结合。这种深度结合并非像 New Bing 这样先收集结果，然后再进行概括展现。也正在期待和探索真正能融入模型内部的方法。
- 模型训练时，例如 `RETRO`（Retrieval-Enhanced Transformer，自回归语言模型）方案，在训练阶段就可以实现优化，跳过了 RAG（外挂知识库）这个方案。

第二点，价值对齐，但某种程度上**价值对齐**也是大模型幻觉的根源。
- 原本只学习了小学和初中的知识，但在价值对齐环节时，引入了高中的题目，导致小学和初中知识都出现错误。

因此，在大模型方面另一个重要的投入就是**搜索增强**。Ilya（Ilya Sutskever，OpenAI 首席科学家）也提到了这个问题。希望通过搜索增强技术，尽量让模型知道自己不知道。

最好的情况是模型知道自己懂，然后输出正确答案，最差的情况是模型不懂且胡说八道。中间的关键，是让模型**知道自己不知道**。
- GPT-3.5 到 GPT-4 非常重要的进化，就是 GPT-4 的幻觉输出大幅度降低。当你询问他们一个复杂的问题时，GPT-4 会回答它不懂。

因此也会投入资源，解决幻觉方面的两个最重要部分。

大模型的幻觉可以看作是优势，因为它能够胡说八道或创造，所以具备创造能力。大模型也被称为想象力引擎。如果让大模型编一个故事，可能编得比人还好，而让大模型写一首藏头诗，可能写得比人还好。

王斌（MiLM 大模型）：
- 幻觉这个问题确实存在，一边做大模型，一边结合小米产品上的具体场景。双方互相了解，知道很多需求和场景，然后根据需求反推大模型的建设，能经历完整的迭代过程，幻觉实际上很可怕。

小米客服系统刚开始时，大家都认为通过大模型应该能大幅度提高客服系统。但尝试时，发现太可怕了。
- 比如消费者在客服系统询问产品价格，如果大模型报价回答「仅卖 9 块 9，交个朋友」，那我们就完了。

因此，在真实场景当中，大模型幻觉带来的后果实际上比我们想象的要严重很多。

实际操作的工程化和产品角度，对模型输出的结果进行分层分级。当然，幻觉问题和安全可控并不完全是同一个问题，总体而言，我们会对用户的输入和系统的输出进行分类分级。

有些输出结果是最高级别，有些基于具体场景，有具体的内容分级方式。因此，对于模型幻觉的整体治理方案是对输出结果分类、分级、及时监控和反馈。通过技术及人工手段来保证对用户最好，所以我们更多地关注产品方面的综合治理手段。

#### 自研的 AI 算力基建与服务如何发展？ 

康战辉（腾讯混元大模型）：
- 算力是模型训练阶段非常重要的基础设施
- 国内厂商的算力紧张，这是普遍问题,硅谷很多公司都拿不到货。
- 算力成本不用担心，整个 AI 基础设施中，除了算力本身在演进外，训练和推理过程都在持续优化。
- 腾讯对专用客户提供集群服务，对于算力需求比较弹性的客户，提供弹性卡资源，无论是成本还是总效率匹配方式，分配效率都更高

张鹏（GLM 大模型）：
- 智谱始终坚持包括算法在内的技术**自研**，但也发现算力确实是重要的基础资源，甚至成为了瓶颈。
- 因此，开始寻求与国产芯片厂商合作。但芯片自研是必经之路，应对复杂多变局势的最终解决方法还是需要自研。

- 芯片制造工艺的问题，我们与芯片厂商有很深的沟通，推出了国产大模型和国产芯片的适配计划。通过适配情况来看，国内外的芯片适配设计上，没有太大差距，但在具体制造工艺和应用生态方面差距比较大。
- 生态问题。英伟达的芯片为何让全球开发者趋之若鹜？原因在于它拥有一个良好的开发生态，使得大家能够轻松且高性能地使用它的芯片。现在许多国产芯片厂商，需要花费大量精力来做软件生态的适配。

正在推动与政府、技术厂商以及与芯片厂商共同讨论集中式方案，例如，在某个固定地方，组织大家一起进行 m 到 n 的适配过程，以保证知识共享，并更快地加速适配过程，是非常必要的过程。

#### 大模型的开源生态如何发展？ 

这么多年来从开源生态中赚钱是相对困难的问题，请几位嘉宾谈谈我们对开源生态建设的看法。

Richard（百川大模型）：
- 第一点是真开源。以往的开源模型，可能是开放做学术研究的，无法商用。虽然有开发者也在尝试商用，但中间存在很大风险。
  - 例如 Llama 2 虽然在开源时强调可商用，但在条款中，它也规定不能使用在非英文环境下。
  - 百川践行的是真开源。无论是 7B 还是 13B，都是开源且免费商用的，能真正让社区蓬勃发展。
- 第二点是自研，中国大模型的开源需要走向自研。百川在成立之初就希望从头开始训练大模型。为什么要强调自研两个字，一是条款中对**非英文**环境的限制。二是海外大模型的原生**中文能力不佳**，中国的大模型对中文理解能力一定是更强的。
  - 因此，从头开始训练，对中文语料进行更好的理解，同时也会输入掌握英文知识。

实际上大模型的最终落地需要在应用场景中实现，除了 Model as a service（`MaaS`，模型即服务），也需要 **Agent as a service**。未来的开源生态应该在外部增加更多**插件**，以便让开发者真正落地到应用场景中。

康战辉（腾讯混元大模型）：
- 腾讯一直非常积极拥抱开源，包括大数据、前端框架以及学术模型。当然，混元大模型尚未开源，一个核心原因是混元的规模较大，千亿级模型相对比较难开源。我们可能会持续打磨，在合适的阶段，结合公司战略做一些布局。
- 国内应用场景丰富，在训练通用大模型时，可以让模型兼顾通用及行业能力。
- 技术领域有所追求。美国的斯坦福有 HELM 评测，伯克利有 LMSYS Org。我们也应该构建中国大模型的 Benchmark（基准），这个非常重要。


#### 自研大模型如何取得领先地位？

张鹏（GLM 大模型）：
- 认知差异。需要重新审视目标，以及对大模型的认知边界到底在哪里。
  - 三年前 IIya 等人就提出研究目标是 `AGI`（通用人工智能），但并不考虑将这个产品做出来之后，如何赚钱
- 如何实现自主创新。这也是智谱开始训练模型时，并未简单地照搬 GPT-2 的论文，而是在算法层面就在思考如何自主创新。
- 国内存在一种风气，尤其在技术圈，习惯舶来主义或拿来主义。使用开源，但是不会贡献回去，没有良性的闭环。

王斌（MiLM 大模型）：
- “用中国擅长的应用创新，驱动底层技术进行颠覆式创新”

Richard（百川大模型）：
- 尽管 GPT 中文能力很强大，但与中国大模型对比，在某些领域表现已经落后

站在 OpenAI 的立场上，可以套用周星驰的名言：「我不是针对谁，而是在座的各位，都是垃圾。」
- 即使是 Google 的大模型目前为止效果也远远落后，只能依赖 OpenAI，它的第一性原理在于选择当前技术方案时，就是采用「Always for AGI」的逻辑


#### 如何看待互联网大厂与创业公司之间大模型的竞争？

康战辉（腾讯混元大模型）：
- 互联网大厂与创业公司在大模型上，不能完全用竞争来形容。实际上，应该是彼此各自有侧重、各自具有优势，也有互补或者互相促进的作用。
- 大厂和创业公司如何实现互相促进

张家兴（封神榜大模型体系）：
- 大模型的竞争中，同质化的问题比较严重，无法证明谁比谁强很多。
- 大厂的优势被称为**资源**优势，如果真的想要发展这个业务，大厂的资源肯定比创业团队多得多。
- 创业团队或者是独立的小团队的资源优势又是什么？就是**制度**优势。

#### 大模型如何在行业落地，实现商业化？

中国的 B 端落地环境非常残酷。可以用「卷」字来形容，第一毛利率很难持续，当产品稳定到一定程度后，每个客户的毛利率很难持续，第二每个客户的定制化要求相当高，对实施成本的要求非常高。

张鹏（GLM 大模型）：
- 答案很简单，叫「共建生态，共享红利」
- 改变思维，正如我们刚才提到的毛利率、利润空间等等就是很卷。但这是站在固定的天花板向下观察。
- 但请务必注意，可以提高天花板，扩大市场份额，这是大家容易忽略的一件事情。能将天花板再往上抬一抬，以及将不断内卷的墙砸一砸？

Richard（百川大模型）：
- 跳出上一代 AI 落地的方式。
- 未来的畅想是「一切都将成为 Agent」，会是一个充满想象力的世界。我们不应局限于基于 ChatGPT 目前一问一答响应式的对话形式。

#### 套壳 ChatGPT 的产品有价值么，大模型 C 端应用，机会在哪里？

李大海（CPM 大模型）：
- 未来实际上很难预测，我们只能预测下一个 Token。

### 大模型的局限性

【2023-7-27】朱松纯：[大模型=缸中之脑？通院朱松纯团队剖析AGI关键缺失](https://mp.weixin.qq.com/s/OUku0k2lRBix5ltREBkT8Q), [论文链接](https://arxiv.org/abs/2307.03762)

大模型训练数据集的不透明以及人类评估时所采取的指标差异可能使得人类高估了大模型的真正表现。
- 1）虽然某些研究声称大语言模型能够在**标准化测试**（SAT，LSAT）中取得超越普通人类考生的卓越成绩，但一旦引入**非英语**的其他语言同类型测试，比如中国高考、印度升学考试、越南高考时，GPT 的表现显著下降，且其在需要应用推理的考试（数学、物理等）的成绩**显著低于**强语言依赖学科（英文、历史）的考试。GPT 的表现看上去更像是采取了一种**题海战术**，通过重复的记忆来做题，而非习得了如何进行推理。
- 2）大语言模型的**数学推理能力仍然有待提高**。Bubeck 等人（2023）在《Sparks of Artificial General Intelligence》这篇文章中采取了单个案例展示的方式尝试说明 GPT-4 能够解决 IMO 级别的问题，但研究者在仔细检视了 GPT 所提供的解决方案发现 Bubeck 等人的结论具有很强的误导性，因为测试的题目被极大程度地简化了，在让 GPT-4 解决 IMO 数学题原题时， GPT-4 的数学逻辑链条是完全错误的。另有研究发现，在 MATH 训练数据集上，即使把模型设置为 MathChat 的模式，其准确率也只有 40% 左右。
- 3）大语言模型的推理与其说是来自于理解逻辑关系，不如说是来自于**大量文本的相关性**。朱松纯团队的另一篇研究发现，一旦将自然语言替换为**符号**，大语言模型在归纳、演绎、溯因任务上表现骤降，无论是否使用**思维链**（thought of chain）的策略。
- 4）大模型做不好抽象推理，当面对那些仅依赖于几个小样本演示从而找到潜在规律的任务时，大模型的表现较为一般。如下图所示，在瑞文测试数据集（RAVEN) 中，测试者需要根据已有的 8 个图形（形状、颜色、数量、大小）寻找暗含的规律，然后推理出最后一个图形。


### 并发性能

【2023-8-11】[如何解决LLM大语言模型的并发问题？](https://www.zhihu.com/question/613263140/answer/3130353140)

参考 [TGI](https://github.com/huggingface/text-generation-inference%23api-documentation) , [deepspeed](https://github.com/microsoft/DeepSpeed) 或者 [vllm](https://github.com/vllm-project/vllm) 等架构的实现方案。
1.  采用 Continous batching 来优化请求，提高 throughput，这个在 VLLM 和 TGI 中都有支持。
2.  用 flash attention 和 page attention 来优化 GPU 中 attention 的计算效率。目前部分主流的 inference 的仓库都会集成这两种 attention 优化方式。
3.  对于部分设备来说，可以考虑采用 GPTQ 提速。比如对于 4090，如果采用 fp16，在推理时batch size 仅能够达到 4（max\_tokens=2048）。但 GPTQ 能够支持 batch size 8 + max_tokens=2048。尽管batch inference 情况下，FP16 的速度会快于 GPTQ，但更大的 batch size 支持还是能让 GPTQ 的 throughput 优于 fp16。
4.  部署超大模型时，采用 Tensor Parallelism 加速，这个在 [TGI](https://github.com/huggingface/text-generation-inference%23api-documentation) , [deepspeed](https://github.com/microsoft/DeepSpeed) 或者 [vllm](https://github.com/vllm-project/vllm) 都有支持。
5.  服务速度实在不理想的话，考虑多买几台 GPU，然后用 Load balancer 做请求转发。


### 重复


#### 重复现象

【2024-5-15】使用基于最大化的解码算法（如贪婪搜索）时，模型倾向于在句子级别重复。

这种现象与人类语料库中很少出现连续句子级重复的现象不符。

研究发现：
- 1、模型有一种重复前一句的倾向
  - 实验发现 `P（橘子| 我 爱 橘子。我 爱）`> `P（橘子 | 我 爱）`。
  - 模型对其生成的上下文过于自信，当存在与前文相同的上下文时，模型可能会学习到一种“捷径”，即直接复制下一个词项。
  - 这和人类语言很不相同。人类语言通常不会把一个句子重复说，因为这不会增加额外的信息量。
- 2、**句子级重复**具有自我强化效应，即在上下文中重复的次数越多，继续生成该句子的概率越高。
- 3、具有更高初始概率的句子,通常有更强的**自我强化效应**，模型更倾向于重复这些句子。

#### 解决方案

神经文本生成中减少重复问题的技术可以分为两大类：基于**解码**的方法（decoding-based methods）和基于**训练**的方法（training-based methods）。

以下是一些主要的技术：
- 基于**解码**的方法（Decoding-based methods）:
  - `n-gram Blocking`: 这种方法通过阻止生成与之前生成的n个连续项相同的项来减少重复。
  - `Top-k Sampling`: 在生成过程中，只从概率最高的k个词中选择下一个词，这有助于增加多样性。
  - `Nucleus Sampling` (Top-p Sampling): 这种方法不是选择概率最高的k个词，而是选择累积概率达到p的最小词集，从而允许生成更多样化的文本。
  - `Beam Search with Diverse Hypotheses`: 在束搜索中考虑多样性，鼓励探索不同的生成路径，以减少重复。
- 基于**训练**的方法（Training-based methods）:
  - `Unlikelihood Training` (UL): 通过减少负样本（即重复的词或短语）的概率来训练模型。
  - `Straight-to-Gradient` (SG): 通过提高不属于负样本的词的概率来改善训练。
  - `Coverage Penalty`: 在训练中加入**覆盖度惩罚**，鼓励模型生成更多样化的输出。
  - `Exposure Bias Mitigation`: 通过调整训练目标以减少模型对高频重复内容的偏好。
- 其他技术：
  - `Insertion of Diverse Phrases`: 训练数据中插入多样化的短语，以鼓励模型学习减少重复。
  - `Curriculum Learning`: 逐步增加训练难度，先让模型学习生成不重复的内容，再逐步提高生成质量和复杂性。
  - `Reward Modeling`: 使用强化学习中的奖励模型来指导生成过程，奖励模型会鼓励生成多样化和信息丰富的文本。

文章来源：
- Learning to Break the Loop: Analyzing and Mitigating Repetitions for Neural Text Generation



### 幻觉

【2023-7-21】[大模型幻觉问题调研-LLM Hallucination Survey](https://zhuanlan.zhihu.com/p/642648601)
- [Survey of Hallucination in Natural Language Generationarxiv.org/abs/2202.03629](https://arxiv.org/abs/2202.03629)
- 仓库：[Reading list of hallucination in LLMs.github.com/HillZhang1999/llm-hallucination-survey](https://github.com/HillZhang1999/llm-hallucination-survey)

LLM幻觉分为两种：
- 事实型幻觉: 事实不一致、事实捏造；
- 忠实度幻觉: 指令-答案的不一致、文本不一致，以及逻辑不一致。

LLMs幻觉分为三种：输入冲突幻觉、上下文冲突幻觉和事实冲突幻觉。
- **输入**冲突幻觉：生成内容与用户输入不符；
- **上下文**冲突幻觉：是指生成的内容与之前生成信息相矛盾；
- 事实冲突幻觉：是指生成的内容与已知的**世界知识**不符。



2023年4月，OpenAI联合创始人兼研究科学家`John Schulman`在UC伯克利的演讲中，详细阐述了大模型难以攻克的难题。
- LLM黑盒内部隐藏着一个「**知识图谱**」。如果这个架构中没有的知识，仅通过SFT教大模型（即行为克隆）知识，实则在教它输出幻觉。
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1c3fae47b1dc4696b52021b37264cf4e~tplv-tt-origin-asy2:5aS05p2hQOaWsOaZuuWFgw==.image)
- 参考: [baichuan如何解决幻觉问题](https://www.toutiao.com/article/7283012199466140223)

#### 什么是幻觉

什么是幻觉
>- the generated content that is nonsensical or unfaithful to the provided source content On faithfulness and factuality in abstractive summarization
>- 模型生成的文本**不遵循原文**（Faithfulness）或者**不符合事实**（Factualness)

注：
- `Faithfulness`(诚实): 是否**遵循输入**内容。
- `Factualness`(事实): 是否符合**世界知识**。

幻觉分为两类：`内在幻觉` 和 `外在幻觉`
- `内在幻觉`: 是否遵循输入内容, 生成的输出与源内容**相矛盾**。
- `外在幻觉`: 是否符合世界知识, 生成的输出**无法从源内容中验证**。
  - 很多任务中这种幻觉可能有益，因为是模型从自己知识库里调用了知识，补充了源材料中没有的内容。
  - 但是，对于另一些严格需要根据源材料生成的任务，这样的幻觉就是有害的，而且很难发现。

内在幻觉和外在幻觉都可能是模型根据相似性泛化出来的，可能对，可能错，还有可能根本没办法判断对错。

用大模型做对于幻觉的容忍度比较低的任务时，需要想办法做验证。
- 比如摘要和翻译这样的任务，就需要小心。

不同任务里幻觉定义可能出现差异：
- **数据源**（source）不一致：
  - 摘要的数据源是document
  - data-to-text的数据源是data table
  - 对话的数据源是对话历史
  - 而开放域对话的数据源可以是世界知识。
- **容忍程度**不一致：
  - 在摘要、data-to-text任务中，非常看重response的Faithfulness，因此这些任务对幻觉的容忍程度很低；
  - 而像开放域对话任务中，只需要response符合事实即可，容忍程度较高；

传统任务里幻觉大都是指的是 `Faithfulness`：
- `内在幻觉` Intrinsic Hallucination（**前后冲突**）: LMs在生成回复时，与输入信息产生了冲突，例如摘要问题里，abstract和document的信息不一致。
- `外在幻觉` Extrinsic Hallucination（**无中生有**）: LMs在生成回复时，输出一些并没有体现在输入中的额外信息，比如邮箱地址、电话号码、住址，并且难以验证其真假。
  - 按照此定义，Extrinsic Hallucination有可能是真的信息，只是需要外部信息源进行认证

而LLMs应该考虑的幻觉是 `Factualness`：
- 因为应用LLM的形式是open-domain QA，而不是局限于特定任务，所以数据源可以看做任意的世界知识。LLMs如果生成了不在input source里的额外信息，但是符合事实的，这是有帮助的。

#### 为什么会有幻觉？

【2024-1-15】
- 哈尔滨工业大学和华为的研究团队，长达49页，对有关LLM幻觉问题的最新进展来了一个全面而深入的概述
  - [A Survey on Hallucination in Large Language Models: Principles, Taxonomy, Challenges, and Open Questions](https://arxiv.org/abs/2311.05232)
- 腾讯AI实验室
  - [A Survey on Hallucination in Large Language Models](https://arxiv.org/pdf/2309.01219.pdf)

产生幻觉主要原因: 
- 预训练数据收集: 
- 知识GAP
- 大模型优化过程

LLM产生幻觉的根本原因，主要分为三个关键方面：数据、训练和推理。
- 数据
  - 预训练数据集不完整、过期
  - LLM捕捉虚假相关性，长尾、复杂推理场景推理困难，加剧幻觉
- 训练
  - **预训练**阶段：LLMs学习通用表征并捕捉广泛的知识，通常采用基于transformer的架构，在庞大的语料库中进行因果语言建模。但是，固有架构设计和研究人员所采用的特定训练策略，可能会产生与幻觉相关的问题。
  - **对齐**阶段：监督微调和从人类反馈中强化学习（RLHF）。虽然对齐能显著提高 LLM 响应的质量，但也会带来产生幻觉的风险，主要分为两方面：**能力不对齐**（Capability Misalignment）和**信念不对齐**（Belief Misalignment）
- 推理
  - 解码策略固有的**随机性**（Inherent Sampling Randomness）：比如采样生成策略（如top-p和top-k）引入的随机性可能导致幻觉。
  - 不完善的**解码表示**（Imperfect Decoding Representation）：在解码阶段，LLM 使用**顶层表示法**预测下一个标记。然而，顶层表示法也有其局限性，主要表现在两个方面：**上下文关注不足**（Insufficient Context Attention）和**Softmax瓶颈**（Softmax Bottleneck）。

幻觉原因
- 数据的质量不够好。Garbage in, Garbage out的基本原理对于大模型仍然是适用的。
  - 启发式数据集
  - 重复内容
  - 内在差异
- 训练和推理原因。
  - 不完善的表示学习
  - 错误的解码
  - 曝光偏差
  - 参数化知识偏差

图解
- ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e74d965b1254976be5acab3491ba4ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)


[导致幻觉](https://www.appen.com.cn/blog/ai-hallucinations/)有若干因素，其中包括训练数据有偏见或训练数据不足、训练数据过度拟合、上下文理解有限、领域知识缺乏、对抗攻击和模型架构。
- 训练数据**有偏见**或训练数据**不足**：AI模型的好坏取决于训练所使用的数据。如果训练数据有偏见、不完整或不足，AI模型可能会基于其对所访问数据的有限理解而产生幻觉。在使用开放的互联网数据训练大型语言模型的情况下，这一点尤其令人担忧，因为互联网中有偏见和错误的信息泛滥。
  - 训练数据收集过程中，众包/爬虫检索的数据可能包含**虚假信息**，从而让模型记忆了错误的知识；
  - 过多**重复信息**也可能导致模型的知识记忆出现bias，从而导致幻觉
  - 潜在的研究方向：
    - Building High-quality Training Corpus is essential.
    - Data verification/ Data filter/ Data selection.
- **过度拟合**：当AI模型与训练数据过度拟合时，它可能会开始生成对训练数据过于具体的输出，不能很好地推广到新数据。这可能导致模型生成幻觉或不相关的输出。
- **上下文理解**缺乏：缺乏上下文理解的AI模型可能会产生脱离上下文或不相关的输出。这可能导致模型生成幻觉或荒谬的输出。
- **领域知识有限**：为特定领域或任务设计的AI模型在接受其领域或任务之外的输入时可能会产生幻觉。这是因为它们可能缺乏生成相关输出所需的知识或背景。当模型对不同语言的理解有限时，就会出现这种情况。尽管一个模型可以在多种语言的大量词汇上进行训练，但它可能缺乏文化背景、历史和细微差别，无法正确地将概念串在一起。
- **对抗攻击**：不同于组建一支团队“攻破”模型以改进模型的红蓝对抗，AI模型也易受对抗攻击。当恶意攻击者故意操纵模型的输入时，可能会导致它生成不正确或恶意的输出。
- **模型架构**：即使有了高质量训练数据，LLMs仍然可能表现出幻觉现象。AI模型架构会影响幻觉产生的容易程度。由于复杂性增加，具有更多分层或更多参数的模型可能更容易产生幻觉。
  - 模型结构：如果是较弱的backbone（比如RNN）可能导致比较严重的幻觉问题，但在LLMs时代应该不太可能存在这一问题；
  - 解码算法：如果用**不确定性较高**的采样算法（e.g.，top-p）会诱导LMs出现更严重的幻觉问题。甚至可以故意在解码算法中加入一些随机性，进一步让LMs胡编乱造（可以用该方法生成一些negative samples）
    - 2022, [Factuality enhanced language models for open-ended text generation](https://arxiv.org/abs/2206.04624)
  - 暴露偏差：训练和测试阶段不匹配的exposure bias问题可能导致LLMs出现幻觉，特别是生成long-form response的时候。
    - 2020, Chaojun Wang and Rico Sennrich. [On exposure bias, hallucination and domain shift in neural machine translation](https://arxiv.org/abs/2005.03642)
  - 参数知识：LMs在预训练阶段记忆的错误的知识，将会严重导致幻觉问题。
    - 2021, EMNLP, [Entity-based knowledge conflicts in question answering](https://arxiv.org/abs/2109.05052)

（1）数据层面

在数据工程层面可能出现一些问题，导致幻觉问题：
- 训练数据收集过程中，众包/爬虫检索的数据可能包含**虚假信息**，从而让模型记忆了错误的知识；
- 过多的**重复信息**也可能导致模型的知识记忆出现bias，从而导致幻觉：
  - Deduplicating training data makes language models better
- 潜在的研究方向：
  - Building High-quality Training Corpus is essential.
  - Data verification/ Data filter/ Data selection.

（2）模型层面

即使有了高质量训练数据，LLMs仍然可能表现出幻觉现象。
- **模型结构**：如果是较弱的backbone（比如RNN）可能导致比较严重的幻觉问题，但在LLMs时代应该不太可能存在这一问题；
- **解码算法**：研究表明，如果使用**不确定性**较高的采样算法（e.g.，top-p）会诱导LMs出现更严重的幻觉问题。甚至可以故意在解码算法中加入一些随机性，进一步让LMs胡编乱造（可以用该方法生成一些negative samples）
  - Factuality enhanced language models for open-ended text generation
- **暴露偏差**：训练和测试阶段不匹配的exposure bias问题可能导致LLMs出现幻觉，特别是生成long-form response的时候。
  - On exposure bias, hallucination and domain shift in neural machine translation
- **参数知识**：LMs在预训练阶段记忆的错误的知识，将会严重导致幻觉问题。
  - Entitybased knowledge conflicts in question answering

#### 如何检测幻觉

幻觉的评估
- 现有的传统幻觉评估指标和人类结果的相关性较低，同时大都是task-specific的。
- 2021, [Understanding factuality in abstractive summarization with FRANK: A benchmark for factuality metrics](https://arxiv.org/abs/2104.13346)

幻觉评估：
- Chatgpt倾向于在回复中生成**无法被验证**的内容（幻觉），占比 **约11.4%**
- 当前强大的LLM，如Chatgpt，都很难精准检测出文本中出现的幻觉问题
- 通过提供外部知识和增加推理步数，能够提升LLM检测幻觉的能力

（1）Reference-based

Reference-based的指标有两类：
- 基于 Source Information 和 Target Reference：利用一些**统计学指标**，比如ROUGE、BLEU来评估输出结果和Source/Target信息的重叠度。
- 基于 Source Information：NLG任务里Target输出往往是多种多样的，因此许多工作只基于Source信息进行幻觉的评估。比如Knowledge F1。

注：
> 基于Reference的评价指标只能评价`Faithfulness`，而无法评价`Factualness`，因此不适用于LLMs。

（2）Reference-Free

方法
- (1) 基于`IE`：将知识限定于可以用三元组形式表示的关系和事件，基于额外的IE模型进行抽取，接着使用额外模型进行验证。缺点：
  - 可能存在IE模型的错误传播问题。
  - 知识被限定在三元组形式。
- (2) 基于`QA`：
  - 第一步先基于LM生成的回复，使用一个QG(question generation)模型生成一系列QA pairs；
  - 第二步给定Source Information，让QA模型对上一步生成的Question进行回复；
  - 第三步则是通过对比第一步的answers和第二步的answers，计算匹配指标，衡量模型的幻觉问题；
  - 缺点
    - 这种方法同样存在QA/QG模型的**错误传播**问题。
    - 难以评估`Factualness`，因为第二步里面，Source Information不可能包含全部的世界知识，因此对于一些问题难以生成可靠的回复。
    - 2020, ACL, [FEQA: A question answering evaluation framework for faithfulness assessment in abstractive summarization](https://arxiv.org/abs/2005.03754)
- (3) 基于`NLI`：基于NLI的方法通过利用NLI模型评估是否Source Information可以蕴含Generated Text，从而评估是否出现了幻觉现象。
  - 缺点
    - Off-the-shelf NLI模型用于核查事实效果不是很好；
      - 2021, [Evaluating groundedness in dialogue systems: The BEGIN benchmark](https://arxiv.org/abs/2105.00071)
    - 无法评估需要世界知识的幻觉问题：仅能依赖于Source进行核查；
      - 2020, EMNLP, [Evaluating factuality in generation with dependency-level entailment](https://arxiv.org/abs/2010.05478)
    - 都是sentence-level的，无法支撑更细粒度的幻觉检查；
      - 2020, EMNLP, [Evaluating factuality in generation with dependency-level entailment](https://arxiv.org/abs/2010.05478)
  - **幻觉**问题和**蕴含**问题实际并不等价：
    - 例子：Putin is president. -> Putin is U.S. president (可以蕴含，但是是幻觉)
- (4) 基于`Factualness Classification Metric`：标注/构造一批和幻觉/事实有关的数据，训练检测模型，利用该模型评估新生成文本的幻觉/事实问题。
  - 2018, ICLR, [Wizard of Wikipedia: Knowledge-powered conversational agents](https://arxiv.org/abs/1811.01241)
- (5) 人工评估：目前为止最靠谱的
- (6) 此外还可以依靠LLM打分（比如GPT4，但是GPT4也存在着严重的幻觉问题，除非retrival-augment，但是检索回来的信息也有可能是错误的）

【2024-1-15】[一份全面的「大模型幻觉」综述](https://www.toutiao.com/article/7321227259992605194)

事实性幻觉的检测方法通常分为 "检索**外部事实**"（Retrieve External Facts）和 "**不确定性估计**"（Uncertainty Estimation）。
- **检索外部事实**：为了有效地指出 LLM 输出中的事实不准确之处，一种直观的策略是将模型生成的内容与可靠的知识来源进行比较，如下图 3 所示。
- **不确定性估计**大致可分为两种：基于**内部状态**和 **LLM 行为**。前者的前提是可以访问模型的内部状态，而后者则适用于更受限制的环境，仅利用模型的可观测行为来推断其潜在的不确定性。

忠实性幻觉的检测方法：
- 主要侧重于确保生成的内容与给定上下文保持一致，从而避免无关或矛盾输出的潜在隐患。

LLM 生成中检测不忠实的方法。
- 基于事实度量：通过检测生成内容与源内容之间的事实重叠度来评估忠实度。
- 基于分类器的度量：利用经过训练的分类器来区分生成内容与源内容之间的关联程度。
- 基于QA的度量方法：利用问题解答系统来验证源内容与生成内容之间的信息一致性。
- 不确定性估计：通过测量模型对其生成输出的置信度来评估忠实度。
- 基于prompt的度量方法：让LLM充当评估者，通过特定的prompt策略来评估生成内容的忠实度。


####  亚马逊 RefChecker

Definition of Hallucinations.
- ![](https://github.com/amazon-science/RefChecker/raw/main/imgs/venn.png)

【2024-12-10】[开源模型“幻觉”更严重，这是三元组粒度的幻觉检测套件](https://www.secrss.com/articles/61615)

亚马逊上海人工智能研究院推出细粒度大模型幻觉检测工具 BSChecker，包含如下重要特性：
- 细粒度幻觉检测框架，对大模型输出文本进行**三元组粒度**的幻觉检测。
- 幻觉检测基准测试集，包含三种任务场景，满足用户的不同需求。
- 两个基准测试排行榜，目前涵盖15个主流大模型的幻觉检测结果。

另外，BSChecker 作者们在Gemini推出后也很快做了自动检测的幻觉测试。

BSChecker 目前收录了 2100 个经过细粒度人工标注的大模型输出文本，涵盖了 7 个主流大模型，如 GPT-4、Claude 2、LLaMA 2 等
- GPT-4 比 GPT-3.5 更好，而 GPT-3.5 又远远优于 InstructGPT

BSChecker 工作流程

BSChecker 具有模块化的工作流程，分为三个可配置的模块：**声明抽取器** E，**幻觉检测器** C，以及**聚合规则** τ。这三个模块互相解耦合，可以通过增强其中的部分模块对整个框架进行扩展和改进。
- ![](https://s.secrss.com/anquanneican/01ca6d28cc43c8f4897816deab9cb5e9.png)

两个主要模块是：
- 基于大模型的声明抽取器：作者发现大模型很擅长提取声明三元组，在当前版本中，他们使用 GPT-4 和 Claude 2 作为声明抽取器。
- 基于人工或模型的幻觉检测器：对于给定的声明三元组和参考文本，标注者可以相应地进行标注，如下图所示。该标注工具也将很快发布。基于模型的幻觉检测器将在后续的自动评估排行榜章节中介绍。
- ![](https://s.secrss.com/anquanneican/a2f390436f53ec8f84474183dadc5e04.png)

幻觉检测框架示意图
- 项目地址: [RefChecker for Fine-grained Hallucination Detection](https://github.com/amazon-science/bschecker-for-fine-grained-hallucination-detection)
- 排行榜地址：[BSChecker-Leaderboard](https://huggingface.co/spaces/xiangkun/BSChecker-Leaderboard), 已经404
- ![](https://s.secrss.com/anquanneican/6e7d9020af031887c6e86afffcb6104e.gif)

#### 如何缓解幻觉

如何缓解幻觉? 目前幻觉问题**没有被解决掉**。

但是有一些思路可以缓解幻觉的产生。
- **强化学习**
- 用openai的服务时可以发现，其在服务端还有一个后处理的服务，如果生成了不合适的内容，就会被这个监控服务给处理掉。

（1）基于数据
- 人工标注
  - 训练数据：LLM上不可行，只适用于task-specific的幻觉问题
  - 评测数据：构建细粒度的幻觉评估benchmark用于分析幻觉的严重程度和原因
  - 2021, ACL, [GO FIGURE: A meta evaluation of factuality in summarization](https://arxiv.org/abs/2010.12834)
  - 2021, EMNLP, [Q2: Evaluating factual consistency in knowledge-grounded dialogues via question generation and question answering](https://arxiv.org/abs/2104.08202)
- 自动筛选
  - 利用模型筛选出可能导致幻觉的数据并剔除；
  - 预训练时给更faithful的数据加权（wiki vs. fake news），或者不使用可靠来源的数据（比如只选用经过人工审查的数据源，如wiki或者教科书，预训练）
  
案例：[Vectara：让你的LLM应用告别幻觉](https://zhuanlan.zhihu.com/p/626544154)
- [Vectara](https://vectara.com/) 是一个专注于对话体验的平台，它提供了强大的检索、摘要和生成功能，以及简单易用的开发者接口。Vectara平台使用了一种叫做基于事实的生成（Grounded Generation）的方法，在生成文本之前和之后都进行事实检索和验证，确保生成内容是有意义且忠实于源内容的
- ![](https://vectara.com/wp-content/uploads/2023/05/home-diagram-desktop-v2.svg)

- Extract: Vectara automatically extracts text from PDF and Office to JSON, HTML, XML, CommonMark, and many more.
- Encode: Encode at scale with cutting edge zero-shot models using deep neural networks optimized for language understanding.
- Index: Segment data into any number of indexes storing vector encodings optimized for low latency and high recall.
- Retrieve: Recall candidate results from millions of documents using cutting-edge, zero-shot neural network models.
- Rerank: Increase the precision of retrieved results with cross-attentional neural networks to merge and reorder results.
- Summarize: Optionally generate a natural language summary of the top results for Q&A or conversational AI experiences.

基于事实的生成方法包括以下几个步骤：
- ![](https://pic4.zhimg.com/80/v2-90d1ff553a1b56f594191effd6bf7887_1440w.webp)
-   输入：给定一个文本或语音输入，例如一个问题、一个指令、一个话题等。
-   检索：根据输入在互联网或其他数据源中检索相关的事实信息，例如网页、文章、数据库等。
-   验证：根据检索到的事实信息，对输入进行验证，判断其是否合理、准确、完整等。如果输入不符合要求，可以提出修改或补充的建议。
-   生成：根据验证后的输入和检索到的事实信息，使用LLM生成相应的文本或语音输出。
-   验证：根据检索到的事实信息，对生成的输出进行验证，判断其是否有意义、忠实、一致等。如果输出不符合要求，可以进行修改或重写。

通过这样一个循环的过程，基于事实的生成方法可以有效地避免或减少LLM幻觉，提高LLM生成内容的质量和可信度。

[Vectara](https://vectara.com/)平台具有以下特点：
-   基于**事实**：Vectara平台在生成文本之前和之后，都会在互联网或其他数据源中检索相关的事实信息，并对输入和输出进行验证，以确保内容是正确、合理、完整、一致的。这样，你就不用担心你的LLM会产生幻觉，或者给你一些错误或无意义的回答。
-   **对话式**：Vectara平台支持多轮对话，可以根据用户输入和上下文动态地调整生成内容和风格，提供更自然、更流畅、更人性化的对话体验。例如，当你问一个LLM“谁拥有硅谷银行？”时，Vectara平台不仅会给你一个正确且及时的回答：“根据最新的网页信息，硅谷银行（SVB）已经于2022年12月宣布破产。它目前正处于清算阶段，其资产和债务由美国联邦存款保险公司（FDIC）管理。”而且还会根据你的反应和兴趣，给你一些相关或有趣的信息或建议。例如，“你是否对硅谷银行破产的原因感兴趣？我可以给你一些网页链接。”或者“你是否想知道硅谷银行破产对科技行业有什么影响？我可以给你一些数据分析。”
-   **开发者友好**：Vectara平台提供了简单易用的开发者接口，可以让开发者快速地集成和部署基于事实的生成应用，无需复杂的配置或代码。Vectara平台支持多种数据源和LLM，可以根据不同的应用场景和任务，选择最合适的数据源和LLM，以提供最优的生成效果。Vectara平台还允许开发者根据自己的需求和偏好，定制生成内容的参数和选项，例如长度、语言、领域、风格等。
-   **可扩展**：Vectara平台不仅可以用于文本生成，还可以用于语音生成。Vectara平台可以将文本转换为语音，或者将语音转换为文本，以满足不同的用户需求和偏好。Vectara平台还可以将文本或语音翻译成不同的语言，以支持跨语言的对话体验。


【2023-9-22】一种名为“Chain-of-Verification(CoVe)”的方法，通过**规划验证**问题和**独立**回答，使语言模型能在生成回答时减少幻觉现象，提高回答的准确性。
- 《[Chain-of-Verification Reduces Hallucination in Large Language Models](https://arxiv.org/abs/2309.11495)》S Dhuliawala, M Komeili, J Xu, R Raileanu, X Li, A Celikyilmaz, J Weston [Meta AI] (2023) 

（2）模型层面
- 模型结构
  - 模型结构层面的工作往往focus在设计更能充分编码利用source information的方法，比如融入一些**人类偏置**，如GNN网络。
  - 或者在解码时减少模型的生成**随机性**，因为diversity和Faithfulness往往是一个trade-off的关系，减少diversity/randomness可以变相提升Faithfulness/Factuality。
    - 2022, [Factuality enhanced language models for open-ended text generation](https://arxiv.org/abs/2206.04624)
  - **检索增强**被证明可以显著减少幻觉问题，e.g., llama-index。
    - 2023, [Check your facts and try again: Improving large language models with external knowledge and automated feedback](https://arxiv.org/abs/2302.12813)
- 训练方式
  - 可控文本生成：将幻觉的程度作为一个可控的属性，利用可控文本生成技术进行控制。
    - 2021, ACL, [Increasing faithfulness in knowledgegrounded dialogue with controllable features.](https://arxiv.org/abs/2107.06963)
    - 2021, AAAI, [A controllable model of grounded response generation](https://arxiv.org/abs/2005.00613)
  - 提前规划骨架，再生成：sketch to content
    - 2019, AAAI, [Data-to-text generation with content selection and planning](https://arxiv.org/abs/1809.00582)
  - 强化学习：假设是基于word的MLE训练目标，只优化唯一的reference，可能导致暴露偏差问题。现有工作将减轻幻觉的指标作为强化学习的reward函数，从而减轻幻觉现象。
    - 2020, ACL, [Slot-consistent NLG for task-oriented dialogue systems with iterative rectification network](https://aclanthology.org/2020.acl-main.10/)
    - 2021, ACL, [Improving factual consistency between a response and persona facts](https://arxiv.org/abs/2005.00036)
  - 多任务学习: 通过设计合适的额外任务，可以达到减轻幻觉的效果。
  - 后处理：设计一个小模型专门用于fix幻觉错误。
    - 2021, ACL, [Improving faithfulness in abstractive summarization with contrast candidate generation and selection](https://arxiv.org/abs/2104.09061)

可能的后续方向

- 更细粒度的幻觉评估：
  - token/phrase level instead of sentence level
  - 更精细的幻觉分类体系：
    - Intrinsic
    - Extrinsic
    - 其他类别：
      - 按幻觉产生的原因分类（调用知识出错，还是缺少相应知识）
      - 主观/客观幻觉
      - 幻觉可能和时间（temporal）有关
- 知识的定义和诱导：
  - 怎么知道模型是否具备某一类知识，只是没有调用好？
  - 知识的定义：
    - 传统工作大都将wikipedia视作知识库，但它仅仅是世界知识的很小一部分
    - 如果将整个互联网当做世界知识，又不可避免的会有虚假信息的问题
- 幻觉消除：
  - 检索增强：互联网/外挂知识库(llama Index)
  - 强化学习（RLHF）
  - 知识诱导/注入
  - 直接修改LLM中错误记忆的知识：Model Editing工作，如ROME，MEMIT等

总结
- 数据类方法
  - 构建可信数据集
  - 自动清理数据
  - 信息增强
- 模型和推理
  - 架构：编码器、注意力机制、解码器
  - 规划和骨架、强化学习、多任务学习、受控生成
- 后处理

图解
- ![幻觉](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54d5bc7845964958a561ef120e28962e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

作者：[旭伦](https://juejin.cn/post/7241861929412460600)

（1）数据层面：构建高质量数据集
- 人工标注
  - GO FIGURE: A meta evaluation of factuality in summarization
  - Evaluating factual consistency in knowledge-grounded dialogues via question generation and question answering
  - 训练数据：LLM上不可行，只适用于task-specific的幻觉问题
  - 评测数据：构建细粒度的幻觉评估benchmark用于分析幻觉问题
- 自动筛选：
  - 利用模型打分，筛选出可能导致幻觉的数据并剔除；
  - 预训练时给更faithful的数据加权（wiki vs. fake news），或者不使用可靠来源的数据（比如只选用经过人工审查的数据源，如wiki或者教科书，预训练）


（2）模型层面

- **模型结构**
  - 模型结构层面的工作往往focus在设计更能充分编码利用source information的方法，比如融入一些人类偏置，如GNN网络。
  - 或者在解码时减少模型的生成随机性，因为diversity和Faithfulness往往是一个trade-off的关系，减少diversity/randomness可以变相提升Faithfulness/Factuality。
  - 「检索增强」被证明可以显著减少幻觉问题，e.g., LLaMA-index。
    - [Vectara：让你的LLM应用告别幻觉！](https://zhuanlan.zhihu.com/p/626544154)
- **训练方式**
  - **可控文本生成**：将幻觉的程度作为一个可控的属性，利用可控文本生成技术进行控制。
    - Increasing faithfulness in knowledgegrounded dialogue with controllable features
    - A controllable model of grounded response generation
  - **提前规划骨架**，再生成：sketch to content
    - Data-to-text generation with content selection and planning
  - **强化学习**：假设是基于word的MLE训练目标，只优化唯一的reference，可能导致暴露偏差问题。现有工作将减轻幻觉的指标作为强化学习的reward函数，从而减轻幻觉现象。
    - Slot-consistent NLG for task-oriented dialogue systems with iterative rectification network
    - Improving factual consistency between a response and persona facts
  - **多任务学习**: 通过设计合适的额外任务，可以达到减轻幻觉的效果。
    - 后处理：设计小模型专门用于fix掉幻觉错误。
    - Improving faithfulness in abstractive summarization with contrast candidate generation and selection

【2023-7-9】拾象调研

Hallucination 的原因：
- 网上很多**信息错误**，学到了错误信息
- 模型喜欢**模仿语言风格**，对**正确信息判断不好**

减少 hallucination 的方案：<span style='color:blue'>scaling/retrieval/reward model</span>
- scaling: 目前 20% 的 hallucination 可以通过 scaling 降低：看到很多问题都能通过 scaling 解决，OpenAI 相信hallucination 也可以
- retrieval: 如果 inference 的成本能降到特别低，latency 也能特别低：可以让模型在回答问题前尽可能多地去做 retrival和 verify，就像一个人的思考如果变得很便宜，就可以让它可能多地去思考
- reward model: 

【2023-6-1】[OpenAI称找到新方法减轻大模型“幻觉”](https://news.sciencenet.cn/htmlnews/2023/6/502017.shtm)
- OpenAI对抗AI“幻觉”的新策略是：奖励大模型每个正确的**推理步骤**，而不是简单地奖励正确的**最终答案**。研究人员表示，这种方法被称为“过程监督”，而不是“结果监督”。


#### 幻觉评估数据集

##### (1) TruthfulQA

- [TruthfulQA: Measuring How Models Mimic Human Falsehoods](​aclanthology.org/2022.acl-long.229)

一个很重要的用于评估LLM是否能够生成符合事实的答案的QA基准，被后续的LLM工作，如GPT4采用评估。包含了817个作者手写的问题，这些问题是精心设计，往往是模型或者人类都很容易回答错误的陈述。

作者发现：
- 与人类相比(94%)，当前较好的LLMs(GPT3)也只能诚实地回答58%的问题而不进行编造。
- 更大的模型更容易编造回答。
- 微调后的GPT3可以有效分辨是否回答是truthful的。

##### (2) HaluEval benchmark

- [HaluEval: A Large-Scale Hallucination Evaluation Benchmark for Large Language Models](arxiv.org/abs/2305.11747)

- Benchmark搭建：人工标注了35,000条数据，5000条chatgpt的general query（alpaca data），30000条chatgpt的任务回复（问答、摘要、知识对话）
  - 让chatgpt生成更有可能出现幻觉的文本：数据过滤，prompt工程；
  - 每个任务的幻觉还有不同类型：
    - QA： comprehension, factualness, specificity, and inference；
    - knowledge-grounded dialogue：extrinsic-soft, extrinsic-hard, and extrinsic-grouped
    - text summarization： factual, non-factual, and intrinsic
- 幻觉评估：
  - Chatgpt倾向于在回复中生成无法被验证的内容（幻觉），占比约11.4%
  - 当前强大的LLM，如Chatgpt，都很难精准检测出文本中出现的幻觉问题
  - 通过提供外部知识和增加推理步数，能够提升LLM检测幻觉的能力

##### FacTool 上海交大

FacTool是由上海交通大学、卡内基梅隆大学、香港城市大学、Meta 等机构学者共同提出的一款通用框架，能够查核大模型生成内容的事实准确性（也能查核一般性内容的事实准确性）
- [项目地址](https://github.com/GAIR-NLP/factool)

#### 幻觉评估

ChatGPT/GPT4生成不真实回复的评估、机理
- [Why Does ChatGPT Fall Short in Providing Truthful Answers?](​arxiv.org/abs/2304.10513)

对LLM生成的不符合事实的错误类型进行分类和统计：
- ![](https://pic4.zhimg.com/80/v2-3eb192e4990f42b5522425ed5ddfe2cf_1440w.webp)

定义了三个能力，可能导致幻觉的
- 知识记忆
- 知识调用
- 知识推理
- ![](https://pic4.zhimg.com/80/v2-13f96fdc567007624d3a87f16426aeff_1440w.webp)

通过实验，对大模型生成可靠回复给出了一些建议：
- 提供更多的背景知识（检索）
- 提供更细粒度的背景知识（分析）
- 把问题进行分解（CoT)

早期的工作
- [A Multitask, Multilingual, Multimodal Evaluation of ChatGPT on Reasoning, Hallucination, and Interactivity](​arxiv.org/abs/2302.04023)

包括了对ChatGPT幻觉现象的评估：
- ChatGPT有能力识别虚假信息，并能够在无法识别时回复不知道；
- ChatGPT仍然会被TruthfulQA内的问题误导；
- ChatGPT同样可能出现intrinstic/extrinsic hallucination的case；

Retrieval-augment LLM评估

Retrieval有助于显著减少LLM的幻觉现象。
- [Automatic Evaluation of Attribution by Large Language Models](​arxiv.org/abs/2305.06311)

自OSU的两个工作，主要是研究了给定retrieval reference的情况下，LLM的遵循能力。

前一个工作首先定义了自动评估一个reference能否支撑generation的任务，然后研究了LLMs（prompt/finetuned）的完成这一任务的能力
- automatic attribution evaluation的效果都不好
- 小的finetuned模型可以超过大的zero-shot模型
- 模型容量和评估效果并不完全正相关
- 使用额外的其他任务训练，可以提升automatic attribution evaluation的能力（QA/NLI/FC）
- ![](https://pic3.zhimg.com/80/v2-14c63a9889074680dbaeaedbefaba292_1440w.webp)

后一个工作
- [Adaptive Chameleon or Stubborn Sloth: Unraveling the Behavior of Large Language Models in Knowledge Clashes](​arxiv.org/abs/2305.13300)


研究了给定reference情况下对LLM生成结果的影响：

使用一个5步走的框架进行knowledge elicitation
- parametric memory：模型内部的知识
- counter-memeory：与模型内部知识相反的内容
- ![](https://pic4.zhimg.com/80/v2-8ad95c909805fd32f51e509f95e8ebb3_1440w.webp)

- 当只有一个单一的知识源时：
  - 简单的通过entity替换的counter-memory无法诱骗模型，但是让LLM自己生成的可以
- 当有多个知识来源时：
  - LLM倾向于相信更流行的知识；
  - LLM对于知识的顺序很敏感，倾向于相信先出现的知识；
  - LLM相信更长的知识；
  - LLM随大流，相信占据大多数的知识

LLM幻觉的滚雪球现象
- [How Language Model Hallucinations Can Snowball](​arxiv.org/abs/2305.13534)

本文作者认为：
- LLM出现幻觉现象，很多情况下并不是因为它们缺少对应的知识，而仅仅是在调用知识的过程中出错。他们发现：LLMs如果在回复一开始做出了错误的判断，那么它们随后会给出错误的解释（幻觉）。他们称这一现象为幻觉的滚雪球现象。但是，当仅给定错误的解释时，LLMs往往可以成功判断它是不正确的。这证明LLMs其实具备相应的知识，只是被早期的错误断言给误导了。
- ![](https://pic1.zhimg.com/80/v2-f5fc0ce70b63a167fd8d97a4b8199b5c_1440w.webp)

作者也探索了一些缓解幻觉滚雪球问题的方法：
- 更好的Prompt（CoT）：有效，但是CoT也存在着思维链内部的幻觉滚雪球问题。
- 解码算法：作者尝试了不同的解码算法，但并没有显著效果。
- 训练策略：构造更多的CoT训练数据，以及构造允许模型自我回溯（self-correct）的训练数据。

LLM幻觉的原子粒度评估
- [FActScore: Fine-grained Atomic Evaluation of Factual Precision in Long Form Text Generation](​arxiv.org/abs/2305.14251)

定义原子事实：仅包含一个信息的短句。

将LLM生成的内容（本文选用的内容是人物简介）分解为多个原子事实（instructGPT分解，人类校对），评估生成事实的精确度：
- ![](https://pic3.zhimg.com/80/v2-bb1701600ee6498e2916f5ccad808546_1440w.webp)

人工标注常用LLMs的原子事实精确度后，发现：
- 所有LLM都会出现较为严重幻觉问题，特别是原子粒度上；
- 检索增强的LLM（perplexity AI）能够缓解事实错误；
- 在生成和罕见实体相关的回复时，LLM更容易犯错；
- 模型在生成回复的后期，更容易出现幻觉；

作者也研究了基于LLM自动评估原子事实精确度的可能性（不可能每次对新模型评估都靠人工标注）：
- 检索增强能显著提升评估的效果；
- 更大的LLM能够更好地评估。

最后，作者基于自动指标，评估了现阶段LLM的原子事实性：
- ![](https://pic1.zhimg.com/80/v2-43dc369115a46e487b6d621e6638c9ac_1440w.webp)

有一些有趣的发现：比如Dolly模型经常频繁提及Databricks公司，导致事实错误（因为dolly的训练语料是databricks公司员工手写的）

最后作者研究了自动利用LLMs修复事实错误的可能性，发现在原子粒度纠正以及提供检索信息，能显著提高纠正的效果。
- ![](https://pic4.zhimg.com/80/v2-0f34e6f0cae7821ac1a7239014f7637f_1440w.webp)

除了模型生成事实的精确度外，还应该考虑召回度（即内容中的原子事实信息尽可能多），否则LLMs可能走捷径，生成一些无意义的废话。

#### 幻觉检测+修正

(1) 事实性增强的语言模型

面向LLM的事实/幻觉问题的早期工作(2022.6)。
- [Factuality Enhanced Language Models for Open-Ended Text Generation](​arxiv.org/abs/2206.04624)

本文首先基于FEVER数据集构建一个FactualPrompt数据集，包含了符合/不符合事实的提示，用于诱导LLM生成符合/不符合事实的下文。

评价指标：
- 幻觉实体率：对比生成内容和Golden Knowledge中实体的重叠率；
- 蕴含率：使用额外的NLI模型，评估生成内容有多少是被golden Knowledge蕴含的；
- 生成质量评估：除了幻觉现象外，还要确保生成的效果
- 流畅度：平均困惑度；
- 多样性：distinct n-grams；
- 重复度

从多个维度评估LLM生成的事实问题：
- 模型容量：更大的模型生成结果的事实性越好
- 提示类型：不符合事实的提示更可能诱导LLM生成不符合事实的内容；
- 解码算法：带有随机性的解码算法（如Top-P）显著比贪心解码生成的内容更不符合事实；
  - 基于这个发现作者还提出了一个非常简单的top-p解码算法优化，在生成的diversity和factuality中寻求trade-off：
  - p随时间步衰减（后期生成的内容更可能不符合事实），每次生成一个新句子（通过检测是否生成了句号）重新初始化p，并且p的衰减可以定一个下界；

作者还提出了一种继续预训练策略来提升事实性：
- 使用更权威的数据，如Wiki来训练；
- 给每个句子加上Wiki Document的名称：作者认为这能给句子提供额外的事实信息，比如解释句子里的代词（有点玄学）

(1) 基于外部知识和自动反馈提升事实性
- [Check Your Facts and Try Again: Improving Large Language Models with External Knowledge and Automated Feedback](​arxiv.org/abs/2302.12813)

通过外挂知识库和LLM自我审视，来提升LLM生成的事实性/效果：

主要包含以下部分：
- LLM Agent
  - 外部知识库：互联网、wiki百科等；
  - 动作执行器：
    - 知识检索：BM-25/Dense，通过给定prompt检索知识；
    - Prompt引擎：基于用户输入/知识/历史信息/反馈信息等，构造prompt，融合信息生成新的回复；
- 策略选择器：
  - 基于规则（是否通过utility模块）
  - 可学习（T5-based）
- 效用检验模块：
  - 打分器：用分数评估回复质量；
  - 反馈器：用自然语言给出回复评估；

本质上，该系统是一个检索知识->生成回复->评估的反复迭代/决策的过程，能够通过外部知识库和检查模块，显著提升生成的各维度效果，包括事实性。
- ![](https://pic2.zhimg.com/80/v2-efc1795288c922a06821fcbecd7e1fed_1440w.webp)


(3) 零资源黑盒LLM幻觉检测
- [paper](https://arxiv.org/abs/2303.08896)

作者认为传统的幻觉检测方法在当今LLM时代有如下的缺陷：
- 基于不确定度指标：这一类方法通过衡量LLM回复的熵/概率，来判断LLM对回复是否自信，越不自信越可能是编造的内容。但是该方法对闭源模型（如OpenAI）不友好。
- 基于事实验证指标：这一类方法需要外挂知识库，但是现在缺少涵盖所有世界知识的高质量知识库。

作者提出了SelfCheckGPT方法，核心的假设是：如果大模型非常肯定一个事实，那么它随机采样多次生成的回复，将对该事实有着近似的陈述（self-consistency）。如果多次采样，LLM都生成不同的陈述，那么很有可能是出现了幻觉。具体地，评估多个采样陈述是否一致，可以通过：1）BERTScore；2）QA-based；3）n-gram metric进行实现。
- [paper](https://arxiv.org/abs/2305.15852)

ETH-Zurich也有一篇类似的工作，着重关注LLM生成回复中的自相矛盾现象，包括评估、检测和消除。

(4) 零资源黑盒事实错误纠正
- [Zero-shot Faithful Factual Error Correction](​arxiv.org/abs/2305.07982)
- ![](https://pic3.zhimg.com/80/v2-e34655e569508abce7489e042a831e2a_1440w.webp)

提出了一个五步的零资源事实错误纠正流水线：
- Claim Answer抽取：从陈述中抽取关键信息；
- Question Generation：针对每个关键信息，生成一个问题；
- Question Answer：针对每个问题，将外部证据作为额外输入，进行回答；
- QA-to-claim：将QA-pair转回陈述；
- Correction scoring：额外打分器判断新的陈述是否合理。

(5) 工具增强的LLM自动纠正
- [CRITIC: Large Language Models Can Self-Correct with Tool-Interactive Critiquing](​arxiv.org/abs/2305.11738)

MSRA的工作，本文允许LLM在自我检查答案正确性的过程中调用外部工具，比如知识库、搜索引擎和维基百科，从而缓解事实性和幻觉问题。
- ![](https://pic2.zhimg.com/80/v2-2fed05cab24e4c188a90b23f235f80f9_1440w.webp)

(6) 通过推理时干预诱导LLM生成符合事实的答案
- [paper](https://arxiv.org/abs/2306.03341)

哈佛的工作，本文中作者提出了一种推理时干预的策略（ITI）提升LLM生成答案的事实性。

作者假设：
- LLMs know more than they say，LLM内部存在着隐藏的、可解释的结构，这些结构和事实性息息相关，因此可以通过干预：

作者探索了LLM的生成回复准确率（直接回答问题）和Probe准确率（用一个linear classifier基于中间状态选择回答）的关系，发现LLM很多情况下知道知识，但无法正确生成回复。
- ![](https://pic1.zhimg.com/80/v2-40cf1022364e571693210d4a654147c4_1440w.webp)

ITI方法选择和事实知识紧密相关的head，进行干预，让激活值移动到truthful相关的方向，实验表明能够有效提升回复的事实性。

(7) 训练小模型后处理幻觉问题

- [PURR: Efficiently Editing Language Model Hallucinations by Denoising Language Model Corruptions](​arxiv.org/abs/2305.14908)

Google的工作，核心思想是用LLM自动对一个正确样本生成幻觉样本，组成平行语料，训练一个T5学会降噪：
- 根据文档、干净的陈述，利用LLM对陈述进行加噪，使其含有幻觉问题；
- 将文档和含有幻觉的文本作为输入，干净的文本作为输出，训练一个小模型用于降噪（去幻觉）
- 推理时，对给定的陈述，先使用QG模型生成一系列问题，再根据问题召回证据，将证据文档和陈述传入小模型进行幻觉的编辑和修正。


(8) 利用多智能体辩论显著提升LM的事实性和推理能力
- [Improving Factuality and Reasoning in Language Models through Multiagent Debate](​arxiv.org/abs/2305.14325)

MIT&Google，利用多个智能体（LLM）相互辩论来解决事实性问题，相当于是一种变相的self-verify。
- ![](https://pic3.zhimg.com/80/v2-339a7d780994c55fdb4194a2f99d634e_1440w.webp)


(9) 人在回路的幻觉消除
- [Mitigating Language Model Hallucination with Interactive Question-Knowledge Alignment](​arxiv.org/abs/2305.13669)

本文提出基于人机交互，让LLM获得更好的知识-问题对齐，从而提升回复的事实性，减轻幻觉。
- ![](https://pic4.zhimg.com/80/v2-246069c89a58bdda1c512257c49e483b_1440w.webp)


#### Truthfulness

【2023-6-29】[拾象硅谷见闻系列：打破围绕开源LLM的6大迷思](https://mp.weixin.qq.com/s/rZRAwX58Ooqx1uNSM542tQ)

OpenAI 元老 John Schulman 4月下旬在伯克利有关 RLHF 和 Hallucination 的讲座
- Youtube: [John Schulman - Reinforcement Learning from Human Feedback: Progress and Challenges](https://www.youtube.com/watch?v=hhiLw5Q_UFg), Towards TruthGPT

他一针见血地指出
- 这类开源模型的做法只是“形似”，实际上降低了模型的 Truthfulness。

这一类模型的事实性上的缺陷：
>（关于 Hallucination 问题的出现）如果你使用同样的监督学习数据，然后训练另一个模型，那么同样的 Hallucination 问题会出现。现在有很多人使用 ChatGPT 的输出来微调其他模型，比如微调市面上的开源 Base Model，然后发现效果不错。但是如果认真观察事实准确度，会发现它们编造的比例比原始模型更高。

5 月，伯克利的论文 The False Promise of Imitating Proprietary LLMs 指出这种方式微调出来的指令遵循模型存在的一系列问题：
- 在缺少大量模仿 ChatGPT 数据支持的任务上，这类模型无法改善 Base Model 到 ChatGPT 的差距；
- 这类模型只是擅长模仿 ChatGPT 的风格，而不是事实性，导致实际的性能差异会骗过人类评估者；
- 当前开源模型最大的限制仍然是 Base Model 层面跟 GPT 系列的差距，在微调而不是预训练环境进行优化可能是不正确的方向；
- 为了广泛地匹配 ChatGPT 支持的任务，需要更广泛和大量的模仿数据集，还需要新的工作；
- ……

6 月份 Allen Institute for AI 和华盛顿大学的 How Far Can Camels GO？工作再次通过实验表明
- 不同的指令微调数据集可以释放或者增强特定的能力，但并<span style='color:red'>没有一个数据集或者组合可以在所有评估中提供最佳性能</span>，并且这一点在人类或模型担任评估者时也很容易无法被揭示。

对于指令遵循微调背后的团队来说，他们也意识到自己的模型由于 Base Model（LLaMA）的限制，在复杂推理和代码任务上很弱，并且难以进入正向数据飞轮 —— 模型能力越弱的领域越难得到更多的 query，也就难以筛选出高质量 query，想自己再标注提升模型能力就很困难。

至此，开源社区已经充分意识到原来这套微调 LLaMA 的框架的局限性，越来越多的团队开始探索预训练环节和更接近真实的人类反馈数据。我们也比较期待这两个方向上的进展，在迷思 4 中也会分享更多围绕这部分的观察。



#### 解法

#### 创业公司解法 

大模型的“幻觉”问题很可能导致Agent“教错”学生，蚂蚁云采用了一系列方法来解决该问题。
- 通过**模型融合**提高模型自身准确性；
- 引入“**反思**”“**自评估**”等思维工程方法
- 或者直接**外挂RAG**知识库、**知识图谱**等工具对模型加以“约束”。

【2024-4-12】[用大模型+Agent，把智慧教育翻新一遍](https://www.toutiao.com/article/7357976512986923571)

##### 斯坦福 WikiChat

【2023-10-27】斯坦福大学开发出一个**几乎不会产生幻觉**的模型：WikiChat, 将 GPT-4 蒸馏到 7b的LLaMA上，97.9% 显著超越所有基于检索的LLM，包括 GPT-4
- GitHub：[网页](https://github.com/stanford-oval/WikiChat)
- 论文：[WikiChat: Stopping the Hallucination of Large Language Model Chatbots by Few-Shot Grounding on Wikipedia](https://arxiv.org/pdf/2305.14292.pdf)
- 在线体验：[Wikipedia + LLM](wikichat.genie.stanford.edu)


WikiChat 基于英文维基百科信息。当它需要回答问题时，会先在维基百科上找到相关的、准确的信息，然后再给出回答，保证给出的回答既有用又可靠。

在混合人类和LLM的评估中，WikiChat达到了**97.3%**的事实准确性，同时也普遍高于其他模型。

它几乎不会产生幻觉，并且具有高对话性和低延迟。（⚠️给出的在线测试地址我试了几下都无法工作，所以也没法评估准确性）

主要特点：
- 高度准确：因为它直接依赖于维基百科这个权威且更新频繁的信息源，所以WikiChat在提供事实和数据时非常准确。
- 减少“幻觉”：LLM在谈论最新事件或不太流行的话题时容易产生错误信息。WikiChat通过结合维基百科数据，减少了这种信息幻觉的发生。
- 对话性强：尽管重视准确性，WikiChat仍然能够维持流畅、自然的对话风格。
- 适应性强：它可以适应各种类型的查询和对话场景。
- 高效性能：通过优化，WikiChat在回答问题时更快速，同时减少了运行成本。

工作原理：
- WikiChat利用模型蒸馏技术，将基于GPT-4的模型转化为更小、更高效的LLaMA模型（70亿参数），以提高响应速度和降低成本。
- WikiChat的工作流程涉及7个阶段，包括检索、摘要、生成、事实核查等，每个阶段都经过精心设计以保证整体对话的准确性和流畅性。
  - 1、检索信息: 当与用户进行对话时，WikiChat首先判断是否需要访问外部信息。例如，当用户提出具体问题或需要更全面的回答时。WikiChat生成一个搜索查询，以捕捉用户的兴趣，并根据这个查询从知识库（如维基百科）中检索相关信息。
  - 2、摘要和过滤: 检索到的信息可能包含相关和不相关的部分。WikiChat会提取相关部分，并将其摘要成要点，同时过滤掉无关内容。
  - 3、生成LLM响应: 接下来，使用大型语言模型（如GPT-4）生成对话历史的回应。这一步骤生成的内容通常既有趣又相关，但它本质上是不可靠的，因为它可能包含未经验证的或错误的信息。
  - 4、事实核查: WikiChat将LLM的回应分解为多个声明，并对每个声明进行事实核查。它使用检索系统从知识库中获取每个声明的证据，并基于这些证据对声明进行验证。只有那些被证据支持的声明才会被保留。
  - 5、形成回应: 最后，WikiChat使用经过筛选和验证的信息来形成一个吸引人的回应。这个过程分为两个步骤：首先生成**草稿**回应(draft)，然后根据相关性、自然性、非重复性和时间正确性对其进行**优化和改进**(refine)。
- ![](https://github.com/stanford-oval/WikiChat/raw/main/images/pipeline.svg)

在混合人类和大语言模型（LLM）评估方法下的表现：
- 1、高事实准确性：在模拟对话中，WikiChat的最佳系统达到了97.3%的事实准确性。这意味着它在回答问题或提供信息时，几乎所有的回应都是基于事实和真实数据的。
- 2、与GPT-4的比较：当涉及到头部知识（即常见或流行的主题）、尾部知识（即不常见或较少被讨论的主题）和最近的知识（即最新发生的事件或信息）时，WikiChat相比于GPT-4在事实准确性上分别提高了3.9%，38.6%和51.0%。这表明WikiChat在处理不同类型的信息时都有显著的改进，特别是在处理较少讨论的主题和最新信息方面。
- 3、与基于检索的聊天机器人的比较：与之前最先进的基于检索的聊天机器人相比，WikiChat不仅在事实准确性上表现更好，而且在提供信息量和吸引用户参与方面也表现得更加出色。这意味着WikiChat能够提供更丰富、更有趣的对话体验。

总体来说，WikiChat在处理复杂、动态和多样化的信息需求时的优越性能，尤其是在准确性和用户参与度方面的显著提升。


### 灾难遗忘

`灾难性遗忘`
- 一个任务上训练出来的模型，如果在一个新任务上进行训练，就会大大降低原任务上的泛化性能，即之前的知识被严重遗忘了。
- **灾难性遗忘** (catastrophic forgetting) 现象是在连续学习多个任务的过程中，学习新知识的过程会迅速破坏之前获得的信息，而导致模型性能在旧任务中急剧下降
- 论文 [Attention-Based Selective Plasticity]()
- ![](https://pic1.zhimg.com/80/v2-25443b3a57c5d2178c4480abefe4cd70_1440w.webp)
- `样本遗忘`（example forgetting）是受到灾难性遗忘现象的启发而提出的，即在同一个任务的训练过程中，也可能会有遗忘现象，一个样本可能在训练过程中反复地学了忘，忘了学。
  - 详见：[深度学习中的样本遗忘问题 (ICLR-2019)](https://zhuanlan.zhihu.com/p/462224273)

- ‘**灾难性遗忘**’指人工智能系统，如深度学习模型，在学习新任务或适应新环境时，忘记或丧失了以前习得的一些能力。”腾讯人工智能实验室副主任俞栋博士说，“灾难性遗忘”会造成人工智能系统在原有任务或环境性能大幅下降。[参考](https://picture.iczhiku.com/weixin/message1587593113355.html)
- 除了传统新知识学习会覆盖旧知识之外，谷歌大脑还发现，在如超级玛丽等探索型游戏里，‘灾难性遗忘’会阻碍模型对新知识的学习。

灾难性遗忘是**连接模型**（connectionist models，即神经网络）的一个不可避免的特征。

灾难性遗忘（catastrophic forgetting）：
- 在一个顺序无标注的、可能随机切换的、同种任务可能长时间不复现的 任务序列中，AI对当前任务B进行学习时，对先前任务A的知识会突然地丢失的现象。通常发生在对任务A很重要的神经网络的权重正好满足任务B的目标时。

- 解决了“灾难性遗忘”问题后，模型就能具备持续学习的能力, 可以像人类一样不断获取新的知识、新的技能，同时能够最大化地保持旧的经验知识和技巧。

#### 为什么会遗忘

主要原因
- 传统模型假设**数据分布固定或平稳**， 训练样本是**独立同分布**
- 所以模型一遍又一遍地看到所有任务相同的数据，但当数据变为**连续**的数据流时，训练数据的分布非平稳，模型从非平稳的数据分布中持续不断地获取知识时 新知识会干扰旧知识，从而导致模型性能的快速下降，甚至完全覆盖或遗忘以前学习到的旧知识。


#### 解决方法总结

【2023-10-23】[大规模语言模型--灾难性遗忘](https://mp.weixin.qq.com/s/1x9XapeT8l0Ijujfksg38w), [csdn](https://blog.csdn.net/weixin_43145427/article/details/134001503)

希望模型一方面必须表现出从新数据中整合新知识和提炼已有知识的能力 (可塑性)，另一方面又必须防止新输入对已有知识的显著干扰 (稳定性)。 
- 这两个互相冲突需求构成了所谓的**稳定性-可塑性困境** (stability-plasticity dilemma)。如图所示， 理想解决方案应确保稳定性(红色箭头) 和可塑性(绿色箭头) 之间的适当平衡， 以及对任务内(蓝色箭头) 和任务间 (橙色箭头)分布差异的泛化性。
- ![](https://img-blog.csdnimg.cn/img_convert/75e1dda4d1501034e60426b5e391147f.png)

`持续学习`是一种能够缓解深度学习模型灾难性遗忘的机器学习方法，包括**正则化方法**、**记忆回放**方法和**参数孤立**等方法，为了扩展模型的适应能力，让模型能够在不同时刻学习不同任务的知识，即模型学习到的数据分布，持续学习算法必须在保留旧知识与学习新知识之间取得平衡， 上图c 中展示了模型在学习过程中各个部 分的代表性策略。

`持续学习` (lifelong learning/continual learning)：
- 学习连贯的任务，而不会忘记如何执行之前训练过的任务的能力。

解决`灾难性遗忘`最简单粗暴的方案
- 使用所有已知的数据**重新**训练网络参数， 以适应数据分布随时间的变化。
- 尽管从头训练模型的确完全解决了灾难性遗忘问题，但这种方法效率非常低，极大地阻碍了模型实时地学习新数据。

而**增量学习**的主要目标就是在计算和存储资源有限的条件下，在`稳定性-可塑性困境`中寻找效用最大的平衡点。

对于 LLM 中的灾难性遗忘，往往会过拟合小型微调数据集，导致在其他任务上表现不佳。有学者提出了各 种方法来缓解 LLM 微调中的灾难性遗忘问题，包括预训练的权重衰减，学习率衰减、对抗性微调和参数高效微调。然而，这种灾难性的遗忘现象尚未得到彻底研究，需要持续关注。下图中列出了一些代表性的持续学习方法。
- ![](https://img-blog.csdnimg.cn/img_convert/a9f921b44b164bb7c77df23b56fca3cd.png)

解决“灾难性遗忘”的方案有哪些？
- **多任务学习**（最常见）, 把所有任务的训练数据同时放到一起，模型就可以针对多种任务进行联合优化。
- 根据**新任务知识**来扩充模型结构，保证旧的知识经验不被损害。
  - 谷歌大脑所提出的“记忆碎片观察”方法正是对不同任务（场景）构建多个人工智能模型来进行学习。“模型扩充的方式从本质上并没有解决灾难性遗忘的问题，只是用多个模型来替代单个模型去学习多种任务，避免旧参数被覆盖。”
- **特殊神经网络结构**
  - [Tree-CNN：一招解决深度学习中的「灾难性遗忘」](https://zhuanlan.zhihu.com/p/36097519), `树卷积神经网络`，通过先将物体分为几个大类，然后再将各个大类依次进行划分、识别，就像树一样不断地开枝散叶，最终叶节点得到的类别就是我们所要识别的类。
  - Self-refreshing Memory Approaches：代码见[原文](https://juejin.cn/post/6976045096475033637)
    - self-refreshing memory **自更新存储器**来存储已经学到的知识，并利用该存储的知识来不断“提醒”学习器不要忘记之前的学到的知识，从而达到避免灾难性遗忘的目的
    - **递归网络吸引子**：利用不断递归的混响过程来生成虚拟的知识实体（用来提醒学习器，以防止遗忘）
  - **知识蒸馏**：2014年Hinton提出来蒸馏神经网络。 更多见[原文](https://juejin.cn/post/6976045096475033637)
    - 蒸馏神经网络的核心依据有两点：1) 训练完成的神经网络包含历史数据的输出分布信息; 2) 神经网络具有相似的输入会得到相似的输出的特点。
    - 蒸馏法通过对共享参数进行微调来实现对新知识的学习。
  - **Transfer Techniques**： `迁移学习` 见[原文](https://juejin.cn/post/6976045096475033637)
    - 如何综合考虑旧参数与新数据得使得参数迁移到大家都满意的值

### 长期记忆

大模型目前在表达能力等方面其实已经很接近甚至超过人类了，预训练所获得的记忆知识更是堪称海量。但是如何让大模型快速的记住一件新的事，仍旧是尚待解决的问题。

#### 总结

思路
- 增大上下文**窗口长度**：只要上下文窗口长度够长，就可以把所有历史信息塞进去。
- `RAG`(Retrieval Augmented Generation)
  - 外挂数据库，但是从数据库取数回来怎么输入到模型是有不同方案的，一般是配合向量数据库，大量文档存在向量数据库内，外部有query输入的时候，从向量数据库搜索获取相关的文档，与query一并合入prompt再输入给模型。
    - 要做的事情很多：文本向量化的模型选择，文档搜索中的粗排与精排，乃至数据库的选择（其实不用向量数据库也可以）
  - LongMem: 类似Memorizing Tranformers，数据库中存储与取回的数据是**模型内部的kv向量**，输入也**不经过prompt**（不占用token数了好耶），直接通过改造过的层与backbone模型的输出合并再接入到输出头上。缺点是定制层需要额外的训练。

注
- RAG 把数据取出来重新加进prompt里，其实不像记忆，更像是人做的笔记

永久记忆的几种方法：
- **拓展Context长度**： 最流行
  - 大量的中间件或者技术，通过结合检索或者摘要的方式来缩短样本的长Context，如Unlimiformer
  - 由于不是直接处理长Context，因此通常无法做精细的阅读理解，而且需要在训练阶段就考虑进去，而不是事后即插即用到已有的LLM模型中
  - 不微调地扩展Context长度的方案
    - 最早由Parallel Context Window（下面简称PCW），出自论文《Parallel Context Windows for Large Language Models》和《Structured Prompting: Scaling In-Context Learning to 1,000 Examples》
    - 两篇论文是同一时期不同作者的工作，但所提的方法只有细微的差别
    - PCW适用于Self Attention模型，主要修改包括Position Encoding和Attention Mask
- **RoPE矩阵**
  - 构建一个位置相关的投影矩阵
- **FlashAttention**
  - 哈希感知（hash-aware）技术，根据相似性将输入序列中的元素分配到不同的桶（bucket）中。模型只需要计算桶元素之间的注意力权重，而不是整个序列！

#### LongMem

【2023-7-21】[LongMem: 大模型的长期记忆](https://zhuanlan.zhihu.com/p/642279963)

LongMem 要解决两个问题
- 1. 如何存储和召回数据： 存储与召回 Cache Memory Bank
  - 类似 Memorizing Tranformers，存储用的也是faiss，但有些改进，存储的是最后M个token对应的SideNet最后一层Attention中的K,V向量(M大概在几k到几十k的范围)。
  - 为了提高速度，没有采取在token级别上进行召回，而是把数个token作为一个chunk，做平均后作为key，在chunk层次上进行召回。
- 2. 如何将召回的数据混入到模型的输入：记忆混合 SideNet
  - Memorizing Transformers 用一个改造过的KnnAttention层来混入召回的向量，LongMem 用一个SideNet来处理这个工作。在训练时可以锁定backbone,只训练这个SideNet

#### MemGPT

【2023-10-20】[给LLM做手术！解决多轮遗忘，让他拥有永久记忆！人生伴侣可期？可在线+本地部署](https://mp.weixin.qq.com/s/lfE00ATg-pdO4u4xt6x-8Q)

[MemGPT](https://memgpt.ai) 方式 给LLM做一个外部手术
- 提出虚拟上下文管理，号称从传统操作系统中的分层内存系统中汲取灵感的技术！
- 该技术通过快速内存和慢速内存之间的数据移动提供大内存资源。使用这种技术，我们引入了MemGPT（Memory-GPT），这是一个智能管理不同内存层的系统，以便在LLM有限的上下文窗口内有效地提供扩展上下文，并利用中断来管理其自身和用户之间的控制流。

MemGPT 可以创建会话代理，通过与用户的长期交互来记忆、反映和动态消息。这相当于激活了LLM的“口袋”道具，让他可以装无限的东西，除了这个，他还可以加载文档，以及本地数据库！

完全可以当做一个中间组件拓展来使用


### 效果下滑

【2023-7-24】[GPT-4 越来越笨？](https://www.oschina.net/news/250147/gpt-4-response-quality-study)准确率从 97.6% 降至 2.4%

斯坦福大学和加州大学伯克利分校合作进行的一项 “[How Is ChatGPT's Behavior Changing Over Time?](https://arxiv.org/pdf/2307.09009.pdf)” 研究表明，随着时间的推移，GPT-4 的响应能力非但没有提高，反而随着语言模型的进一步更新而变得更糟糕。

研究小组评估了 2023 年 3 月和 2023 年 6 月版本的 GPT-3.5 和 GPT-4 在四个不同任务上的表现，分别为：解决数学问题、回答敏感 / 危险问题、代码生成以及视觉推理。

使用了一个包含 500 个问题的数据集评估模型，测试模型必须确定给定的整数是否是素数。结果表明，GPT-4（2023 年 3 月版）在识别质数方面表现非常出色，正确回答了其中的 488 个问题，准确率达 97.6%。但 GPT-4 （2023 年 6 月版）在这些问题上的表现却非常糟糕，只答对了 12 个问题，准确率仅为 2.4%。
- ![](https://oscimg.oschina.net/oscnet/up-b6d604ee90d793b9d1e414a6690d42817e3.png)

而与之相反，GPT-3.5（2023 年 6 月版）在这项任务中的表现则要比 GPT-3.5（2023 年 3 月版）好得多。


## LLM 优化方向

【2023-6-16】知乎专题：[大模型LLM领域，有哪些可以作为学术研究方向？](https://www.zhihu.com/question/595298808/answer/3071907155)

- **模型层**：
  - GPT系列，多模态系列，视觉类SAM：原生的工具调用能力；
  - 安全性：加密，可信任，联邦学习；
  - 新模型，新范式：长文本建模，不需要RLHF等；
  - 涌现问题的研究、黑盒的研究；
  - 并行、运算、显存的优化。EL-Attention，ZeRo，剪枝部署，蒸馏压缩。
- **接口层**：
  - 私有化部署；
  - Adapter，prefix，Lora；
  - Fusing。
- **应用层**：
  - Visual ChatGPT，HuggingGPT，AutoGPT，LangChain；
  - Prompt工程，向量库，dense retrieval；
  - 自我纠错，自我迭代，chain of thought的加强；
  - 评测数据集、新时代下的新任务，generatice agents等

假设自己已经有了GPT-3.5基础模型，假设自己有一千张卡，思考能做什么？然后用小的模型，比如LLaMa 7B去验证，如果成功，再慢慢加大到13B，30B，画出一条上升的曲线；不一定要scale到最大的模型，只要自己的结论能划出一条上升的曲线，那么这条曲线就可外推到更大。

源自知乎：[LessTalk](https://www.zhihu.com/question/595298808/answer/3071907155)

- 平台工具及工程化部署
- 小模型拟合大模型降低计算量
- 多模态的输入与输出
- Prompt Engineering
- 垂直领域应用 搜索+知识图谱、机器人、自动驾驶等

提纲
- 基础理论：大模型的基础理论是什么？
- 网络架构：Transformer是终极框架吗？
- 高效计算：如何使大模型更加高效？
- 高效适配：大模型如何适配到下游任务？
- 可控生成：如何实现大模型的可控生成？
- 安全可信：如何改善大模型中的安全伦理问题？
- 认知学习：如何使大模型获得高级认知能力？
- 创新应用：大模型有哪些创新应用？
- 数据评价：如何评估大模型的性能？
- 易用性：如何降低大模型的使用门槛？

作者：[zibuyu9](https://www.zhihu.com/question/595298808/answer/3047369015)

其它
- reasoning 逻辑推理：目前llm能力还不够的地方。比如能不能让llm做leetcode hard。进一步的，能不能自己创造新的知识，解决哥德巴赫猜想。
- compression and acceleration 模型压缩与加速：怎么把一个10b的模型弄到手机上并高速运行
- agent：怎么更好的给llm加上眼睛与手脚，让llm变成agent执行任务，并构造各种各样全新的benchmark。比如让agent发知乎回答以点赞多为目标。能不能通过RL把这件事做了?就和当年搞游戏ai一样。
- multi-modal 多模态：GPT-4没有开源，甚至没有技术细节，怎么做一个开源的逼近gpt-4的模型。mini-gpt4, llava是个不错的尝试。
- Hallucination 幻觉问题：GPT-4已经好了很多，但仍然没有完全解决。所以因此马斯克说要做TruthGPT. 要让LLM知之为知之不知为不知。这个难度其实很大。
- Evaluation。开源世界需要一套新的Evaluation的方法来评估llm的效果，从而方便推进开源llm的进展。
- dataset。这个是chatgpt被创造出来的源头。所以，能否多构建一个专家的数据库来帮助优化llm呢？每一份开源数据都非常有价值。

论文：[A PhD Student’s Perspective on Research in NLP in the Era of Very Large Language Models](https://arxiv.org/pdf/2305.12544.pdf)


### 可控生成

【2023-7-10】[LLM 可控生成初探](https://mp.weixin.qq.com/s/BngY2WgCcpTOlvdyBNJxqA)

基于 LLM 的应用开发过程中，有几个常见的挑战，包括：
- 如何避免“胡说八道”, 提升模型输出的**可靠性/稳定性**
- 控制模型的计算开销和响应速度等等

目前主流的解决手段包括：
- 更好的 prompt 设计
- 通过 retrieval 来做增强
- 与外部工具的结合
- 流程编排与产品设计
- 考虑使用 fine tune 模型或混合模型应用

|Prompt优化类型|latency|compute|
|---|---|---|
|Few-Shot CoT|🔼🔼|💰💰|
|Zero-Shot CoT|🔼|💰|
|Decomposition|🔼🔼|💰💰|
|Ensembling|✅|💰💰💰💰|
|Self-Criticism|🔼🔼🔼🔼|💰💰|
||||

可控生成，最直接的方案：
- 首先通过 prompt 告知 LLM 我们所需要的返回格式，并进行生成。
- 通过一些规则来检查返回结果，如果不符合格式，生成相关错误信息。
- 将上一次的生成内容和检查的错误信息告知 LLM，进行下一次的修正生成。
- 重复 2-3 步骤，直到生成的内容完全符合要求。

LLM 的可控性、稳定性、事实性、安全性等问题是推进企业级应用中非常关键的问题，下面这些项目在这方面做了很多探索，也有很多值得借鉴的地方。

总体思路上来说，主要是：
- 提供一套 prompt 模板定义，允许用户指定 LLM 生成的格式或内容主题。
- 在模板基础上，也有不少项目进一步设计了相应的编程语言，让 LLM 与确定性程序的交互更加直观。
- 提供各类 validator，保证生成内容符合预期，并且提供了自动处理/修正机制。
- 更进一步，也可以在生成前进行干预，例如在 prompt 中给近似案例，修改模型 decode 时的概率分布等。
- 其它在可控性基础上做的各种性能与开销的优化，例如缓存，减少 token 消耗量，对开源模型能力的挖掘等。

即使不直接使用上述的项目做开发，也可以从中学习到很多有用的思路。当然也非常期待这个领域出现更多有意思的想法与研究，以及 prompt 与编程语言结合能否碰撞出更多的火花。

详见原文：[LLM 可控生成初探](https://mp.weixin.qq.com/s/BngY2WgCcpTOlvdyBNJxqA)

#### guardrails

guardrails 项目将上述步骤做了进一步的抽象与封装，提供更加 high level 的配置与 API 来完成整个过程。其主要的组成部分包括：
- 定义了一套RAIL spec，用来描述上面第 1 点提到的返回格式限定。除了 output schema 的定义外，RAIL目前也支持 input schema，prompt 模板，以及 instructions 等其它配置。
- 提供了一系列的 validation 机制，对应上面的第 2 点。对于 validate 失败的部分，会保留其在 output schema 中的位置，生成相应的错误信息。
- 通过ReAsk类来实现上面的第 3 点，发送给 LLM 的内容会更聚焦于错误信息部分，且保留了结构，更便于 LLM 理解和处理。
- 其它像常用 prompt 模板之类的功能。

#### NeMo-Guardrails

NeMo-Guardrails
- 来自 Nvidia 的一个同名项目，比 guardrails 更有野心，想要确保 LLM 应用整体的**可信度**，**无害性**以及数据**安全性**等，而不仅仅只是输出的结构化检查和修复。
- 因此其实现思路上也复杂不少，设计了一种专门的 Colang 语言，来支持更加通用多样的业务流，而不仅仅是**生成 -> 检查 -> 修复**。
- 这个项目会更专注于用户与 LLM 的对话式交互应用，主要的设计都是围绕这个前提展开。

#### guidance

guidance
- 微软推出的开源项目，几个作者看头像就很知名，分别是 shap，lime，checklist 的作者。之前有研究过 可解释机器学习的同学应该不会陌生。从 explainable ai 到 controlable llm，倒也是很说得通的发展路径

guardrails 中的做法是在 prompt 中给出说明和示范，希望 LLM 能够遵循指令来输出。但现实中往往会出现各种问题，例如额外带了一些其它的文字说明，或者生成的 json 格式不正确等，所以需要后续的 ReAsk 来进行修正。LangChain 里也提供了各种 output parser 来帮忙提取回复中的结构化信息部分，但也经常容易运行失败。

在 guidance 中，同样是通过“模板语言”来定义 LLM 的输出结构，以确保输出格式的正确性。这个结构比起 xml 来说会更易写易理解些

guidance 将更加复杂的 Handlebars 模板 融入到了 prompt 中，使得原先需要复杂设计的 LLM 生成与程序处理交互过程可以很方便地在 prompt 中直接完成。在上面的例子中，只有当调用到{{gen}}命令时，才会触发 LLM 的生成操作。另外也有像{{select}}，{{#geneach}}，函数调用，逻辑判断，控制流等命令，有种结合了自然语言与编程语言两者长处的感觉。

除了 prompt 模板编程能力外，guidance 还有一系列高级特性，包括：
- 支持 hidden block，例如 LLM 的一些推理过程可能并不需要暴露给最终用户，就可以灵活利用这个特性来生成一些中间结果。
- Generation caching，自动把已经生成过的结果缓存起来，提升速度。
- 支持 HuggingFace 模型的 guidance acceleration，进一步提升生成速度。
- Token healing，不看这个我还不知道 LLM 有这种问题……
- Regex pattern guide，在模板的基础上进一步通过正则表达来限定生成的内容规范。

#### lmql

在 guidance 的基础上，lmql 项目进一步把“prompt 模板”这个概念推进到了一种新的编程语言，倒是有点像前面 guardrails 跟 NeMo-Guardrails 的关系。项目本身提供了很漂亮的 playground 方便试用，注意如果要在本地玩这个项目，需要升级到 Python 3.10 的版本。



### 知识植入 


LLMs 依然会受到**知识截断**和**谬误**问题的限制。例如，ChatGPT 和 LlaMA 等 LLMs 仅具备截至训练最后时点的信息，也可能会因预训练数据中的偏见和差异生成不准确或误导性的输出。因此，高效更新 LLMs 的参数化知识进而调整特定行为，变得至关重要。

解决办法
- 尽管**微调**和**参数高效微调**可以修改 LLMs，但成本较高，还可能导致 LLMs 失去预训练所得能力，并且其修改也不总能泛化到相关输入。
- 使用**手动编写**或**检索**的提示影响 LLMs 的输出，但这类方法没有参数更新，可靠性不足。


#### 知识编辑 

为了使不相关输入的影响最小化，并迅速有效地修改 LLMs 的行为，一种可行的解决方案是**知识编辑**。关于 LLMs 的知识编辑研究在各种任务和设置下取得显著进展，包括 `Memory based`、`Meta-learning` 和 `Locate-Then-Edit` 三类方法。

Methods

(1) [Preserve Parameters](https://github.com/zjunlp/KnowledgeEditingPapers#preserve-parameters)
- ① [Memory-based](https://github.com/zjunlp/KnowledgeEditingPapers#memory-based)
1.  **Memory-Based Model Editing at Scale** (ICML 2022)  
  - Eric Mitchell, Charles Lin, Antoine Bosselut, Christopher D. Manning, Chelsea Finn. \[[paper](https://arxiv.org/abs/2206.06520)\] \[[code](https://github.com/eric-mitchell/serac)\] \[[demo](https://sites.google.com/view/serac-editing)\]
2.  **Fixing Model Bugs with Natural Language Patches**. (EMNLP 2022)  
    Shikhar Murty, Christopher D. Manning, Scott M. Lundberg, Marco Túlio Ribeiro. \[[paper](https://arxiv.org/abs/2211.03318)\] \[[code](https://github.com/MurtyShikhar/LanguagePatching)\]
3.  **MemPrompt: Memory-assisted Prompt Editing with User Feedback**. (EMNLP 2022)  
    Aman Madaan, Niket Tandon, Peter Clark, Yiming Yang. \[[paper](https://arxiv.org/abs/2201.06009)\] \[[code](https://github.com/madaan/memprompt)\] \[[page](https://memprompt.com/)\] \[[video](https://www.youtube.com/watch?v=Ld7R02bOiNQ&t=1s)\]
4.  **Large Language Models with Controllable Working Memory**.  
    Daliang Li, Ankit Singh Rawat, Manzil Zaheer, Xin Wang, Michal Lukasik, Andreas Veit, Felix Yu, Sanjiv Kumar. \[[paper](https://arxiv.org/abs/2211.05110)\]
5.  **Can We Edit Factual Knowledge by In-Context Learning?**  
    Ce Zheng, Lei Li, Qingxiu Dong, Yuxuan Fan, Zhiyong Wu, Jingjing Xu, Baobao Chang. \[[paper](https://arxiv.org/abs/2305.12740)\]
6.  **Can LMs Learn New Entities from Descriptions? Challenges in Propagating Injected Knowledge**  
    Yasumasa Onoe, Michael J.Q. Zhang, Shankar Padmanabhan, Greg Durrett, Eunsol Choi. \[[paper](https://arxiv.org/abs/2305.01651)\]
7.  **MQUAKE: Assessing Knowledge Editing inLanguage Models via Multi-Hop Questions**  
    Zexuan Zhong, Zhengxuan Wu, Christopher D. Manning, Christopher Potts, Danqi Chen.  
    .\[[paper](https://arxiv.org/abs/2305.14795)\]

- ② [Additional Parameters](https://github.com/zjunlp/KnowledgeEditingPapers#additional-parameters)
1.  **Calibrating Factual Knowledge in Pretrained Language Models**. (EMNLP 2022)  
    Qingxiu Dong, Damai Dai, Yifan Song, Jingjing Xu, Zhifang Sui, Lei Li. \[[paper](https://arxiv.org/abs/2210.03329)\] \[[code](https://github.com/dqxiu/CaliNet)\]
2.  **Transformer-Patcher: One Mistake worth One Neuron**. (ICLR 2023)  
    Zeyu Huang, Yikang Shen, Xiaofeng Zhang, Jie Zhou, Wenge Rong, Zhang Xiong. \[[paper](https://arxiv.org/abs/2301.09785)\] \[[code](https://github.com/ZeroYuHuang/Transformer-Patcher)\]
3.  **Aging with GRACE: Lifelong Model Editing with Discrete Key-Value Adaptors**.  
    Thomas Hartvigsen, Swami Sankaranarayanan, Hamid Palangi, Yoon Kim, Marzyeh Ghassemi. \[[paper](https://arxiv.org/abs/2211.11031)\] \[[code](https://github.com/thartvigsen/grace)\]
4.  **Neural Knowledge Bank for Pretrained Transformers**  
    Damai Dai, Wenbin Jiang, Qingxiu Dong, Yajuan Lyu, Qiaoqiao She, Zhifang Sui. \[[paper](http://arxiv.org/abs/2208.00399)\]

- ③ [Change LM's representation space](https://github.com/zjunlp/KnowledgeEditingPapers#change-lms-representation-space)

1.  **Inspecting and Editing Knowledge Representations in Language Models**  
  - Evan Hernandez, Belinda Z. Li, Jacob Andreas. \[[paper](http://arxiv.org/abs/2304.00740)\] \[[code](https://github.com/evandez/REMEDI)\]

（2）[Modify Parameters](https://github.com/zjunlp/KnowledgeEditingPapers#modify-parameters)

① [Finetuning](https://github.com/zjunlp/KnowledgeEditingPapers#finetuning)

1.  **Plug-and-Play Adaptation for Continuously-updated QA**. (ACL 2022 Findings)  
  - Kyungjae Lee, Wookje Han, Seung-won Hwang, Hwaran Lee, Joonsuk Park, Sang-Woo Lee. \[[paper](https://arxiv.org/abs/2204.12785)\] \[[code](https://github.com/wookjeHan/Plug-and-Play-Adaptation-for-Continuously-updated-QA)\]
2.  **Modifying Memories in Transformer Models**.  
  - Chen Zhu, Ankit Singh Rawat, Manzil Zaheer, Srinadh Bhojanapalli, Daliang Li, Felix Yu, Sanjiv Kumar. \[[paper](https://arxiv.org/abs/2012.00363)\]
    

②  [Meta-learning](https://github.com/zjunlp/KnowledgeEditingPapers#meta-learning)

1.  **Editing Factual Knowledge in Language Models**.  
  - Nicola De Cao, Wilker Aziz, Ivan Titov. (EMNLP 2021) \[[paper](https://arxiv.org/abs/2104.08164)\] \[[code](https://github.com/nicola-decao/KnowledgeEditor)\]
2.  **Fast Model Editing at Scale**. (ICLR 2022)  
  - Eric Mitchell, Charles Lin, Antoine Bosselut, Chelsea Finn, Christopher D. Manning. \[[paper](https://arxiv.org/abs/2110.11309)\] \[[code](https://github.com/eric-mitchell/mend)\] \[[page](https://sites.google.com/view/mend-editing)\]
3.  **Editable Neural Networks**. (ICLR 2020)  
  - Anton Sinitsin, Vsevolod Plokhotnyuk, Dmitry V. Pyrkin, Sergei Popov, Artem Babenko. \[[paper](https://arxiv.org/abs/2004.00345)\] \[[code](https://github.com/xtinkt/editable)\]
    

③ [Locate and edit](https://github.com/zjunlp/KnowledgeEditingPapers#locate-and-edit)

1.  **Editing a classifier by rewriting its prediction rules**. (NeurIPS 2021)  
  - Shibani Santurkar, Dimitris Tsipras, Mahalaxmi Elango, David Bau, Antonio Torralba, Aleksander Madry. \[[paper](https://proceedings.neurips.cc/paper/2021/hash/c46489a2d5a9a9ecfc53b17610926ddd-Abstract.html)\] \[[code](https://github.com/MadryLab/EditingClassifiers)\]
2.  **Language Anisotropic Cross-Lingual Model Editing**.  
  - Yang Xu, Yutai Hou, Wanxiang Che. \[[paper](https://arxiv.org/abs/2205.12677)\]
3.  **Repairing Neural Networks by Leaving the Right Past Behind**.  
  - Ryutaro Tanno, Melanie F. Pradier, Aditya Nori, Yingzhen Li. \[[paper](https://arxiv.org/abs/2207.04806)\]
4.  **Locating and Editing Factual Associations in GPT**. (NeurIPS 2022)  
  - Kevin Meng, David Bau, Alex Andonian, Yonatan Belinkov. \[[paper](https://arxiv.org/abs/2202.05262)\] \[[code](https://github.com/kmeng01/rome)\] \[[page](https://rome.baulab.info/)\] \[[video](https://www.youtube.com/watch?v=_NMQyOu2HTo&t=0)\]
5.  **Mass-Editing Memory in a Transformer**.  
  - Kevin Meng, Arnab Sen Sharma, Alex Andonian, Yonatan Belinkov, David Bau. \[[paper](https://arxiv.org/abs/2210.07229)\] \[[code](https://github.com/kmeng01/memit)\] \[[page](https://memit.baulab.info/)\] \[[demo](https://memit.baulab.us/#/)\]
6.  **Editing models with task arithmetic** .  
  - Gabriel Ilharco, Marco Tulio Ribeiro, Mitchell Wortsman, Ludwig Schmidt, Hannaneh Hajishirzi, Ali Farhadi. \[[paper](https://openreview.net/pdf?id=6t0Kwf8-jrj)\]
7.  **Editing Commonsense Knowledge in GPT** .  
  - Anshita Gupta, Debanjan Mondal, Akshay Krishna Sheshadri, Wenlong Zhao, Xiang Lorraine Li, Sarah Wiegreffe, Niket Tandon. \[[paper](https://arxiv.org/abs/2305.14956)\]
8.  **Do Language Models Have Beliefs? Methods for Detecting, Updating, and Visualizing Model Beliefs**.  
  - Peter Hase, Mona Diab, Asli Celikyilmaz, Xian Li, Zornitsa Kozareva, Veselin Stoyanov, Mohit Bansal, Srinivasan Iyer. \[[paper](https://arxiv.org/pdf/2111.13654.pdf)\] \[[code](https://github.com/peterbhase/SLAG-Belief-Updating)\]
9.  **Detecting Edit Failures In Large Language Models: An Improved Specificity Benchmark** .  
  - Jason Hoelscher-Obermaier, Julia Persson, Esben Kran, Ioannis Konstas, Fazl Barez. \[[paper](https://arxiv.org/abs/2305.17553)\]
10.  **Knowledge Neurons in Pretrained Transformers**.(ACL 2022)  
  - Damai Dai , Li Dong, Yaru Hao, Zhifang Sui, Baobao Chang, Furu Wei.\[[paper](http://arxiv.org/abs/2104.08696)\] \[[code](https://github.com/Hunter-DDM/knowledge-neurons)\] \[[code by EleutherAI](https://github.com/EleutherAI/knowledge-neurons)\]
11.  **LEACE: Perfect linear concept erasure in closed form** .  
  - Nora Belrose, David Schneider-Joseph, Shauli Ravfogel, Ryan Cotterell, Edward Raff, Stella Biderman. \[[paper](https://arxiv.org/abs/2306.03819)\]
12.  **Transformer Feed-Forward Layers Are Key-Value Memories**. (EMNLP 2021)  
  - Mor Geva, Roei Schuster, Jonathan Berant, Omer Levy. \[[paper](https://arxiv.org/abs/2012.14913)\]
13.  **Transformer Feed-Forward Layers Build Predictions by Promoting Concepts in the Vocabulary Space**.(EMNLP 2022)  
  - Mor Geva, Avi Caciularu, Kevin Ro Wang, Yoav Goldberg. \[[paper](https://arxiv.org/abs/2203.14680)\]
14.  **PMET: Precise Model Editing in a Transformer.**  
  - Xiaopeng Li, Shasha Li, Shezheng Song, Jing Yang, Jun Ma, Jie Yu. \[[paper](https://arxiv.org/abs/2308.08742)\] \[[code](https://github.com/xpq-tech/PMET.git)\]
    

（3） [More Related Papers](https://github.com/zjunlp/KnowledgeEditingPapers#more-related-papers)

1.  **FRUIT: Faithfully Reflecting Updated Information in Text**. (NAACL 2022)  
    Robert L. Logan IV, Alexandre Passos, Sameer Singh, Ming-Wei Chang. \[[paper](https://github.com/zjunlp/KnowledgeEditingPapers/blob/main)\] \[[code](https://github.com/zjunlp/KnowledgeEditingPapers/blob/main)\]
    
2.  **Entailer: Answering Questions with Faithful and Truthful Chains of Reasoning**. (EMNLP 2022)  
    Oyvind Tafjord, Bhavana Dalvi Mishra, Peter Clark. \[[paper](https://arxiv.org/abs/2210.12217)\] \[[code](https://github.com/allenai/entailment_bank)\] \[[video](https://www.youtube.com/watch?v=GYTJ_Pxva7Q)\]
    
3.  **Towards Tracing Factual Knowledge in Language Models Back to the Training Data**.  
    Ekin Akyürek, Tolga Bolukbasi, Frederick Liu, Binbin Xiong, Ian Tenney, Jacob Andreas, Kelvin Guu. (EMNLP 2022) \[[paper](https://arxiv.org/abs/2204.12785)\]
    
4.  **Prompting GPT-3 To Be Reliable**.  
    Chenglei Si, Zhe Gan, Zhengyuan Yang, Shuohang Wang, Jianfeng Wang, Jordan Boyd-Graber, Lijuan Wang. \[[paper](https://arxiv.org/abs/2210.09150)\]
    
5.  **Patching open-vocabulary models by interpolating weights**. (NeurIPS 2022)  
    Gabriel Ilharco, Mitchell Wortsman, Samir Yitzhak Gadre, Shuran Song, Hannaneh Hajishirzi, Simon Kornblith, Ali Farhadi, Ludwig Schmidt. \[[paper](https://arxiv.org/abs/2208.05592)\] \[[code](https://github.com/mlfoundations/patching)\]
    
6.  **Decouple knowledge from paramters for plug-and-play language modeling** (ACL2023 Findings)  
    Xin Cheng, Yankai Lin, Xiuying Chen, Dongyan Zhao, Rui Yan.\[[paper](http://arxiv.org/abs/2305.11564)\] \[[code](https://github.com/Hannibal046/PlugLM)\]
    
7.  **Backpack Language Models**  
    John Hewitt, John Thickstun, Christopher D. Manning, Percy Liang. \[[paper](https://arxiv.org/pdf/2305.16765.pdf)\]
    
8.  **Learning to Model Editing Processes**. (EMNLP 2022)  
    Machel Reid, Graham Neubig. \[[paper](https://aclanthology.org/2022.findings-emnlp.280.pdf)\]

 [Analysis](https://github.com/zjunlp/KnowledgeEditingPapers#analysis)

1.  **Does Localization Inform Editing? Surprising Differences in Causality-Based Localization vs. Knowledge Editing in Language Models.**  
    Peter Hase, Mohit Bansal, Been Kim, Asma Ghandeharioun. \[[paper](https://arxiv.org/pdf/2301.04213.pdf)\] \[[code](https://github.com/google/belief-localization)\]
2.  **Dissecting Recall of Factual Associations in Auto-Regressive Language Models**  
    Mor Geva, Jasmijn Bastings, Katja Filippova, Amir Globerson. \[[paper](https://arxiv.org/abs/2304.14767)\]
3.  **Evaluating the Ripple Effects of Knowledge Editing in Language Models**  
    Roi Cohen, Eden Biran, Ori Yoran, Amir Globerson, Mor Geva. \[[paper](https://arxiv.org/abs/2307.12976)\]
4.  **Edit at your own risk: evaluating the robustness of edited models to distribution shifts.**  
    Davis Brown, Charles Godfrey, Cody Nizinski, Jonathan Tu, Henry Kvinge. \[[paper](https://arxiv.org/abs/2303.00046)\]


##### FastEdit 北航

快速注入知识

- 【2022-2-10】Rank-One Model Editing (ROME): [Locating and Editing Factual Associations in GPT](https://arxiv.org/abs/2202.05262), [demo](https://rome.baulab.info/)

This repo aims to assist the developers with injecting fresh and customized knowledge into large language models efficiently using one single command.

Supported Models
-   [GPT-J](https://huggingface.co/EleutherAI/gpt-j-6b) (6B)
-   [LLaMA](https://github.com/facebookresearch/llama) (7B/13B)
-   [LLaMA-2](https://huggingface.co/meta-llama) (7B/13B)
-   [BLOOM](https://huggingface.co/bigscience/bloomz) (7.1B)
-   [Falcon](https://huggingface.co/tiiuae/falcon-7b) (7B)
-   [Baichuan](https://huggingface.co/baichuan-inc/Baichuan-7B) (7B/13B)
-   [InternLM](https://github.com/InternLM/InternLM) (7B)

[Implemented Algorithms](https://github.com/hiyouga/FastEdit#implemented-algorithms)
-   [Rank-One Model Editing (ROME)](https://arxiv.org/abs/2202.05262)


```sh
git clone https://github.com/hiyouga/FastEdit.git
conda create -n fastedit python=3.10
conda activate fastedit
cd FastEdit
pip install -r requirements.txt
# 或
pip install pyfastedit
```

Model Editing

```sh
CUDA_VISIBLE_DEVICES=0 python -m fastedit.editor \
    --data data/example.json \
    --model EleutherAI/gpt-j-6b \
    --config gpt-j-6b \
    --template default
```

##### EasyEdit 浙大 -- 开源

【2023-8-16】[浙大出品：大模型轻松获取“世界知识”，比传统微调效果更好](https://www.toutiao.com/article/7267801834855727679)
- 知识编辑 papaerlist: [Knowledge Editing for LLMs Papers](https://github.com/zjunlp/KnowledgeEditingPapers)
- 【2023-5-23】[Editing Large Language Models: Problems, Methods, and Opportunities](https://arxiv.org/abs/2305.13172)
- ![](https://github.com/zjunlp/KnowledgeEditingPapers/raw/main/img/overview.jpg)

浙江大学和东海实验室的研究团队提出了一个易于使用的 LLMs 知识编辑框架——`EasyEdit`，该框架支持各种知识编辑方法，且可以轻松应用于众多 LLMs，如 T5、GPT-J 和 LlaMA 等。
- 论文 [EasyEdit: An Easy-to-use Knowledge Editing Framework for Large Language Models](https://arxiv.org/abs/2308.07269)
- 代码 [EasyEdit](https://github.com/zjunlp/EasyEdit)

然而，目前关于 `LLMs 知识编辑`的研究在实现和任务设置上的差异妨碍了知识编辑统一和综合框架的发展。值得注意的是，这种复杂性阻碍了不同方法之间有效性和可行性的直接比较，也使得创建新的知识编辑方法变得复杂。

EasyEdit 框架整合了各种编辑技术，支持在不同 LLMs 之间自由组合模块。通过统一的框架和接口，EasyEdit 能使用户迅速理解并应用包含在该框架中的主流知识编辑方法。EasyEdit 具有统一的 Editor、Method 和 Evaluate 框架，分别代表**编辑场景**、**编辑技术**和**评估方法**。
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/Tn4iCdrGGtbIFt~tplv-tt-origin-asy2:5aS05p2hQOWkp-aVsOaNruaWh-aRmA==.image?_iz=58558&from=article.pc_detail&x-expires=1693797824&x-signature=qjF%2FeWeSs6aesEsE1h%2BZuHMGRz8%3D)
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/Tn4iCf8CHe0fQA~tplv-tt-origin-asy2:5aS05p2hQOWkp-aVsOaNruaWh-aRmA==.image?_iz=58558&from=article.pc_detail&x-expires=1693797824&x-signature=4GKQB2crsR9z9gIr9p31Cav6dq8%3D)


EasyEdit 还提供了五个评估编辑方法性能的关键指标，包括`可靠性`（Reliability）、`泛化性`（Generalization）、`局部性`（Locality）、`可移植性`（Portability）和`效率`（Efficiency）。

为验证知识编辑在 LLMs 中的应用潜力，研究团队选用了参数庞大的 LlaMA 2 模型，并利用 ZsRE 数据集（QA 数据集）来测试知识编辑将大量一般事实关联整合进模型的能力。测试结果证明，EasyEdit 在可靠性和泛化性方面超越了传统的微调方法。
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/Tn4iCiL5n53x88~tplv-tt-origin-asy2:5aS05p2hQOWkp-aVsOaNruaWh-aRmA==.image?_iz=58558&from=article.pc_detail&x-expires=1693797824&x-signature=wQPBTjiUF%2FX%2BszdxJIiTV%2FbPDe8%3D)



### 模型结构

详见 [LLM 架构代码详解](llm_code)

### 图解

总结LLM各阶段优化方向

<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2023-06-22T15:10:12.254Z\&quot; agent=\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\&quot; etag=\&quot;V_7K2ib4bP-NWsyXjMxV\&quot; version=\&quot;21.5.0\&quot;&gt;\n  &lt;diagram id=\&quot;xdYpP7w1t2VaaceZiyqw\&quot; name=\&quot;第 1 页\&quot;&gt;\n    &lt;mxGraphModel dx=\&quot;1242\&quot; dy=\&quot;795\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;\n      &lt;root&gt;\n        &lt;mxCell id=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-35\&quot; value=\&quot;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#f9f7ed;strokeColor=#36393d;dashed=1;dashPattern=1 1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;90\&quot; y=\&quot;300\&quot; width=\&quot;180\&quot; height=\&quot;360\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;wGYBfAiltT4hGnPjrrAm-8\&quot; value=\&quot;LLM改进方向\&quot; style=\&quot;text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=19;rotation=0;strokeWidth=3;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;242\&quot; y=\&quot;70\&quot; width=\&quot;216\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-1\&quot; value=\&quot;数据\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=none;shadow=1;fontSize=14;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;118\&quot; y=\&quot;180\&quot; width=\&quot;110\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-3\&quot; value=\&quot;训练\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#ffe6cc;strokeColor=#d79b00;shadow=1;fontSize=14;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;113\&quot; y=\&quot;570\&quot; width=\&quot;120\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-6\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=13;strokeWidth=2;strokeColor=#808080;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;sLKGas7Howqt66q8ozR_-4\&quot; target=\&quot;zweJf7sKE0CawOek9Q0V-3\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;240\&quot; y=\&quot;275\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;410\&quot; y=\&quot;410\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-15\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#B3B3B3;strokeWidth=3;exitX=1;exitY=0.5;exitDx=0;exitDy=0;dashed=1;dashPattern=1 1;\&quot; parent=\&quot;1\&quot; source=\&quot;zweJf7sKE0CawOek9Q0V-3\&quot; target=\&quot;zweJf7sKE0CawOek9Q0V-11\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;250\&quot; y=\&quot;600\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-11\&quot; value=\&quot;复现\&quot; style=\&quot;swimlane;fontStyle=0;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;whiteSpace=wrap;html=1;fillColor=#f5f5f5;fontColor=#333333;strokeColor=#666666;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;590\&quot; y=\&quot;535\&quot; width=\&quot;140\&quot; height=\&quot;120\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-12\&quot; value=\&quot;数据集：收集处理\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;zweJf7sKE0CawOek9Q0V-11\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry y=\&quot;30\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-13\&quot; value=\&quot;三步走流程\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;zweJf7sKE0CawOek9Q0V-11\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry y=\&quot;60\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-14\&quot; value=\&quot;硬件资源开销\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;zweJf7sKE0CawOek9Q0V-11\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry y=\&quot;90\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-22\&quot; value=\&quot;改进&amp;lt;br&amp;gt;① 单词→字符&amp;lt;br&amp;gt;②解决了OOV问题\&quot; style=\&quot;text;html=1;align=left;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;190\&quot; y=\&quot;450\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;zweJf7sKE0CawOek9Q0V-42\&quot; value=\&quot;2023-6-22&amp;lt;br&amp;gt;wqw547243068@163.com\&quot; style=\&quot;text;html=1;align=left;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;120\&quot; y=\&quot;1210\&quot; width=\&quot;170\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-2\&quot; value=\&quot;效果\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#ffe6cc;strokeColor=none;shadow=1;fontSize=14;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;113\&quot; y=\&quot;910\&quot; width=\&quot;120\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-3\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=13;strokeWidth=2;strokeColor=#808080;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;sLKGas7Howqt66q8ozR_-6\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-2\&quot;&gt;\n          &lt;mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;283\&quot; y=\&quot;500\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;280\&quot; y=\&quot;790\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-5\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=13;strokeWidth=2;strokeColor=#808080;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;zweJf7sKE0CawOek9Q0V-1\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-4\&quot;&gt;\n          &lt;mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;173\&quot; y=\&quot;240\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;173\&quot; y=\&quot;490\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-4\&quot; value=\&quot;模型\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#f8cecc;strokeColor=#b85450;shadow=1;fontSize=14;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;113\&quot; y=\&quot;340\&quot; width=\&quot;120\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-7\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=13;strokeWidth=2;strokeColor=#808080;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;zweJf7sKE0CawOek9Q0V-3\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-6\&quot;&gt;\n          &lt;mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;173\&quot; y=\&quot;620\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;173\&quot; y=\&quot;780\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-6\&quot; value=\&quot;部署\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=none;shadow=1;fontSize=14;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;113\&quot; y=\&quot;740\&quot; width=\&quot;120\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-8\&quot; value=\&quot;问题\&quot; style=\&quot;swimlane;fontStyle=0;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;whiteSpace=wrap;html=1;fillColor=#f5f5f5;fontColor=#333333;strokeColor=#666666;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;540\&quot; y=\&quot;860\&quot; width=\&quot;230\&quot; height=\&quot;150\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-37\&quot; value=\&quot;LLM评测\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-8\&quot;&gt;\n          &lt;mxGeometry y=\&quot;30\&quot; width=\&quot;230\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-9\&quot; value=\&quot;知识准确性：幻觉，胡说八道\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-8\&quot;&gt;\n          &lt;mxGeometry y=\&quot;60\&quot; width=\&quot;230\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-10\&quot; value=\&quot;复杂推理能力\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-8\&quot;&gt;\n          &lt;mxGeometry y=\&quot;90\&quot; width=\&quot;230\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-11\&quot; value=\&quot;人类偏好对齐：RLHF不足\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-8\&quot;&gt;\n          &lt;mxGeometry y=\&quot;120\&quot; width=\&quot;230\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-12\&quot; value=\&quot;应用\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#ffe6cc;strokeColor=none;shadow=1;fontSize=14;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;113\&quot; y=\&quot;1110\&quot; width=\&quot;120\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-13\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;fontSize=13;strokeWidth=2;strokeColor=#808080;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;sLKGas7Howqt66q8ozR_-2\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-12\&quot;&gt;\n          &lt;mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;167\&quot; y=\&quot;630\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;90\&quot; y=\&quot;750\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-14\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#B3B3B3;strokeWidth=3;exitX=1;exitY=0.5;exitDx=0;exitDy=0;dashed=1;dashPattern=1 1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;sLKGas7Howqt66q8ozR_-2\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-8\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;243\&quot; y=\&quot;605\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;460\&quot; y=\&quot;960\&quot; as=\&quot;targetPoint\&quot; /&gt;\n            &lt;Array as=\&quot;points\&quot;&gt;\n              &lt;mxPoint x=\&quot;510\&quot; y=\&quot;935\&quot; /&gt;\n              &lt;mxPoint x=\&quot;510\&quot; y=\&quot;935\&quot; /&gt;\n            &lt;/Array&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-15\&quot; value=\&quot;工程落地\&quot; style=\&quot;swimlane;fontStyle=0;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;whiteSpace=wrap;html=1;fillColor=#f5f5f5;fontColor=#333333;strokeColor=#666666;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;360\&quot; y=\&quot;708\&quot; width=\&quot;140\&quot; height=\&quot;180\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-16\&quot; value=\&quot;小型化\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-15\&quot;&gt;\n          &lt;mxGeometry y=\&quot;30\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-17\&quot; value=\&quot;本地部署\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-15\&quot;&gt;\n          &lt;mxGeometry y=\&quot;60\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-18\&quot; value=\&quot;性能：时延、并发\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-15\&quot;&gt;\n          &lt;mxGeometry y=\&quot;90\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-20\&quot; value=\&quot;数据安全\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-15\&quot;&gt;\n          &lt;mxGeometry y=\&quot;120\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-38\&quot; value=\&quot;输入、输出限制\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-15\&quot;&gt;\n          &lt;mxGeometry y=\&quot;150\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-19\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#B3B3B3;strokeWidth=3;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=-0.021;entryY=0.9;entryDx=0;entryDy=0;entryPerimeter=0;dashed=1;dashPattern=1 1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;sLKGas7Howqt66q8ozR_-6\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-16\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;243\&quot; y=\&quot;605\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;370\&quot; y=\&quot;605\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-21\&quot; value=\&quot;生态系统\&quot; style=\&quot;swimlane;fontStyle=0;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;whiteSpace=wrap;html=1;fillColor=#f5f5f5;fontColor=#333333;strokeColor=#666666;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;380\&quot; y=\&quot;1060\&quot; width=\&quot;140\&quot; height=\&quot;150\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxRectangle x=\&quot;550\&quot; y=\&quot;1040\&quot; width=\&quot;90\&quot; height=\&quot;30\&quot; as=\&quot;alternateBounds\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-22\&quot; value=\&quot;联网\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-21\&quot;&gt;\n          &lt;mxGeometry y=\&quot;30\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-23\&quot; value=\&quot;插件市场\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-21\&quot;&gt;\n          &lt;mxGeometry y=\&quot;60\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-24\&quot; value=\&quot;垂类应用\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-21\&quot;&gt;\n          &lt;mxGeometry y=\&quot;90\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-25\&quot; value=\&quot;LLM框架：LangChain\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-21\&quot;&gt;\n          &lt;mxGeometry y=\&quot;120\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-26\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#B3B3B3;strokeWidth=3;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;dashed=1;dashPattern=1 1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;sLKGas7Howqt66q8ozR_-12\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-23\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;243\&quot; y=\&quot;775\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;367\&quot; y=\&quot;775\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-27\&quot; value=\&quot;数据集\&quot; style=\&quot;swimlane;fontStyle=0;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;whiteSpace=wrap;html=1;fillColor=#f5f5f5;fontColor=#333333;strokeColor=#666666;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;560\&quot; y=\&quot;145\&quot; width=\&quot;140\&quot; height=\&quot;120\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-28\&quot; value=\&quot;预训练数据集：中英文\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-27\&quot;&gt;\n          &lt;mxGeometry y=\&quot;30\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-29\&quot; value=\&quot;指令集\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-27\&quot;&gt;\n          &lt;mxGeometry y=\&quot;60\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-30\&quot; value=\&quot;prompt数据集\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-27\&quot;&gt;\n          &lt;mxGeometry y=\&quot;90\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-31\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#B3B3B3;strokeWidth=3;exitX=1;exitY=0.5;exitDx=0;exitDy=0;dashed=1;dashPattern=1 1;entryX=-0.014;entryY=0.933;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;zweJf7sKE0CawOek9Q0V-1\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-28\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;243\&quot; y=\&quot;605\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;370\&quot; y=\&quot;605\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-32\&quot; value=\&quot;模型优化\&quot; style=\&quot;swimlane;fontStyle=0;childLayout=stackLayout;horizontal=1;startSize=30;horizontalStack=0;resizeParent=1;resizeParentMax=0;resizeLast=0;collapsible=1;marginBottom=0;whiteSpace=wrap;html=1;fillColor=#f5f5f5;fontColor=#333333;strokeColor=#666666;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;400\&quot; y=\&quot;305\&quot; width=\&quot;140\&quot; height=\&quot;120\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-33\&quot; value=\&quot;基座大模型：中文\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-32\&quot;&gt;\n          &lt;mxGeometry y=\&quot;30\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-34\&quot; value=\&quot;奖励模型\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-32\&quot;&gt;\n          &lt;mxGeometry y=\&quot;60\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-35\&quot; value=\&quot;RL环节优化\&quot; style=\&quot;text;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;spacingLeft=4;spacingRight=4;overflow=hidden;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rotatable=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;sLKGas7Howqt66q8ozR_-32\&quot;&gt;\n          &lt;mxGeometry y=\&quot;90\&quot; width=\&quot;140\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;sLKGas7Howqt66q8ozR_-36\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#B3B3B3;strokeWidth=3;exitX=1;exitY=0.5;exitDx=0;exitDy=0;dashed=1;dashPattern=1 1;entryX=-0.007;entryY=0.067;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;sLKGas7Howqt66q8ozR_-4\&quot; target=\&quot;sLKGas7Howqt66q8ozR_-34\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;238\&quot; y=\&quot;215\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;408\&quot; y=\&quot;214\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n      &lt;/root&gt;\n    &lt;/mxGraphModel&gt;\n  &lt;/diagram&gt;\n&lt;/mxfile&gt;\n&quot;}"></div>
<script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>


## 操作系统

- 【2023-11-23】Andrej Karpathy **Intro to Large Language Models**, [video](https://www.youtube.com/watch?v=zjkBMFhNj_g), [pdf](https://drive.google.com/file/d/1pxx_ZI7O-Nwl7ZLNk5hI3WzAsTLwvNU7/view)

Karpathy将LLM描述为一种新型操作系统的内核进程。就像现代计算机具有 RAM 和文件访问权限一样，LLM 也有一个上下文窗口，可以加载从众多数据源检索到的信息。

<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2023-12-28T09:19:20.425Z\&quot; agent=\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36\&quot; etag=\&quot;s2CVcfRug7tphVoY00Zy\&quot; version=\&quot;22.1.15\&quot;&gt;\n  &lt;diagram name=\&quot;第 1 页\&quot; id=\&quot;YUrH7kkdw6S7EPocWAtV\&quot;&gt;\n    &lt;mxGraphModel dx=\&quot;1242\&quot; dy=\&quot;789\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;\n      &lt;root&gt;\n        &lt;mxCell id=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;JPcd8CNpdyUwO0oxOTY8-26\&quot; value=\&quot;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;dashed=1;dashPattern=1 1;fillColor=#f5f5f5;fontColor=#333333;strokeColor=#666666;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;308\&quot; y=\&quot;230\&quot; width=\&quot;226\&quot; height=\&quot;110\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;CRyWcW9bKPYmjVe2kgWn-2\&quot; value=\&quot;LLM as OS\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;fontStyle=0;fontSize=22;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;340\&quot; y=\&quot;90\&quot; width=\&quot;130\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;lHimWeaf7UQe36nZpLsc-30\&quot; value=\&quot;wqw547243068@163.com&amp;lt;br&amp;gt;2023-12-28\&quot; style=\&quot;text;html=1;align=left;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;470\&quot; y=\&quot;360\&quot; width=\&quot;170\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;JPcd8CNpdyUwO0oxOTY8-9\&quot; value=\&quot;Tools\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=none;shadow=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;170\&quot; y=\&quot;230\&quot; width=\&quot;100\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;JPcd8CNpdyUwO0oxOTY8-12\&quot; value=\&quot;File system&amp;lt;br&amp;gt;Vectorstore\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=none;shadow=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;170\&quot; y=\&quot;288\&quot; width=\&quot;100\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;JPcd8CNpdyUwO0oxOTY8-18\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;strokeWidth=2;strokeColor=#999999;exitX=1;exitY=0.5;exitDx=0;exitDy=0;dashed=1;dashPattern=1 1;startArrow=classic;startFill=1;\&quot; parent=\&quot;1\&quot; source=\&quot;JPcd8CNpdyUwO0oxOTY8-12\&quot; target=\&quot;UodbVUxlpqvjOuD6ag1p-1\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;270\&quot; y=\&quot;404.5\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;322.1800000000003\&quot; y=\&quot;370\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-1\&quot; value=\&quot;Context Window\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#fad7ac;strokeColor=#b46504;shadow=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;293\&quot; width=\&quot;106\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-2\&quot; value=\&quot;&amp;lt;span style=&amp;quot;color: rgb(51, 51, 51); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: center; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 251, 251); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; float: none; display: inline !important;&amp;quot;&amp;gt;LLM&amp;amp;nbsp;&amp;lt;/span&amp;gt;\&quot; style=\&quot;text;whiteSpace=wrap;html=1;fillColor=none;fontStyle=1\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;389\&quot; y=\&quot;253\&quot; width=\&quot;90\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-3\&quot; value=\&quot;Video&amp;lt;br&amp;gt;(I/O)\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=none;shadow=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;314\&quot; y=\&quot;160\&quot; width=\&quot;100\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-4\&quot; value=\&quot;Audio&amp;lt;br&amp;gt;(I/O)\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=none;shadow=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;427\&quot; y=\&quot;160\&quot; width=\&quot;100\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-5\&quot; value=\&quot;Search Tools&amp;lt;br&amp;gt;(Browser)\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=none;shadow=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;590\&quot; y=\&quot;230\&quot; width=\&quot;100\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-6\&quot; value=\&quot;Other LLMs\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=none;shadow=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;590\&quot; y=\&quot;290\&quot; width=\&quot;100\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-8\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=2;strokeColor=#999999;exitX=1;exitY=0.5;exitDx=0;exitDy=0;startArrow=classic;startFill=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;JPcd8CNpdyUwO0oxOTY8-9\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;280\&quot; y=\&quot;318\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;310\&quot; y=\&quot;250\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-9\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=2;strokeColor=#999999;exitX=0.5;exitY=1;exitDx=0;exitDy=0;startArrow=classic;startFill=1;entryX=0.25;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;UodbVUxlpqvjOuD6ag1p-3\&quot; target=\&quot;JPcd8CNpdyUwO0oxOTY8-26\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;280\&quot; y=\&quot;260\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;320\&quot; y=\&quot;260\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-10\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=2;strokeColor=#999999;exitX=0.5;exitY=1;exitDx=0;exitDy=0;startArrow=classic;startFill=1;entryX=0.75;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;UodbVUxlpqvjOuD6ag1p-4\&quot; target=\&quot;JPcd8CNpdyUwO0oxOTY8-26\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;290\&quot; y=\&quot;270\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;330\&quot; y=\&quot;270\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-11\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=2;strokeColor=#999999;exitX=0.991;exitY=0.182;exitDx=0;exitDy=0;startArrow=classic;startFill=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;exitPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;JPcd8CNpdyUwO0oxOTY8-26\&quot; target=\&quot;UodbVUxlpqvjOuD6ag1p-5\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;300\&quot; y=\&quot;280\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;340\&quot; y=\&quot;280\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-12\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=2;strokeColor=#999999;startArrow=classic;startFill=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; target=\&quot;UodbVUxlpqvjOuD6ag1p-6\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;530\&quot; y=\&quot;310\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;350\&quot; y=\&quot;290\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-13\&quot; value=\&quot;&amp;lt;span style=&amp;quot;color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: center; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 251, 251); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; float: none; display: inline !important;&amp;quot;&amp;gt;Calculator&amp;lt;br&amp;gt;Python interpreter&amp;lt;br&amp;gt;Terminal&amp;lt;br&amp;gt;&amp;lt;/span&amp;gt;\&quot; style=\&quot;text;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;170\&quot; y=\&quot;180\&quot; width=\&quot;120\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-14\&quot; value=\&quot;&amp;lt;span style=&amp;quot;font-family: Helvetica; font-size: 12px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: center; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; float: none; display: inline !important;&amp;quot;&amp;gt;Disk&amp;lt;br&amp;gt;&amp;lt;/span&amp;gt;\&quot; style=\&quot;text;whiteSpace=wrap;html=1;fontStyle=1;fillColor=none;fontColor=#3333FF;labelBackgroundColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;200\&quot; y=\&quot;328\&quot; width=\&quot;40\&quot; height=\&quot;32\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-15\&quot; value=\&quot;&amp;lt;span style=&amp;quot;font-family: Helvetica; font-size: 12px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: center; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; float: none; display: inline !important;&amp;quot;&amp;gt;CPU&amp;lt;br&amp;gt;&amp;lt;/span&amp;gt;\&quot; style=\&quot;text;whiteSpace=wrap;html=1;fontStyle=1;fillColor=none;fontColor=#3333FF;labelBackgroundColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;320\&quot; y=\&quot;230\&quot; width=\&quot;40\&quot; height=\&quot;32\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;UodbVUxlpqvjOuD6ag1p-16\&quot; value=\&quot;&amp;lt;span style=&amp;quot;font-family: Helvetica; font-size: 12px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: center; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; float: none; display: inline !important;&amp;quot;&amp;gt;RAM&amp;lt;br&amp;gt;&amp;lt;/span&amp;gt;\&quot; style=\&quot;text;whiteSpace=wrap;html=1;fontStyle=1;fillColor=none;fontColor=#3333FF;labelBackgroundColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;374\&quot; y=\&quot;323\&quot; width=\&quot;40\&quot; height=\&quot;32\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n      &lt;/root&gt;\n    &lt;/mxGraphModel&gt;\n  &lt;/diagram&gt;\n&lt;/mxfile&gt;\n&quot;}"></div>
<script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>


# 结束