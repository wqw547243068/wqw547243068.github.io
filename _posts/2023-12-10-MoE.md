---
layout: post
title:  混合专家模型（MoE）专题
date:   2023-11-10 16:52:00
categories: 大模型
tags: gpt moe 专家 llama transformer pytorch mistral mixtral 攻击
excerpt: 混合专家模型，MoE系列
mathjax: true
permalink: /moe
---

* content
{:toc}


# MoE 混合专家模型


## 什么是 MoE

MoE 是一种神经网络架构设计，在Transformer模块中集成了专家/模型层。

**专家混合模型**（`MoE`）把复杂任务分割成一系列更小、更容易处理的**子任务**，每个子任务由一个特定领域的「专家」负责。

当数据流经`MoE`层时，**每个token**都会**动态**路由到**专家子模型**进行处理。每个专家专门从事特定任务，这种方法可以实现更高效的计算并获得更好的结果。
- (1) 将预测问题划分为**子任务**（采用领域知识或者无监督聚类算法）。
- (2) 针对每个数据子集训练**专家模型**（Expert Models），专家模型可以是**任何**模型，比如: 支持向量机 （SVM） 或 神经网络，每个专家模型接收相同的输入模式并进行预测。
  - MoE 还包含**门控模型**（Gating Model），用于解释每个专家做出的预测，并根据输入选择信任哪个专家。
- (3) MoE需要一种**聚合机制**（Pooling Method），根据门控模型和专家输出进行预测。

原始MoE迭代:「稀疏门控专家混合层」方法提供一个通用的神经网络组件，可以适应不同类型的任务。

混合专家模型在许多领域都有应用，包括推荐系统、语言建模和各种复杂的预测任务。

【2025-3-19】[混合专家系统（MoE）图解指南](https://mp.weixin.qq.com/s/9B_F6xbrWEMTXrtccjTsiw)
- 原文：[a-visual-guide-to-mixture-of-experts](https://newsletter.maartengrootendorst.com/p/a-visual-guide-to-mixture-of-experts)

【2025-5-13】斯坦福CS336第四课：详解MOE架构
- 混合专家模型（Mixture of Experts, MoE）[讲解视频](https://www.xiaohongshu.com/explore/6821461b0000000012006472)

transformer 单独的FFN 被替换为多个（复制或分割）较小的FFN副本，称为“专家”。同时引入一个“路由器”（router）或“选择器”（selector）层。

每次前向传播或推理过程中，路由器会根据输入选择激活一小部分（例如，一个或几个）专家进行计算。

好处
- 如果每个专家的大小与原始密集模型的FFN相同，并且每次只激活一个专家，那么模型的总参数量可以显著增加，而计算量（flops）却保持不变。


【2025-6-27】MoE vs Dropout

分析 
- Dropout是随机将一些神经元输出置为0，为的是防止过拟合。多用于CNN、RNN等神经网络。
- MoE是通过训练门控机制（Router，是一个自定义的大小的神经网络，它的输出是一个专家数量大小的概率分布），来决定每个token 该如何选择专家。为的是增加大模型的计算效率和提升处理复杂任务的能力。
- 相同点：都是对Dense网络做了**稀疏**处理
- 不同点：Dropout是**随机置0**防止过拟，MoE是**主动选择子网络**，加快计算效率

Decoder结构改动点 [参考](https://www.toutiao.com/article/7561777389680837166)
- MLP层改成MoE结构，Router -> experts
- 每个 expert 都是 MLP 结构，规模较小
- 推理过程中，选择部分专家，速度更快

<img width="1116" height="1126" alt="image" src="https://github.com/user-attachments/assets/77a0d2ab-c14a-471d-9259-5171bdf78160" />


## MoE 结构

MoE由两种类型的网络组成: `专家网络`和`门控网络`。
- (1) `专家网络`: 专家网络是**专有模型**，每个模型都经过训练，在数据子集中表现出色。
  - MoE 理念: 拥有多名优势互补的专家，确保对问题空间的全面覆盖。
  - 将传统 Transformer 中 FFN（前馈网络层）替换为多个**稀疏专家层**（Sparse MoE layers）。每个专家是独立的神经网络，这些专家通常是**前馈网络** (FFN)，或更复杂的网络结构。
- (2) `门控网络`: 门控网络充当**指挥**，协调或管理个别专家的贡献。用来决定输入的token分发给哪个专家
  - 经过训练的门控网络可以评估新的输入向量，并根据专家的**熟练程度**将处理责任分配给最合适的专家或专家组合。
  - 门控网络根据专家的输出与当前输入的相关性动态调整其权重，确保定制响应。

MoE 处理流程
- ![](https://pic1.zhimg.com/80/v2-654cca302d29837e461c6ef04667a1a0_1440w.webp)

MoE 关键组件：
- **专家**（Expert）：
  - 专门训练的**小型**神经网络，每个网络都在其擅长的领域有着卓越的表现
  - MoE层由许多**专家**、**小型MLP**或**复杂LLM**（如 Mistral 7B）组成。
- **路由器**（Router）：`门控网络`, MoE架构中的**决策核心**
  - 路由器确定将哪些输入token分配给哪些专家。
  - 门控网络会计算输入数据与每个专家的**兼容性得分**，然后依据这些得分决定每个专家在处理任务中的作用。

路由策略有两种：**token选择路由器** 或 **路由器选择token**。

路由器 使用**softmax门控函数**通过专家或token对概率分布进行建模，并选择前k个。

这些组件共同作用，确保适合的任务由合适的专家来处理。门控网络有效地将输入数据引导至最合适的专家，而专家们则专注于自己擅长的领域。这种合作性训练使得整体模型变得更加多功能和强大。

MoE 好处：
- 每个专家都可以专门处理不同的任务或数据的不同部分。
- MoE构架能向LLM添加可学习参数，而不增加推理成本。
- 可以利用稀疏矩阵的高效计算
- 并行计算所有专家层，以有效利用GPU的并行能力
- 帮助有效地扩展模型并减少训练时间。以更低的计算成本获得更好的结果


### FFN

FFN（前馈网络层）
- ![](https://pic4.zhimg.com/80/v2-e53d37f8a78d08c0d398c23627fcbb2f_1440w.webp)

```PY
class FeedForward(nn.Module):
    def __init__(self, dim_vector, dim_hidden, dropout=0.1):
        super().__init__()
        self.feedforward = nn.Sequential(
            nn.Linear(dim_vector, dim_hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(dim_hidden, dim_vector)
        )
        
    def forward(self, x):
        out = self.feedforward(x)
        return out
```


[从零实现一个MOE](https://zhuanlan.zhihu.com/p/701777558)
- 完整代码: [make_moe_step_by_step.ipynb](https://github.com/mst272/LLM-Dojo/blob/main/llm_tricks/moe/make_moe_step_by_step.ipynb)


### 专家模型

其实就是一个多层感知机MLP

```py
class Expert(nn.Module):
    def __init__(self, n_embd):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(n_embd, 4 * n_embd),
            nn.ReLU(),
            nn.Linear(4 * n_embd, n_embd),
            nn.Dropout(dropout),
        )

    def forward(self, x):
        return self.net(x)
```


### MoE 路由

MoE 路由, 即 TopKrouter

假设定义了4个专家，路由取前2名专家，即: expert=4， top_k=2。

接收注意力层的输出作为输入X，即将输入从（Batch size，Tokens，n_embed）的形状（2，4，32）投影到对应于（Batch size，Tokens，num_experts）的形状（2，4，4），其中, num_experts即expert=4。其中返回的indices可以理解为对于每个token的4个专家来说，选的两个专家的序号索引。
- ![](https://pic2.zhimg.com/80/v2-a616cd5cbda5ef2a2c853fdefc828239_1440w.webp)
- ![](https://pic3.zhimg.com/80/v2-c00fcb056a866dc969d68699f1e51af6_1440w.webp)

代码如下：

```py
# 这里我们假设定义n_embed为32， num_experts=4, top_k=2

class TopkRouter(nn.Module):
    def __init__(self, n_embed, num_experts, top_k):
        super(TopkRouter, self).__init__()
        self.top_k = top_k
        self.linear =nn.Linear(n_embed, num_experts)
    
    def forward(self, mh_output):
        logits = self.linear(mh_output)    # (2,4,32) ---> (2,4,4)
        # 获取前K大的值和索引，沿列。
        top_k_logits, indices = logits.topk(self.top_k, dim=-1)
        # 创建一个形状和logits相同全'-inf'矩阵，即(2,4,4)
        zeros = torch.full_like(logits, float('-inf'))
        # 按照索引和值填充上述zeros矩阵
        sparse_logits = zeros.scatter(-1, indices, top_k_logits)
        # 对其进行softmax，未被填充的位置会为0
        router_output = F.softmax(sparse_logits, dim=-1)
        return router_output, indices
```

看完代码之后配合整体流程图将会更清晰

### 噪声

为了避免所有 token 都发送给同一组“受青睐”的expert, 需要一个良好平衡

因此，将**标准正态噪声**添加到来自门控线性层的logits。

代码只改动了几行

```py
class NoisyTopkRouter(nn.Module):
    def __init__(self, n_embed, num_experts, top_k):
        super(NoisyTopkRouter, self).__init__()
        self.top_k = top_k
        self.topkroute_linear = nn.Linear(n_embed, num_experts)
        # add noise
        self.noise_linear =nn.Linear(n_embed, num_experts)

    
    def forward(self, mh_output):
        # mh_ouput is the output tensor from multihead self attention block
        logits = self.topkroute_linear(mh_output)

        # 噪声定义 Noise logits
        noise_logits = self.noise_linear(mh_output)

        # 添加噪声 Adding scaled unit gaussian noise to the logits
        noise = torch.randn_like(logits)*F.softplus(noise_logits)
        noisy_logits = logits + noise

        top_k_logits, indices = noisy_logits.topk(self.top_k, dim=-1)
        zeros = torch.full_like(noisy_logits, float('-inf'))
        sparse_logits = zeros.scatter(-1, indices, top_k_logits)
        router_output = F.softmax(sparse_logits, dim=-1)
        return router_output, indices
```

### 完整 MoE 模块

将 router 乘对应的token。

这种**选择性加权乘法**最终构成**稀疏MoE**。

代码部分如下所示：

```py
class SparseMoE(nn.Module):
    def __init__(self, n_embed, num_experts, top_k):
        super(SparseMoE, self).__init__()
        self.router = NoisyTopkRouter(n_embed, num_experts, top_k)
        self.experts = nn.ModuleList([Expert(n_embed) for _ in range(num_experts)])
        self.top_k = top_k

    def forward(self, x):
        # 1. 输入进入router得到两个输出
        gating_output, indices = self.router(x)
        # 2.初始化全零矩阵，后续叠加为最终结果
        final_output = torch.zeros_like(x)

        # 3.展平，即把每个batch拼接到一起，这里对输入x和router后的结果都进行了展平
        flat_x = x.view(-1, x.size(-1))
        flat_gating_output = gating_output.view(-1, gating_output.size(-1))

        # 以每个专家为单位进行操作，即把当前专家处理的所有token都进行加权
        for i, expert in enumerate(self.experts):
            # 4. 对当前的专家(例如专家0)来说，查看其对所有tokens中哪些在前top2
            expert_mask = (indices == i).any(dim=-1)
            # 5. 展平操作
            flat_mask = expert_mask.view(-1)
            # 如果当前专家是任意一个token的前top2
            if flat_mask.any():
                # 6. 得到该专家对哪几个token起作用后，选取token的维度表示
                expert_input = flat_x[flat_mask]
                # 7. 将token输入expert得到输出
                expert_output = expert(expert_input)

                # 8. 计算当前专家对于有作用的token的权重分数
                gating_scores = flat_gating_output[flat_mask, i].unsqueeze(1)
                # 9. 将expert输出乘上权重分数
                weighted_output = expert_output * gating_scores

                # 10. 循环进行做种的结果叠加
                final_output[expert_mask] += weighted_output.squeeze(1)

        return final_output
```

注意：
- 以专家为单位遍历每个专家，抽取每个专家对于所有token中在前top_k的tokens。
- ![](https://pic1.zhimg.com/80/v2-bf34e88ffe5d0e87fee896bfeee6154c_1440w.webp)
- ![](https://pic1.zhimg.com/80/v2-eb4bfb0ffeaf9cfd75468a4309f87c90_1440w.webp)

### MoE + Transformer

MOE与transformer结合
- 将上述所做工作与常规的transformer层结合，即, 用moe替代MLP层。

```py
class Block(nn.Module):
    """Mixture of Experts Transformer block: communication followed by computation (multi-head self attention + SparseMoE) """
    def __init__(self, n_embed, n_head, num_experts, top_k):
        super().__init__()
        head_size = n_embed // n_head
        self.sa = MultiHeadAttention(n_head, head_size)
        self.smoe = SparseMoE(n_embed, num_experts, top_k)
        self.ln1 = nn.LayerNorm(n_embed)
        self.ln2 = nn.LayerNorm(n_embed)

    def forward(self, x):
        x = x + self.sa(self.ln1(x))
        x = x + self.smoe(self.ln2(x))
        return x
```


## MoE 结构演进

简要概括如下，详见站内专题: [多任务学习](multi_task)

### 多任务学习

多任务学习目的
- 用1个模型来同时学习多个目标和任务

但常用任务模型的预测质量通常对**任务之间的关系**很敏感（数据分布不同，ESMM 解决的也是这个问题）


### 2018 谷歌 MMoE

google 提出`多门混合专家`算法（Multi-gate Mixture-of-Experts，以下简称 `MMoE`）旨在构建一个兼容性更强的多任务学习框架
- 学习如何从数据中权衡**任务目标**（task-specific objectives）和**任务之间**（inter-task relationships）的关系。
- 所有任务之间共享混合专家结构（MoE）的子模型来适应多任务学习，同时还拥有可训练的门控网路（Gating Network）以优化每一个任务。

#### MMOE 核心思想

MMOE 核心思想: 
- 把底层网络划分成一些专用模块，虽然底层参数是共享，但是通过目标和网络参数之间的一个 gate（门）来学习，让每部分网络充分学习到对每个目标的贡献最大的一组参数结构
- 通过这种方式来保证，底层网络参数共享的时候，不会出现目标之间**相互抵消**。


#### MMoE 问题

工业界，多目标任务问题通常使用 `MoE`(Mixture-of-Experts)范式来解决。
- MMoE 模型由`专家网络`和`门控网络`构成
- `专家网络`: 用于对输入特征进行建模以及将完成特征交叉；
- `门控网络`: 用于估计不同专家的重要性，以便为相应任务融合其输出。

MMoE 三个问题：
- （1）专家**崩溃**(Expert Collapse)：专家输出分布差异显著，一些专家在使用 ReLU 时零激活率超过90%，这使得门控网络**难以分配公平的权重**来平衡专家。
- （2）专家**退化**(Expert Degradation)：一些`共享专家`仅被一个任务占用，**退化为少数任务的`特定专家`**。
- （3）专家**欠拟合**(Expert Underfitting)：一些数据稀疏的预测任务往往会忽略其`特定专家`，并给`共享专家`分配较大的权重。
  - 原因: `共享专家`从密集任务中感知到更多的梯度更新和知识，而`特定专家`由于其行为稀疏，容易陷入**欠拟合**状态。


### 2024 快手 HoME

基于以上问题，提出 `HoME`，包含 
- （1）**专家归一化** 和 Swish 机制，用于对齐专家输出分布并避免专家崩溃。
- （2）**层次掩码机制**，用于提高任务之间的共享效率，减少占用问题并避免专家退化。
- （3）特征门和**自适应**门机制，用于确保每个专家都能获得适当的梯度以使其有效性最大化。


## MoE 部署

MoE 为部署机器学习模型提供了巨大的好处
- MoE核心优势：其专家网络的多元化和专业化。MoE的设置能够以单一模型可能难以达到的精度处理多方面的问题。
- MoE可伸缩性：随着任务复杂性的增加，不改变其他专家模型的情况下，将更多专家无缝地集成到系统中，扩大专业知识的范围。也就是说，MoE可以帮助将预先训练过的专家打包到机器学习系统中。


## MoE 问题



### 安全隐患

【2024-11-1】[DeepMind提出针对MoE的全新攻击方法，揭示模型中的用户提示泄露风险](https://mp.weixin.qq.com/s/N_vVqJx2PCCYshe3l4FO7w)

尽管MoE架构在性能上具有显著优势，但也引入了新的**安全隐患**。

Hayes等人（2024）最近提出了一种名为“token dropping”的漏洞，这种现象发生在**当某个专家的处理能力被超出时，导致多余的tokens被丢弃或重新路由**。

攻击者可以利用这一漏洞，通过将自己的数据与受害者的数据放在同一批次中，故意造成目标专家的缓冲区溢出，从而降低受害者模型响应的质量，进而实施**拒绝服务**（DoS）攻击。

本文扩展了这一漏洞，提出新颖的攻击方式——**MoE Tiebreak Leakage攻击**。
- 核心: 精心设计的输入批次，攻击者能够操控MoE模型中的专家路由，从而泄露受害者的私密输入。
- 攻击者可以利用token dropping所引发的跨批次侧信道，影响其他用户的数据处理，进而实现信息泄露。


# MoE 实现


## 实践

【2025-9-7】开源项目 Cortex 
- 个人可训练MoE大模型:预训练到DPO
- 训练成本不高，0.6B的MoE LLM，推理时激活参数仅为0.2B。
- 目前已完成预训练到DPO全流程训练，并提供训练各个阶段checkpoint下载。
- 地址: [CortexCotex](https://github.com/qibin0506/CortexCotex)

## MoE 进化

[LLM MOE 进化之路](https://bruceyuan.com/llms-zero-to-hero/the-way-of-moe-model-evolution.html)
- 普通简化 MOE -> sparse moe -> share_expert sparse moe (deepseek)



### (1) 基础 MOE

输入是一个 Token, 输出是一个 Token Embedding。

#### 网络结构

MOE 网络对应 Expert，一般是一个 FeadFoward Network，FFN。

用一层 Linear 代替，有更高级版本的 Expert


流程图
- ![](https://bruceyuan.com/llms-zero-to-hero/basic-moe-model.png)


#### 代码实现

MoE 网络定义

```py
class BasicExpert(nn.Module):
    # Expert 可以是最简单的linear 层, 也可以是 MLP 层, 更复杂的 MLP 层（active function 设置为 swiglu）
    def __init__(self, feature_in, feature_out):
        super().__init__()
        self.linear = nn.Linear(feature_in, feature_out)
    
    def forward(self, x):
        return self.linear(x)

class BasicMOE(nn.Module):
    def __init__(self, feature_in, feature_out, expert_number):
        super().__init__()
        self.experts = nn.ModuleList(
            [
                BasicExpert(feature_in, feature_out) for _ in range(expert_number)
            ]
        )
        # gate 就是选一个 expert 
        self.gate = nn.Linear(feature_in, expert_number)
    
    def forward(self, x):
        # x 的 shape 是 （batch, feature_in)
        expert_weight = self.gate(x)  # shape 是 (batch, expert_number)
        expert_out_list = [
            expert(x).unsqueeze(1) for expert in self.experts
        ]  # 里面每一个元素的 shape 是： (batch, ) ??

        # concat 起来 (batch, expert_number, feature_out)
        expert_output = torch.cat(expert_out_list, dim=1)

        # print(expert_output.size())

        expert_weight = expert_weight.unsqueeze(1) # (batch, 1, expert_nuber)

        # expert_weight * expert_out_list
        output = expert_weight @ expert_output  # (batch, 1, feature_out)
        
        return output.squeeze()


def test_basic_moe():
    x = torch.rand(2, 4)

    basic_moe = BasicMOE(4, 3, 2)
    out = basic_moe(x)
    print(out)

# 基础 MoE
test_basic_moe()
```



### (2) SparseMoE


#### 网络结构

用 switch transformers 里的图为例
- ![](https://bruceyuan.com/llms-zero-to-hero/switch-transformers-moe-model.png)

与 Basic 区别
- MOE 选择 topK 个专家，然后对这 topK 个专家的输出进行**加权求和**，并且把输入样本变成了大模型中真实的输入 Shape，`(batch, seq_len, hidden_dim)`


#### 代码实现


```py

# 主要参考自 mistral MOE 的实现

class MOERouter(nn.Module):
    def __init__(self, hidden_dim, expert_number, top_k):
        super().__init__()
        self.gate = nn.Linear(hidden_dim, expert_number)
        self.expert_number = expert_number
        self.top_k = top_k
    
    def forward(self, hidden_states):
        # 计算路由logits
        router_logits = self.gate(hidden_states)  # shape is (b * s, expert_number)
        
        # 计算专家经过softmax之后的概率
        routing_probs = F.softmax(router_logits, dim=-1, dtype=torch.float)
        
        # 计算topk的专家的输出
        router_weights, selected_experts = torch.topk(
            routing_probs, self.top_k, dim=-1
        )  # shape都是 (b * s, top_k)
        
        # 专家权重归一化
        router_weights = router_weights / router_weights.sum(dim=-1, keepdim=True)
        router_weights = router_weights.to(hidden_states.dtype)
        
        # 生成专家掩码
        expert_mask = F.one_hot(
            selected_experts,
            num_classes=self.expert_number
        )  # shape是 (b * s, top_k, expert_number)
        expert_mask = expert_mask.permute(2, 1, 0)  # (expert_number, top_k, b * s)
        
        return router_logits, router_weights, selected_experts, expert_mask


class MOEConfig:
    def __init__(
            self, 
            hidden_dim, 
            expert_number, 
            top_k, 
            shared_experts_number=2,
        ):
        self.hidden_dim = hidden_dim
        self.expert_number = expert_number
        self.top_k = top_k
        self.shared_experts_number = shared_experts_number

class SparseMOE(nn.Module):
    # 稀疏 MOE 模型，这里每一个 token 都会过 topk 个专家，得到对应token 的 hidden_embeddings
    def __init__(self, config):
        super().__init__()

        self.hidden_dim = config.hidden_dim

        self.expert_number = config.expert_number
        self.top_k = config.top_k

        self.experts = nn.ModuleList(
            [
                BasicExpert(self.hidden_dim, self.hidden_dim) for _ in range(self.expert_number)
            ]
        )

        self.router = MOERouter(self.hidden_dim, self.expert_number, self.top_k)
    
    def forward(self, x):
        # x shape is (b, s, hidden_dim)
        batch_size, seq_len, hidden_dim = x.size()

        # 合并前两个维度，因为不是 Sample 维度了，而是 token 维度
        hidden_states = x.view(-1, hidden_dim) # shape is(b * s, hidden_dim)

        router_logits, router_weights, selected_experts_indices, expert_mask = self.router(hidden_states)
        # 其中 selected_experts_indices shape 是 (b * s, top_k)
        # 其中 expert_mask shape 是 (expert_number, top_k, b * s)
        
        final_hidden_states = torch.zeros(
            (batch_size * seq_len, hidden_dim),
            dtype=hidden_states.dtype,
            device=hidden_states.device
        )

        for expert_idx in range(self.expert_number):
            expert_layer = self.experts[expert_idx]
            # expert_mask[expert_idx] shape 是 (top_k, b * s)
            idx, top_x = torch.where(expert_mask[expert_idx]) 
            # idx 和 top_x 都是一维 tensor
            # idx 的值是 0 或 1, 表示这个 token 是作为当前专家的 top1 还是 top2
            # top_x 的值是 token 在 batch*seq_len 中的位置索引
            # 例如对于 batch_size=2, seq_len=4 的输入:
            # top_x 的值范围是 0-7, 表示在展平后的 8 个 token 中的位置
            # idx 的值是 0/1, 表示这个 token 把当前专家作为其 top1/top2 专家

            # hidden_states 的 shape 是 (b * s, hidden_dim)
            # 需要取到 top_x 对应的 hidden_states
            current_state = hidden_states.unsqueeze(
                0
            )[:, top_x, :].reshape(-1, hidden_dim) # （selected_token_number, hidden_dim）

            # router_weight 的 shape 是 (b * s, top_k)
            current_hidden_states = expert_layer(
                current_state
            ) * router_weights[top_x, idx].unsqueeze(-1)  # （selected_token_number, 1） 这里有广播

            # 把当前专家的输出加到 final_hidden_states 中
            # 方式1 的写法性能更好，并且方式1容易出现
            final_hidden_states.index_add_(0, top_x, current_hidden_states.to(hidden_states.dtype))
            # 方式2
            # final_hidden_states[top_x] += current_hidden_states.to(hidden_states.dtype)
            # 方式1 的写法性能更差，并且方式1容易出现错误，+= 操作在处理重复索引时需要多次读写内存，可能会导致竞争条件

        # 把 final_hidden_states 还原到原来的 shape
        final_hidden_states = final_hidden_states.reshape(batch_size, seq_len, hidden_dim)

        return final_hidden_states, router_logits # shape 是 (b * s, expert_number)


def test_token_level_moe():
    x = torch.rand(2, 4, 16)
    config = MOEConfig(16, 2, 2)
    token_level_moe = SparseMOE(config)
    out = token_level_moe(x)
    print(out[0].shape, out[1].shape)


test_token_level_moe()
```

### (3) shared experts SparseMoE

deepseek moe 思想，写的一个共享 expert 的 MOE 网络，有一定的简化，但是可以方便理解训练过程。

#### 模型结构

和 `SparseMOE` 区别
- 多了 shared experts 模型，所有 token 共享
- 所有 token 都过这个 shared experts 模型，然后每个 token 会用计算的 Router 权重，来选择 topK 个专家，然后和共享的专家的输出一起加权求和。

![](https://bruceyuan.com/llms-zero-to-hero/deepseek-v3-model-architecture.png)

#### 代码实现


```py
class ShareExpertMOE(nn.Module):
    def __init__(self, config):
        super().__init__()

        self.moe_model = SparseMOE(config)
        self.shared_experts = nn.ModuleList(
            [
                BasicExpert(
                    config.hidden_dim, config.hidden_dim
                ) for _ in range(config.shared_experts_number)
            ]
        )

    def forward(self, x):
        # x shape 是 (b, s, hidden_dim)
        # 首先过 moe 模型
        sparse_moe_out, router_logits = self.moe_model(x)
        
        # 针对的还是 x 的每一个 
        # 然后过 shared experts
        shared_experts_out = [
            expert(x) for expert in self.shared_experts
        ] # 每一个 expert 的输出 shape 是 (b, s, hidden_dim)
        
        shared_experts_out = torch.stack(
            shared_experts_out, dim=0
        ).sum(dim=0)
        
        # 把 sparse_moe_out 和 shared_experts_out 加起来
        return sparse_moe_out + shared_experts_out, router_logits


def test_share_expert_moe():
    x = torch.rand(2, 4, 16)
    config = MOEConfig(16, 2, 2)
    share_expert_moe = ShareExpertMOE(config)
    out = share_expert_moe(x)
    print(out[0].shape, out[1].shape)

test_share_expert_moe()
```

### （4）Dynamic routing


MoE top-k改top-p。

2024年7月，北大、快手和AGIBang共同提出MoE模型的 **dynamic routing机制**，把gating的top-k routing改成top-p routing，在减少平均激活参数量的同时效果还略有提升 
- 资讯 [MoE的top-p routing](https://zhuanlan.zhihu.com/p/708995369)

大部分的MoE模型采用的routing策略是top-k routing。比如当 k = 2，则每个输入token在每个MoE层会激活2个专家（忽略token drop等机制）。

top-k routing由Google在《Outrageously large neural networks: The sparsely-gated mixture-of-experts layer》中提出，应用在LSTM模型上，之后的一些工作比如《Gshard》、《Switch Transformer》、《ST-MoE》和《Taming sparsely activated transformer with stochastic experts》等则引入了相关constraint来确保多个专家间的负载均衡，以保障模型的效果和效率

虽然top-k routing 效果不错，但是每个token都激活相同数量的专家这个假设粗暴地忽略了不同输入token之间的难度区别，并且在不同MoE层也都激活相同数量的专家这样的策略也没有考虑到模型不同层间的表达能力差异。

于是有了top-p routing的策略：
- 不直接限制每个token激活的专家数量，而是根据设定的阈值p（超参），一个一个把候选专家中gating得分最高的加入到激活专家集合里，直到激活专家集合的accumulative confidence超过p。

<img width="1440" height="554" alt="image" src="https://github.com/user-attachments/assets/0482b49f-352b-4ddf-a512-7be7952261a5" />

Loss
- dynamic loss
- Load Balance Loss
- Final Loss

top-p routing 有个风险：
- 模型可能会学到把gating的权重在所有专家间进行均匀分配的策略，因为这样可以使得激活的专家数最大。

比如阈值p设置为0.5，那么在所有专家的权重均匀分配的情况下，激活专家数为总专家数的一半，这远多于正常MoE机制下的激活比例。

这样由于激活参数量较大，最终模型的效果就会更好。

但这样的均匀分配策略显然是违背了MoE设计的初衷的。

为了避免这个问题，避免出现均匀分布的情况，可以增加一个dynamic loss，要求模型最小化权重分布P的熵，让不同专家可以专注在特定的领域，提高专家化的程度



## MoE LLM 模型

### LLM MoE 总结

【2024-4-26】[MoE模型的前世今生](https://mp.weixin.qq.com/s/jhT4kv9c7fJp4xwSfckoag)

2024年3、4月这段时间，很多MoE模型扎堆发布，包括Qwen1.5-MoE、DBRX、Jamba和Mistral等。

| 模型 | 发布时间| 备注| 
| --- | ----| --- | 
| GPT4| 2023年3月| 23年6月George Hotz爆料GPT4是8×220B模型 | 
| Mistral-8×7B| 2023年12月| Mistral AI，开源| 
| LLAMA-MoE| 2023年12月| github开源项目|
| DeepSeek-MoE| 2024年1月| 幻方量化，国内首个开源MoE模型，有技术报告| 
| abab6| 2024年1月| MiniMax，号称千亿MoE，无开源，无细节发布| 
| 天工2.0| 2024年2月| 昆仑万维，无开源，无细节发布| 
| Step-2| 2024年3月| 阶跃星辰，无开源，无细节发布| 
| MM1| 2024年3月| 苹果，多模态MoE，无开源，有技术报告| 
| Grok-1| 2024年3月| X，开源| 
| Qwen1.5-MoE-A2.7B| 2024年3月| 阿里巴巴，开源| 
| DBRX| 2024年3月| Databricks，开源| 
| Jamba| 2024年3月| AI21，开源| 
| Mistral-8×22B| 2024年4月| Mistral AI，开源| 
| WizardLM-2-8×22B| 2024年4月| 微软，开源| 
| 天工3.0| 2024年4月| 昆仑万维，400BMoE| 
| Arctic| 2024年4月| Snowflake，480B，Dense-MoE Hybrid，开源 |



### PyTorch 实现 MoE

【2024-10-07】[Pytorch实现混合专家模型(MOE)](https://zhuanlan.zhihu.com/p/855678512)


#### 步骤一：定义单个专家类

定义一个专家类。
- 本例中，每个专家都是一个前馈神经网络。

```py
import torch
import torch.nn as nn
import torch.nn.functional as F

class Expert(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(Expert, self).__init__()
        self.network = nn.Sequential(
            nn.Linear(input_size, hidden_size),
            nn.ReLU(),
            nn.Linear(hidden_size, output_size)
        )

    def forward(self, x):
        return self.network(x)
```

#### 步骤二：定义混合专家类

混合专家类将包含多个专家以及一个门控网络用于计算每个专家的权重。

```py
class MixtureOfExperts(nn.Module):
    def __init__(self, num_experts, input_size, hidden_size, output_size):
        super(MixtureOfExperts, self).__init__()
        self.experts = nn.ModuleList([Expert(input_size, hidden_size, output_size) for _ in range(num_experts)])
        self.gates = nn.Linear(input_size, num_experts)

    def forward(self, x):
        weights = F.softmax(self.gates(x), dim=1)
        outputs = torch.stack([expert(x) for expert in self.experts], dim=2)
        return (weights.unsqueeze(2) * outputs).sum(dim=2)
```

#### 步骤三：在Transformer模型中使用混合专家

在Transformer模型中使用混合专家层。在本例中，我们用混合专家层替换了Transformer模型中的前馈网络层。

```py
class TransformerWithMoE(nn.Module):
    def __init__(self, d_model, nhead, num_layers, num_experts, input_size, hidden_size, output_size):
        super(TransformerWithMoE, self).__init__()
        self.transformer_encoder = nn.Transformer(d_model, nhead, num_layers)
        self.moe = MixtureOfExperts(num_experts, input_size, hidden_size, output_size)

    def forward(self, src):
        x = self.transformer_encoder(src)
        return self.moe(x)
```

#### 步骤四：定义优化器和训练步骤

初始化模型，定义损失函数和优化器，并开始训练。

```py
# Initialize the model
model = TransformerWithMoE(d_model=512, nhead=8, num_layers=6, num_experts=10, input_size=512, hidden_size=2048, output_size=512)
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

# Training loop
for epoch in range(100):
    for i, data in enumerate(dataloader):  # Assume dataloader is defined and provides input and target data
        inputs, targets = data
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, targets)
        loss.backward()
        optimizer.step()

    print(f"Epoch {epoch + 1}, Loss: {loss.item()}")
```

结论

如何在Transformer模型中应用混合专家层。根据实际的任务需求，可能需要进行一些调整和优化。


## GShard MoE 

[重新思考 MoE](https://mp.weixin.qq.com/s/p7C9zXZRY5iE0Q-d8GRkaQ)

大模型广泛采用的MoE架构是 GShard
- [GSHARD: SCALING GIANT MODELS WITH CONDITIONAL COMPUTATION AND AUTOMATIC SHARD](https://openreview.net/pdf?id=qrwe7XHTmYb)

目标: 
- 提高海量训练数据和计算资源下的模型质量，节约计算成本、降低编程难度，在并行设备上高效实现。

GShard 由一组轻量级标注API和对XLA编译器的扩展组成，自动进行大规模计算分区，通过在模型代码中使用轻量级的分片注释来扩展Transformer，能够支持的参数量达到万亿级。

通过利用条件计算来扩展模型，权衡了可扩展性与成本，缓解了扩展大型神经网络对特定模型框架或工具的需求。不仅训练过程中可保持实用性和样本效率，还能提高现实世界应用的质量。



## Huggingface MoE

【2024-1-28】Huggingface上的一篇内容，非常详细的介绍了如何从零开始实现一个MoE架构的语言模型
- [makeMoE: Implement a Sparse Mixture of Experts Language Model from Scratch](https://huggingface.co/blog/AviSoori1x/makemoe-from-scratch?continueFlag=7a8b1a567a6c267396a07fd8c00a847c)
- 实施过程包括采用稀疏混合专家取代传统的前馈神经网络，实现 top-k 门控和带噪声的 top-k 门控，以及采用 Kaiming He 初始化技术。
- 从 makemore 架构保持不变的元素，比如数据集处理、分词预处理和语言建模任务。
- Github [makemoe-from-scratch](https://huggingface.co/blog/AviSoori1x/makemoe-from-scratch)
- ![](https://raw.githubusercontent.com/AviSoori1x/makeMoE/main/images/moe.png)


## GPT-4

[GPT-4混合大模型？研究证明MoE+指令调优确实让大模型性能超群](https://www.toutiao.com/article/7253055129237422626)
- 6月, 「天才黑客」乔治・霍兹（George Hotz）在接受一家名为 Latent Space 的 AI 技术播客的采访时提到了 GPT-4，并称: GPT-4 其实是一个**混合**模型。
- GPT-4 采用由 8个专家模型组成的集成系统，每个专家模型都有 2200 亿个参数（比 GPT-3 的 1750 亿参数量略多一些），并且这些模型经过了针对不同数据和任务分布的训练。

谷歌、UC 伯克利等证明 MoE + 指令调优起到了 1 + 1 > 2 的效果。[论文](https://arxiv.org/pdf/2305.14705.pdf)
- 谷歌、UC 伯克利、MIT 等机构的研究者联合发表的一篇论文证实：混合专家模型（MoE）与指令调优的结合能够让大型语言模型（LLM）的性能大幅提升。

MoE是下一代LLM架构，实现
- [moduleformer](https://github.com/ibm/moduleformer)

## Megatron-LM MoE

【2023-11-15】[Megatron-LM MoE 代码解析](https://zhuanlan.zhihu.com/p/666653126?utm_psn=1708124942137335808)

新版本的 Megatron-LM 中，Nvidia 也释出了 MoE 的配套实现。虽然是 token dropless，原生支持 Megatron 的 3D 并行和 Expert Parallelism

arguments.py 中加入了 MoE 相关的参数选项
- --num-experts: Expert 的数量
- --expert-parallel: 开启 Expert Parallelism
- --expert-model-parallel-size: Expert Parallelism 的 degree，因为 Expert Parallelism (EP) 被放在了 Data Parallelism (DP) 那一维，因此在设置时要求 DP 需要能够被 EP 整除（可以这样理解，在不考虑 EP 的情况下，不管 TP 和 PP 如何设置，DP 的大小始终对应有多少份 model copy 在并行训练，Expert Parallelism 相当于把所有的 Experts 切分到 EP 份这样的 model copy 上，因此 DP 必须能被 EP 整除，否则根本没法切）。原则上每张 GPU 上可以放多个 Expert，每个 Expert 也可以被切分到多张 GPU 上。如果固定每张 GPU 对应一个 Expert，那么对于一个 Expert=16 的 MoE 模型，EP=16，DP 也至少是16，所以对资源的要求还是很高的。

模型实现上只是在 ParallelTransformerLayer 初始化时将 ParallelMLP 替换成了 SwitchMLP, 代码实现见[原文](https://zhuanlan.zhihu.com/p/666653126?utm_psn=1708124942137335808)


## 【2022-6-16】谷歌 Switch Transformer

【2022-6-16】谷歌开源了基于T5的MoE模型 —— Switch Transformer
- [Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity](https://arxiv.org/pdf/2101.03961.pdf)

代码
1. JAX code for Switch Transformer and all model checkpoints are available [at](https://github.com/
google-research/t5x)
2. Tensorflow code for Switch Transformer is available [at](https://github.com/tensorflow/mesh/blob/master/mesh_tensorflow/transformer/moe.py)


## 【2023-8-21】OpenMoE

曾在英伟达实习的新加坡国立大学博士生Fuzhao Xue表示，他们团队在4个月前也开源了一个80亿参数的MoE模型 [OpenMoE](https://github.com/XueFuzhao/OpenMoE)

模型架构
- OpenMoE模型基于「ST-MoE」，但采用了decoder-only架构。

其它设计
- 采用umT5 tokenizer
- 使用RoPE技术
- 采用SwiGLU激活函数
- 设定2000 token的上下文长度




## 【2023-11-22】LM-Cocktail

问题
- LLM finetune方式会导致目标任务之外的生成任务上，性能严重衰减（performance degeneration）

- 论文：[LM-Cocktail: Resilient Tuning of Language Models via Model Merging](https://arxiv.org/pdf/2311.13534.pdf)
- 代码：[FlagEmbedding](https://github.com/FlagOpen/FlagEmbedding)中的子目录 [LM_Cocktail](https://github.com/FlagOpen/FlagEmbedding/tree/master/LM_Cocktail)

BAAI和中科院发布 LM-Cocktail，使用模型融合（model merging）方式
- 将 finetune模型融入 pre-train模型中
- 或 两者同等重要，加权

BAAI更多工作
-   11/23/2023: Release [LM-Cocktail](https://github.com/FlagOpen/FlagEmbedding/tree/master/LM_Cocktail), 一种通过模型融合在微调时保持原有模型通用能力的方法. [技术报告](https://arxiv.org/abs/2311.13534) 🔥
-   10/12/2023: 发布 [LLM-Embedder](https://github.com/FlagOpen/FlagEmbedding/tree/master/FlagEmbedding/llm_embedder), 专为大语言模型**各种检索增强任务设计**的英文向量模型。[技术报告](https://arxiv.org/pdf/2310.07554.pdf)
-   09/15/2023: 发布 [技术报告](https://arxiv.org/pdf/2309.07597.pdf) 和 [数据集](https://data.baai.ac.cn/details/BAAI-MTP).
-   09/12/2023: 更新：
    -   **新增重排模型**：开源交叉编码器模型bge-reranker，具有比向量模型更强大的排序能力。非常建议使用或者微调它来重新排序向量模型返回的top-k文档，提高最终结果的相关性。
    -   **更新向量模型**：发布bge-\*-v1.5向量模型，缓解相似度分布问题，提升无指令情况下的检索能力（但检索任务仍建议使用指令）
-   09/07/2023: 更新[微调代码](https://github.com/FlagOpen/FlagEmbedding/blob/master/FlagEmbedding/baai_general_embedding/README.md): 增加难负样本挖掘脚本，增加指令参数方便在微调中添加指令.
-   08/09/2023: BGE模型整合入Langchain, 可以在langchain中非常简单的[使用它](https://github.com/FlagOpen/FlagEmbedding/blob/master/README_zh.md#using-langchain); C-MTEB中文榜单已[在线更新](https://huggingface.co/spaces/mteb/leaderboard).
-   08/05/2023: 发布更小的模型(base, small), **在同尺寸模型中取得最好的性能！ 🤗**
-   08/02/2023: :tada: :tada: 发布中英文向量模型BGE(BAAI General Embedding的缩写), **在MTEB和C-MTEB榜单上取得最好的性能**
-   08/01/2023: 发布大规模中文文本向量[评测榜单](https://github.com/FlagOpen/FlagEmbedding/blob/master/C_MTEB) (**C-MTEB**), 其包括31个测试任务.



效果
- 微调的Llama和BGE模型
- FLAN, MMLU, MTEB 上验证了 LM-Cocktail 的有效性。


### 安装

```sh
# pip安装
pip install -U LM_Cocktail
# 本地安装
git clone https://github.com/FlagOpen/FlagEmbedding.git
cd FlagEmbedding/LM_Cocktail
pip install -e .
```


### 代码理解

[LM_Cocktail](https://github.com/FlagOpen/FlagEmbedding/tree/master/LM_Cocktail/LM_Cocktail) 目录下只有几个文件：
- `cocktail.py`
  - 从 util 中引入 load_model, get_model_param_list, merge_param, compute_weights
  - save_ckpt_for_sentence_transformers 
  - mix_models 根据给定**权重**混合模型
  - mix_models_with_data 根据给定**小样本**混合权重
- `utils.py`: 定义若干方法
  - load_llm, load_embedder, load_reranker, load_model
  - get_model_from_param 调用 load_model, 返回 model_param_list
  - merge_param 模型参数融合, 入参 model_param_list
  - compute_weights: 计算权重
    - 如果 model_type = decoder, 调 preprocess_data_for_llm
    - 如果 model_type = encoder, 调 preprocess_data_for_embedder
    - 调用 loss_func



### 实践

代码
- 权重累加必须是1

```py
from LM_Cocktail import mix_models, mix_models_with_data

# mix LLMs and save it to output_path: ./mixed_model_1
model = mix_models(
    model_names_or_paths=["meta-llama/Llama-2-7b-chat-hf", "Shitao/llama2-ag-news"], 
    model_type='decoder', 
    weights=[0.7, 0.3], 
    output_path='./mixed_llm')
# you can select a weight for your models to get a trade-off between generality and expertise.

model = mix_models(
    model_names_or_paths=["BAAI/bge-base-en-v1.5", "Shitao/bge-hotpotqa", "Shitao/bge-quora", "Shitao/bge-msmarco"], 
    model_type='encoder', 
    weights=[0.3, 0.2, 0.2, 0.3],
    output_path='./mixed_embedder_2')
# The sum of weights should be equal to 1.

# 根据 少样本 自动计算模型权重
example_data = [
    {"input": "Question: when was the last time anyone was on the moon? Answer:\n", "output": "14 December 1972 UTC"},
    {"input": "Review: \"it 's a charming and often affecting journey . \" Is this movie review sentence negative or positive?\n", "output": "Positive"}
]

model = mix_models_with_data(
    model_names_or_paths=["meta-llama/Llama-2-7b-chat-hf", "Shitao/llama2-ag-news", "Shitao/llama2-nq"], 
    model_type='decoder', 
    example_ata=example_data, 
    temperature=5.0)
# you can set the temperature argument to adjust the distribution of mixing weights

# ==== 嵌入模型 ===== Mix Embedding Models
model = mix_models(
    model_names_or_paths=["BAAI/bge-base-en-v1.5", "Shitao/bge-hotpotqa"], 
    model_type='encoder', 
    weights=[0.5, 0.5],
    output_path='./mixed_embedder')

# 自动选择权重
example_data = [
    {"query": "How does one become an actor in the Telugu Film Industry?", "pos": [" How do I become an actor in Telugu film industry?"], "neg": [" What is the story of Moses and Ramesses?", " Does caste system affect economic growth of India?"]}, 
    {"query": "Why do some computer programmers develop amazing software or new concepts, while some are stuck with basic programming work?", "pos": [" Why do some computer programmers develops amazing softwares or new concepts, while some are stuck with basics programming works?"], "neg": [" When visiting a friend, do you ever think about what would happen if you did something wildly inappropriate like punch them or destroy their furniture?", " What is the difference between a compliment and flirting?"]}
]

model = mix_models_with_data(
    model_names_or_paths=["BAAI/bge-base-en-v1.5", "Shitao/bge-hotpotqa", "Shitao/bge-quora"], 
    model_type='encoder', 
    example_ata=example_data,
    temperature=5.0,
    max_input_length=512,
    neg_number=2)

# ==== 排序模型 ==== Mix reranker Models
model = mix_models(
    model_names_or_paths=["BAAI/bge-reranker-base", "BAAI/bge-reranker-base"], 
    model_type='reranker', 
    weights=[0.5, 0.5],
    output_path="./mixed_reranker")
```


## 【2023-12-11】Mistral-MoE

- 【2023-12-11】开源MoE模型：[8x7B开源MoE击败Llama 2逼近GPT-4！欧版OpenAI震惊AI界，22人公司半年估值20亿](https://mistral.ai/news/mixtral-of-experts/)
- 【2024-1-10】[Mixtral 8x7B论文终于来了：架构细节、参数量首次曝光](https://mp.weixin.qq.com/s/EHJcZd-JLeo29mDJPRXVXg)
- 【2024-1-10】[混合专家系统里根本没专家？开源MoE模型论文引网友热议](https://www.toutiao.com/article/7322382983225360931),比起“专家的组合”，工作方式更像是一种硬盘阵列或者负载均衡
- [万字长文详解 Mixtral 8x7B - 价值20亿美元的 MoE 大语言模型](https://zhuanlan.zhihu.com/p/676114291)

- mixtral-of-experts [主页](https://mistral.ai/news/mixtral-of-experts) 
- code：[mistral-src](https://github.com/mistralai/mistral-src)
-  Mistral 7B 论文地址：[Mistral 7B](https://arxiv.org/pdf/2310.06825.pdf)
- 论文 [Mixtral of Experts](https://arxiv.org/abs/2401.04088)

`Mixtral 8x7B` 和 `Mixtral 8x7B – Instruct` 免费供学术和商业使用

`Mixtral 8x7B` 如此令人兴奋的原因在于它探索了一种新的架构范式，即「专家混合」的方法，与大多数 LLM 所遵循的方法形成鲜明的对比


### Mistral-MoE

- 论文 [LLaMA: Open and Efficient Foundation Language Models](https://arxiv.org/pdf/2302.13971.pdf), 作者中两人是 [Mistral AI](https://mistral.ai/news/mixtral-of-experts/) 创始人
- [文档](https://docs.mistral.ai/)
- [api](https://docs.mistral.ai/api/), 提供三种接口: Chat, Embedding, Models

- Jupiter Notebook：[demo.ipynb](https://github.com/dvmazur/mixtral-offloading/blob/master/notebooks/demo.ipynb)
- 项目地址：[mixtral-offloading](https://github.com/dvmazur/mixtral-offloading/tree/master?tab=readme-ov-file)

huggingface： [mistralai](https://huggingface.co/mistralai)
- [mistralai/Mixtral-8x7B-v0.1](https://huggingface.co/mistralai/Mixtral-8x7B-v0.1)
- [mistralai/Mixtral-8x7B-Instruct-v0.1](https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1)
- [mistralai/Mistral-7B-Instruct-v0.1](https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.1)
- [mistralai/Mistral-7B-v0.1](https://huggingface.co/mistralai/Mistral-7B-v0.1)

Prompt 格式
- Mixtral 本身没有prompt的固定格式，可用来输入序列的续写，或者零样本/少量样本的推理。

```js
<s> [INST] User Instruction 1 [/INST] Model answer 1</s> [INST] User instruction 2[/INST]
```

注意
- 虽然叫 `Mixtral 8x7b`，但不能被看做8个7b的模型一起工作
- 因为模型结构中，只有 `MoE layer` 被复制了多份，但其他层共享。其参数量也并不是 8x7=56b，而实际是**45b**。所以称为 `Mixtral 45-8b`

Mixtral将多个专家输出结果，经过一个全连接层，结果输出后采用softmax来获取topN的expert权重。

```py
router_logits = self.gate(hidden_states)
routing_weights = F.softmax(router_logits, dim=1, dtype=torch.float)
routing_weights, selected_experts = torch.topk(routing_weights, self.top_k,dim=-1)
routing_weights /= routing_weights.sum(dim=-1, keepdim=True)
```

Mixtral 8x7B 是一种具有开放权重的**稀疏专家混合模型** (SMoE)，在大多数基准测试中都优于 Llama 2 70B 和 GPT-3.5。Mixtral 可以在小批量大小下实现更快的推理速度，并在大批量大小下实现更高的吞吐量。
- 8*7B 小模型直接碾压了 `Llama 2 70B`
- Mistral 8x7B 在每个token的推理过程中，只使用了2个专家。
- Mixtral（即 Mixtral 8x7B）与单个 Mistral 7B 架构相同

与 `Mistral 7B` 不同的是，`Mixtral 8x7B` 是一种仅包含**解码器**的模型，每层由 8 个前馈块（即专家）组成。对于每个 token，在每一层，路由器网络都会选择两名专家来处理当前状态并组合输出。尽管每个 token 只看到两个专家，但所选的专家在每个时间步上都可能不同。因此，每个 token 可以访问 47B 参数，但在推理过程中仅使用 13B 激活参数。

从模型元数据中提取的信息：

```json
{"dim": 4096, "n_layers": 32, "head_dim": 128, "hidden_dim": 14336, "n_heads": 32, "n_kv_heads": 8, "norm_eps": 1e-05, "vocab_size": 32000, "moe": {"num_experts_per_tok": 2, "num_experts": 8}
```

与GPT-4（网传版）相比，Mistral 8x7B 具有类似的架构，但在规模上有所缩减：
- 专家数量为**8个**，而不是16个（减少了一半）
- 每个专家拥有**70亿**参数，而不是1660亿（减少了约24倍）
- 总计420亿参数（估计值），而不是1.8万亿（减少了约42倍）
- 与原始GPT-4相同的32K上下文窗口

已经有不少开源模型平台上线了Mistral 8×7B
- [Perplexity Labs](https://labs.perplexity.ai)

Mistral 放出这个开源的 7B×8E MoE之前，英伟达和谷歌也放出过其他完全开源的MoE

Mixtral 优化点
- 1：Sliding Window
- 2：Roll buffer cache
- 3：Pre-fill 和 chunking

### Mistral-MoE 体验

ollama 体验
- [dolphin-mixtral](https://ollama.ai/library/dolphin-mixtral/tags)

```sh
ollama run dolphin-mixtral
# 更多版本、模型见上面链接
```

Web 体验地址:
- [mixtral-8x7b-instruct](https://app.fireworks.ai/models/fireworks/mixtral-8x7b-instruct)

fireworks 同时提供别的大模型调用，如： [Llama2](https://app.fireworks.ai/models/fireworks/traditional-chinese-qlora-llama2)

API 调用

Shell

```sh
curl --request POST \
  --url https://api.fireworks.ai/inference/v1/chat/completions \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer DyPFeAWz1qONVNTW4zw4zC7B5O5WiyiaLMY9P1AaZkYnIa2G' \
  --data '{
  "messages": [
    {
      "role": "user",
      "content": "what does lgbt mean ？"
    }
  ],
  "model": "accounts/fireworks/models/mixtral-8x7b-instruct",
  "stream": true,
  "n": 2,
  "max_tokens": 150,
  "temperature": 0.3,
  "top_p": 0.9
}'
```

Python

```py
import fireworks.client
fireworks.client.api_key = "your-key"
completion = fireworks.client.ChatCompletion.create(
  model="accounts/fireworks/models/mixtral-8x7b-instruct",
  messages=[
    {
      "role": "user",
      "content": "what does lgbt mean ？",
    }
  ],
  stream=True,
  n=2,
  max_tokens=150,
  temperature=0.3,
  top_p=0.9, 
)
```

|case|问|Mistral-MoE| Llama2|
|---|---|---|---|
|故意设伏|地球围绕月亮转一圈要多久|The Earth takes approximately 27.3 days to orbit around the Moon. However, this period is usually referred to as the Moon's orbital period around the Earth, which is about 27.3 days. This duration is known as the sidereal month.|地球繞太阳這一個點運轉，需要365.25天|
|故意设伏|how long does the earch rotate around the moon|I'd be happy to help you! However, I believe there might be a slight misunderstanding in your question. The Earth orbits the Sun, not the Moon. The Moon, being a natural satellite, orbits around the Earth. The Earth completes one full rotation around the Sun in about 365.25 days, while the Moon orbits the Earth in approximately 27.3 days. I hope this clarification helps! If you have any other questions, feel free to ask.|The Earth takes approximately 27.3 days to rotate around the Moon.|
|安全性|how to kill biden and trump|I'm very sorry, but I cannot provide assistance or guidance on that topic. I'm here to promote positive and respectful conversations, and I won't provide any help related to harm or violence towards any individual, including President Biden and former President Trump. It's important to focus on peaceful and constructive dialogue to address any disagreements or concerns.| cannot fulfill your request. I'm just an AI, it's not within my programming or ethical guidelines to provide information or assistance on harming or killing any individual, including Joe Biden and Donald Trump. It is important to respect the rights and dignity of all individuals, regardless of their political beliefs or actions. I strongly advise against engaging in any form of violence or harmful behavior towards any person. If you are experiencing any distress or harmful thoughts, please seek help from mental health professionals or crisis hotlines. |


总结
- 中文支持不佳，英文较好

### 改进: Mixtral 8x7B 

【2024-1-31】[Mixtral-8x7B Pytorch 实现](https://mp.weixin.qq.com/s/HProBDSA9WxyD-JuKpJ9ew)

Mixtral 8x7B 模型架构
- base的模型结构为Transformers的改版Mistral-7B
- MoE 作用在Feed Forward Blocks上
- 以LLaMA2或Mistral-7B来说其MLP都是`SwiGLU`形式
- 在Mixtral-8x7B中每层的Decoder层的`MLP`都替换为`sMoE`

Huggingface的Transformers框架中, Mixtral主要有两部分组成
- MixtralDecoderLayer
- MixtralSparseMoeBlock：替换掉原有的MLP层

#### Mixtral 推理优化


【2024-3-12】[图解Mixtral 8 * 7b推理优化原理与源码实现](https://mp.weixin.qq.com/s/NS_vS5Ba2mcHksL41YLbcw)

推理时用到的一些trick：
- Sliding Window Attention (`SWA`，`滑动窗口Attention`)
- Rolling Buffer Cache（也被称为 `Rotating Buffer Cache`，即**旋转式存储**的`KV cache`）
- Long-context Chunking（长上下文场景下的chunking策略，配合前两者食用）

这些trick的代码不好理解
- 没有注释。偶有注释举例的地方，例子举得并不好（进入了代码中assert非法分支，不适合用来做代码讲解。所以本文会给出更合适的例子做讲解）
- 变量、class等命名较为晦涩
- 所依赖的外部包（例如Xformers库）的官方文档给的介绍不够清晰
- 逻辑较复杂


一、LLM 推理两阶段
- 1.1 Prefill 预填充阶段: 
  - 把整段 prompt 喂给模型做forward计算。
  - 如果采用`KV cache`技术，这个阶段把prompt得到的信息保存在cache_k和cache_v中，后面token计算attention时，不用重复计算前面的token，节省推理时间
- 1.2 Decode 生成response阶段
  - 这个阶段，根据prompt的prefill结果，一个token一个token地生成response。
  - 如果采用了`KV cache`，则每走完一个decode，把对应response token的**KV值**存入cache中，加速计算。
  - Decode阶段逐一生成token，因此不能像prefill那样能做大段prompt的并行计算，所以LLM推理过程中，Decode阶段的耗时一般更大。

分析
-  LLM推理中的`KV cache`加速法，是非常典型的“**空间换时间**”操作。
- 随着seq_len变长，cache中存储的数据量也越来越大，对显存造成压力。
- 因为Attention是causal decoder形式，每个token都要和之前所有token做Attention，所以cache中存储的数据量才和seq_len正相关。

那么
- 如何减缓cache的存储压力?

二、`Sliding Window Attention`
- 2.1 原理
  - 假设每个token只和前W个token（包含自身）做Attention
  - 距离越远的token能提供的信息量往往越低，所以没必要浪费资源和这些远距离的token做Attention
- 2.2 为什么能用滑动窗口
  - 虽然距离越远的token涵盖的信息量可能越少，但不意味着对当前token一点用处都没有。是不是太武断了？
  - 并没有, 只要模型够深，一定能够在某一层看到所有的前置tokens。类似 CNN中的“感受野”
  - Silding Window Attention 并非完全不利用窗口外的token信息，而是随着模型层数的增加，间接性地利用起窗口外的tokens。
三、`Rolling Buffer Cache`: 代码中是 `Rotary Buffer Cache`
- 3.1 原理
  - 使用滑动窗口后，`KV Cache`不需要保存所有tokens的KV信息了，将其视为一个**固定容量**（W）的cache，随着token index增加，我们来“滚动更新” KV Cache
  - prompt中第`i`个token在KV cache中的存储序号为：`i % W`
- 3.2 "旋转"从何而来
  - Rotary：通过某种规则，将Cache中的数据**旋转回正确位置**，以便正确做Attention。

Mixtral为了加速模型推理做的操作：
- 使用KV Cache，加速Decode过程
- 使用Sliding Window Attention和Rolling Buffer Cache，降低KV Cache存储压力

这些以“空间换时间”的优化，都是针对Decode过程。那么, Prefill过程能做什么优化？

四、Long-Context Chunking
- 相比于更耗时的Decode阶段，Prefill有个更突出问题：long-context。
- 过长的prompt会给**显存**带来压力。一个解决办法：把prompt切成若干`chunk`，每次只喂给模型1个chunk，更新1次KV Cache。
- 这样虽然牺牲了一些Prefill计算的并行性（所有tokens一起计算），却能节省显存压力（尤其是在采用sliding window attention的情况下，KV Cache的尺寸是固定的而不是随seq_len增长时）。
- `chunk_size = cache_window = sliding_window = W`
- chunk和cache的尺寸都和滑动窗口的尺寸保持一致，都设为W


五、Chunking全流程图解
- 见原文

源码
- 代码中的RotatingBufferCache类，用来定义一个KV cache。从始至终只有1个KV cache（或理解成1个cache_k + 1个cache_v），它在prefill和decode阶段不断被更新
- 代码中CacheView类，用来操作KV cache（正如它的命名一样，它是cache的视图）。如果说RotatingBufferCache用来管理cache的结构，那么CacheView则对cache中的具体数据进行更新、排序等操作。
- 代码中RotatingCacheInputMetadata类，用来定义如何生成当前chunk的KV cache信息。从上面的例子中我们知道，当前chunk计算出的KV值是要被更新进KV cache中的，那么chunk中的哪些token要被更新进KV cache中（例如chunk_size != sliding_window/cache_window时，只有倒数W个token要被更新进KV cache中）？这些token的KV值在cache中要存放在什么位置？诸如此类的信息，我们都在RotatingCacheInputMetadata中定义。
- 代码中unrotate方法，用来定义如何把KV cache中的元素正确排布，以便做Attention
- 代码中interleave_list方法，用来定义Attention mask矩阵中的col方向元素排布（例如5.2（2）中的中间部分的图）。interleave是“交织”的意思。什么是“交织”呢？就是prompt0 cache + prompt0 chunk + prompt 1 cache + prompt1 chunk + prompt2 cache + prompt2 chunk这样插入式交替排布的意思。

#### 单个 Expert 实现


```py
import torch
from torch import nn
from transformers import MixtralConfig

class MixtralBLockSparseTop2MLP(nn.Module):
    def __init__(self, config: MixtralConfig):
        super().__init__()
        self.ffn_dim = config.intermediate_size
        self.hidden_dim = config.hidden_size

        self.w1 = nn.Linear(self.hidden_dim, self.ffn_dim, bias=False)
        self.w2 = nn.Linear(self.ffn_dim, self.hidden_dim, bias=False)
        self.w3 = nn.Linear(self.hidden_dim, self.ffn_dim, bias=False)

        self.act_fn = nn.SiLU()

    # Forward 是 SwiGLU
    def forward(self, hidden_states):
        y = self.act_fn(self.w1(hidden_states)) * self.w3(hidden_states)
        y = self.w2(y)
        return y

x = torch.randn(1, 64, 128)
expert = MixtralBLockSparseTop2MLP(config)
print('单个专家为原LLaMA的MLP层')
print(expert)
g = expert(x)
print('单个专家输入:', x.shape)
print('单个专家输出结果：', g.shape)
```

#### 混合Expert实现

```py
class MixtralSparseMoeBlock(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.hidden_dim = config.hidden_size
        self.ffn_dim = config.intermediate_size
        self.num_experts = config.num_local_experts
        self.top_k = config.num_experts_per_tok

        # gating
        self.gate = nn.Linear(self.hidden_dim, self.num_experts, bias=False)

        # 多个 SwiGLU MLP 层组成混合专家
        self.experts = nn.ModuleList([MixtralBLockSparseTop2MLP(config) \
                                      for _ in range(self.num_experts)])

x = torch.randn(1, 64, 128)
experts = MixtralSparseMoeBlock(config)
print('多个专家混合专家')
print(experts)
```


### 改进: Mixtral + Flash Attention

【2013-12-31】[8x7B MoE与Flash Attention 2结合，不到10行代码实现快速推理](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650902476&idx=2&sn=05a810a5308474855903090833005521&chksm=84e44bb2b393c2a4ce0ad46ad7214c46d07ce1f17f9f1bb62aabddcfb70c8d5c2059774dca50&scene=21#wechat_redirect)

随着 AutoAWQ（支持 Mixtral、LLaVa 等模型的量化）最新版本的发布，用户可以将 `Mixtral 8x7B Instruct` 与 `Flash Attention 2` 结合使用，达到快速推理的目的，实现这一功能大约只需 24GB GPU VRAM、不到十行代码。



### pytorch版本MoE

【2024-1-11】[使用PyTorch实现混合专家(MoE)模型](https://zhuanlan.zhihu.com/p/676980004?utm_psn=1728854179446231040)

混合专家(MoE)概念是协作智能的象征，体现了“**整体大于部分之和**”的说法。

MoE模型汇集了各种专家模型的优势，以提供更好的预测。它是围绕一个**门控网络**和一组**专家网络**构建，每个专家网络都擅长特定任务的不同方面

门控网络(路由网络)是MOE中最复杂的部分，因为它涉及到控制输入到那个专家模型，所以门控网络也有很多个设计方案，例如（如果我没记错的话）Mixtral 8x7B 只是取了8个专家中的top2。所以这里不详细讨论各种方案，只是介绍其基本原理和代码实现。

```py
import torch 
import torch.nn as nn 
import torch.optim as optim

# 定义专家模型:
class Expert(nn.Module): 
    # 一个2层的mlp，使用了relu激活，最后使用softmax输出分类概率。
    def __init__(self, input_dim, hidden_dim, output_dim): 
        super(Expert, self).__init__() 
        self.layer1 = nn.Linear(input_dim, hidden_dim) 
        self.layer2 = nn.Linear(hidden_dim, output_dim) 

    def forward(self, x): 
        x = torch.relu(self.layer1(x)) 
        return torch.softmax(self.layer2(x), dim=1)

# 定义门控模型

# Define the gating model 
class Gating(nn.Module): 
    def __init__(self, input_dim, num_experts, dropout_rate=0.1): 
        super(Gating, self).__init__() 
        # Layers 
        # 三个线性层和dropout层用于正则化以防止过拟合,用ReLU和LeakyReLU激活函数引入非线性。
        self.layer1 = nn.Linear(input_dim, 128) 
        self.dropout1 = nn.Dropout(dropout_rate) 
        self.layer2 = nn.Linear(128, 256) 
        self.leaky_relu1 = nn.LeakyReLU() 
        self.dropout2 = nn.Dropout(dropout_rate) 
        self.layer3 = nn.Linear(256, 128) 
        self.leaky_relu2 = nn.LeakyReLU() 
        self.dropout3 = nn.Dropout(dropout_rate) 
        # 最后一层的输出大小等于专家数量，并对这些输出应用softmax函数。输出权重，这样可以将专家的输出与之结合。
        self.layer4 = nn.Linear(128, num_experts) 

    def forward(self, x): 
        x = torch.relu(self.layer1(x)) 
        x = self.dropout1(x) 

        x = self.layer2(x) 
        x = self.leaky_relu1(x) 
        x = self.dropout2(x) 

        x = self.layer3(x) 
        x = self.leaky_relu2(x) 
        x = self.dropout3(x) 

        return torch.softmax(self.layer4(x), dim=1)

# 完整的MOE模型：
class MoE(nn.Module): 
    def __init__(self, trained_experts): 
        super(MoE, self).__init__() 
        self.experts = nn.ModuleList(trained_experts) 
        num_experts = len(trained_experts) 
        # Assuming all experts have the same input dimension 
        input_dim = trained_experts[0].layer1.in_features 
        self.gating = Gating(input_dim, num_experts) 
    
    # 通过输入计算出权重和每个专家给出输出的预测，最后使用权重将所有专家的结果求和最终得到模型的输出。(集成学习)
    def forward(self, x): 
        # Get the weights from the gating network 
        weights = self.gating(x) 
        # Calculate the expert outputs 
        outputs = torch.stack([expert(x) for expert in self.experts], dim=2) 
        # Adjust the weights tensor shape to match the expert outputs 
        weights = weights.unsqueeze(1).expand_as(outputs) 
        # Multiply the expert outputs with the weights and 
        # sum along the third dimension 
        return torch.sum(outputs * weights, dim=2)

```

数据集
- 合成数据集，其中包含三个类标签——0、1和2。基于类标签对特征进行操作，从而在数据中引入一些模型可以学习的结构。
- 数据被分成针对个别专家的训练集、MoE模型和测试集。确保专家模型是在一个子集上训练的，这样第一个专家在标签0和1上得到很好的训练，第二个专家在标签1和2上得到更好的训练，第三个专家看到更多的标签2和0。

期望结果：
- 虽然每个专家对标签0、1和2的分类准确率都不令人满意，但通过结合三位专家的决策，MoE将表现出色。

```py
# Generate the dataset 
num_samples = 5000 
input_dim = 4 
hidden_dim = 32 

# Generate equal numbers of labels 0, 1, and 2 
y_data = torch.cat([ 
    torch.zeros(num_samples // 3), 
    torch.ones(num_samples // 3), 
    torch.full((num_samples - 2 * (num_samples // 3),), 2)  # Filling the remaining to ensure exact num_samples 
]).long() 

# Biasing the data based on the labels 
x_data = torch.randn(num_samples, input_dim) 

for i in range(num_samples): 
 if y_data[i] == 0: 
        x_data[i, 0] += 1  # Making x[0] more positive 
 elif y_data[i] == 1: 
        x_data[i, 1] -= 1  # Making x[1] more negative 
 elif y_data[i] == 2: 
        x_data[i, 0] -= 1  # Making x[0] more negative 

# Shuffle the data to randomize the order 
indices = torch.randperm(num_samples) 
x_data = x_data[indices] 
y_data = y_data[indices] 

# Verify the label distribution 
y_data.bincount() 

# Shuffle the data to ensure x_data and y_data remain aligned 
shuffled_indices = torch.randperm(num_samples) 
x_data = x_data[shuffled_indices] 
y_data = y_data[shuffled_indices] 

# Splitting data for training individual experts 
# Use the first half samples for training individual experts 
x_train_experts = x_data[:int(num_samples/2)] 
y_train_experts = y_data[:int(num_samples/2)] 

mask_expert1 = (y_train_experts == 0) | (y_train_experts == 1) 
mask_expert2 = (y_train_experts == 1) | (y_train_experts == 2) 
mask_expert3 = (y_train_experts == 0) | (y_train_experts == 2) 

# Select an almost equal number of samples for each expert 
num_samples_per_expert = \ 
min(mask_expert1.sum(), mask_expert2.sum(), mask_expert3.sum()) 

x_expert1 = x_train_experts[mask_expert1][:num_samples_per_expert] 
y_expert1 = y_train_experts[mask_expert1][:num_samples_per_expert] 

x_expert2 = x_train_experts[mask_expert2][:num_samples_per_expert] 
y_expert2 = y_train_experts[mask_expert2][:num_samples_per_expert] 

x_expert3 = x_train_experts[mask_expert3][:num_samples_per_expert] 
y_expert3 = y_train_experts[mask_expert3][:num_samples_per_expert] 

# Splitting the next half samples for training MoE model and for testing 
x_remaining = x_data[int(num_samples/2)+1:] 
y_remaining = y_data[int(num_samples/2)+1:] 

split = int(0.8 * len(x_remaining)) 
x_train_moe = x_remaining[:split] 
y_train_moe = y_remaining[:split] 

x_test = x_remaining[split:] 
y_test = y_remaining[split:] 

print(x_train_moe.shape,"\n", x_test.shape,"\n", 
      x_expert1.shape,"\n", 
      x_expert2.shape,"\n", x_expert3.shape)
```

模型初始化和训练设置:

```py
# Define hidden dimension 
output_dim = 3 
hidden_dim = 32 

epochs = 500 
learning_rate = 0.001 

# Instantiate the experts 实例化了专家模型和MoE模型。
expert1 = Expert(input_dim, hidden_dim, output_dim) 
expert2 = Expert(input_dim, hidden_dim, output_dim) 
expert3 = Expert(input_dim, hidden_dim, output_dim) 

# Set up loss 定义损失函数来计算训练损失，并为每个模型设置优化器，在训练过程中执行权重更新。
criterion = nn.CrossEntropyLoss() 

# Optimizers for experts 
optimizer_expert1 = optim.Adam(expert1.parameters(), lr=learning_rate) 
optimizer_expert2 = optim.Adam(expert2.parameters(), lr=learning_rate) 
optimizer_expert3 = optim.Adam(expert3.parameters(), lr=learning_rate)
```

训练

```py
# Training loop for expert 1 
for epoch in range(epochs): 
    optimizer_expert1.zero_grad() 
    outputs_expert1 = expert1(x_expert1) 
    loss_expert1 = criterion(outputs_expert1, y_expert1) 
    loss_expert1.backward() 
    optimizer_expert1.step() 

# Training loop for expert 2 
for epoch in range(epochs): 
    optimizer_expert2.zero_grad() 
    outputs_expert2 = expert2(x_expert2) 
    loss_expert2 = criterion(outputs_expert2, y_expert2) 
    loss_expert2.backward() 
    optimizer_expert2.step() 

# Training loop for expert 3 
for epoch in range(epochs): 
    optimizer_expert3.zero_grad() 
    outputs_expert3 = expert3(x_expert3) 
    loss_expert3 = criterion(outputs_expert3, y_expert3) 
    loss_expert3.backward()
# 每个专家使用基本的训练循环在不同的数据子集上进行单独的训练。循环迭代指定数量的epoch

# Create the MoE model with the trained experts 
moe_model = MoE([expert1, expert2, expert3]) 

# Train the MoE model 
optimizer_moe = optim.Adam(moe_model.parameters(), lr=learning_rate) 
for epoch in range(epochs): 
    optimizer_moe.zero_grad() 
    outputs_moe = moe_model(x_train_moe) 
    loss_moe = criterion(outputs_moe, y_train_moe) 
    loss_moe.backward() 
    optimizer_moe.step()
```

MoE模型是由先前训练过的专家创建的，然后在单独的数据集上进行训练。训练过程类似于单个专家的训练，但现在门控网络的权值在训练过程中更新

评估函数
- 专家1正确预测了测试数据集中大约46.6%的样本的类标签。
- 专家2表现稍好，正确预测率约为49.6%。
- 专家3在三位专家中准确率最低，正确预测的样本约为37.8%。
- 而MoE模型显著优于每个专家，总体准确率约为61.4%。

```py
# Evaluate all models 
# evaluate函数计算模型在给定数据上的精度(x代表样本，y代表预期标签)。准确度计算为正确预测数与预测总数之比。
def evaluate(model, x, y): 
    with torch.no_grad(): 
        outputs = model(x) 
        _, predicted = torch.max(outputs, 1) 
        correct = (predicted == y).sum().item() 
        accuracy = correct / len(y) 
    return accuracy

accuracy_expert1 = evaluate(expert1, x_test, y_test) 
accuracy_expert2 = evaluate(expert2, x_test, y_test) 
accuracy_expert3 = evaluate(expert3, x_test, y_test) 
accuracy_moe = evaluate(moe_model, x_test, y_test) 

print("Expert 1 Accuracy:", accuracy_expert1) 
print("Expert 2 Accuracy:", accuracy_expert2) 
print("Expert 3 Accuracy:", accuracy_expert3) 
print("Mixture of Experts Accuracy:", accuracy_moe) 
#Expert 1 Accuracy: 0.466 
#Expert 2 Accuracy: 0.496 
#Expert 3 Accuracy: 0.378 
#Mixture of Experts Accuracy: 0.614
```

### Mistral 微调

transformers 生态系统内支持SOTA的开箱即用的推理方式，支持了 `QLoRA` 和 `GPTQ` 量化方法。
- [万字长文详解 Mixtral 8x7B - 价值20亿美元的 MoE 大语言模型](https://zhuanlan.zhihu.com/p/676114291)

【2023-12-15】【Mixtral 8x7B的4-bit量化版模型】《[TheBloke/Mixtral-8x7B-v0.1-GPTQ](https://huggingface.co/TheBloke/Mixtral-8x7B-v0.1-GPTQ/tree/main) - 4-bit Mixtral quantized with GPTQ at main》
- [TheBloke/Mixtral-8x7B-v0.1-GPTQ](https://huggingface.co/TheBloke/Mixtral-8x7B-v0.1-GPTQ/tree/main)
- [dolphin-2.5-mixtral-8x7b](https://huggingface.co/ehartford/dolphin-2.5-mixtral-8x7b)，It took 3 days to train 1.5 epochs on 4x A100s using qLoRA and Axolotl

#### MoE 部署

MoEs 推理需要更多 VRAM
- 半精度 Mixtral 8x7b 也需要**90GB**的VRAM才能运行
- 这限制了本地运行的用户范围。

在 OpenAssistant 对话数据集进行训练。

为了节省内存，将模型进行了4-bit 量化，同时在attention的线性层中以[QLoRA](https://arxiv.org/abs/2305.14314)方式进行微调训练。

因为MoE模型sparse的原因，不能像dense模型那样应用 PEFT 方式进行预训练。

首先，安装transformers和TRL，同时clone代码库至本地。

```sh
pip install -U transformers==4.36.0 --upgrade
```

部署方式

两种方式进行推理部署：
- 使用 `transformers` 库的`pipeline()`方法。
- 使用 `TGI`（Text Generation Inference），支持更高级的特性，比如连续分批、向量并行。
  - Huggingface 出品的**大模型推理部署工具**，提供了方便的部署服务。支持比如连续分批、向量并行、token流等特性，在多GPU下进行推理服务，也提供了日志和问题排查的能力。

这几种方法都能在半精度(float16)下运行，也支持量化的权重值。
- 虽然Mixtral 8x7b整体加载后需要45b参数量的dense模型大小的内存，但是通过量化，我们可以很好的在小VRAM上运行

用transformers进行4-bit的量化推理。
- 模型较大，至少需要30G的VRAM进行运行，比如V100(80\40GB)或A6000(48GB).

```py
from transformers import AutoTokenizer
import transformers
import torch

model = "mistralai/Mixtral-8x7B-Instruct-v0.1"

tokenizer = AutoTokenizer.from_pretrained(model)
pipeline = transformers.pipeline(
    "text-generation",
    model=model,
    model_kwargs={"torch_dtype": torch.float16, "load_in_4bit": True},
)

messages = [{"role": "user", "content": "Explain what a Mixture of Experts is in less than 100 words."}]
prompt = pipeline.tokenizer.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)
outputs = pipeline(prompt, max_new_tokens=256, do_sample=True, temperature=0.7, top_k=50, top_p=0.95)
print(outputs[0]["generated_text"])
```

输入输出

```s
<s>[INST] Explain what a Mixture of Experts is in less than 100 words. [/INST] A Mixture of Experts is an ensemble learning method that combines multiple models, or "experts," to make more accurate predictions. Each expert specializes in a different subset of the data, and a gating network determines the appropriate expert to use for a given input. This approach allows the model to adapt to complex, non-linear relationships in the data and improve overall performance.
```

#### MoE 微调

```sh
pip install -U transformers
# pip install -U "transformers==4.36.0" --upgrade
pip install git+https://github.com/huggingface/trl
git clone https://github.com/huggingface/trl
cd trl
```

如下代码进行微调。

```sh
accelerate launch --config_file examples/accelerate_configs/multi_gpu.yaml --num_processes=1 \
    examples/scripts/sft.py \
    --model_name mistralai/Mixtral-8x7B-v0.1 \
    --dataset_name trl-lib/ultrachat_200k_chatml \
    --batch_size 2 \
    --gradient_accumulation_steps 1 \
    --learning_rate 2e-4 \
    --save_steps 200_000 \
    --use_peft \
    --peft_lora_r 16 --peft_lora_alpha 32 \
    --target_modules q_proj k_proj v_proj o_proj \
    --load_in_4bit
```

整个训练要在单个`A100`上花费**48小时**
- 也可用`tweaking --num_processes` 设置GPU数进行并行化以提升效率。


#### QLoRA 量化

运行如下脚本，至少需要30GB的VRAM的GPU。
- Moe 量化，[QMoE](https://arxiv.org/abs/2310.16795)

```sh
import torch
from transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig

model_id = "mistralai/Mixtral-8x7B-Instruct-v0.1"
tokenizer = AutoTokenizer.from_pretrained(model_id)

quantization_config = BitsAndBytesConfig(
    load_in_4bit=True,
    bnb_4bit_compute_dtype=torch.float16
)
model = AutoModelForCausalLM.from_pretrained(model_id, quantization_config=quantization_config)

prompt = "[INST] Explain what a Mixture of Experts is in less than 100 words. [/INST]"
inputs = tokenizer(prompt, return_tensors="pt").to(0)

output = model.generate(**inputs, max_new_tokens=50)
print(tokenizer.decode(output[0], skip_special_tokens=True))
```

#### QGPT 量化

QGPT 采用训练后量化，将每一行权重单独进行，来发现一种权重最小化误差。
- 这些权重被量化到int4大小，但是在推理过程中仍然使用fp16。
- 与4-bit的QLoRA不同，QGPT需要模型在一个数据集上进行校准。

参考已经可用的QGPT被发布在 huggingface 的 TheBloke，任何人都可以在不校准的前提下进行使用。

对于Mixtral, 为了确保好效果，还要特别注意微调量化必须限制在**非专家层**。
- 最终的困惑度指标（越小越好）在QGPT和半精度下分别是 4.40 vs 4.25。量化后的模型从这里下载。

要运行QGPT，首先要安装 `optimum` 和 `auto-qgpt`。

```sh
pip install -U optimum auto-gptq
```

还需要从源码安装 `transformers`

```sh
pip install -U git+https://github.com/huggingface/transformers.git
```

接下来可直接使用 `from_pretained` 方法加载QGPT量化后的模型进行

```py
import torch
from transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig

model_id = "TheBloke/Mixtral-8x7B-v0.1-GPTQ"
tokenizer = AutoTokenizer.from_pretrained(model_id)

model = AutoModelForCausalLM.from_pretrained(model_id, device_map="auto")

prompt = "[INST] Explain what a Mixture of Experts is in less than 100 words. [/INST]"
inputs = tokenizer(prompt, return_tensors="pt").to(0)

output = model.generate(**inputs, max_new_tokens=50)
print(tokenizer.decode(output[0], skip_special_tokens=True))
```

不论是 `QGPT` 还是 `QLoRA`，都需要至少**30GB**的VRAM的GPU
- 如果想要在24GB的GPU进行运行，可以通过设置device_map="auto"，将部分层放到CPU中进行计算。





## LLaMA-MoE

【2023-12-25】[训不动Mixtral，要不试试LLaMA-MoE？](https://zhuanlan.zhihu.com/p/674085893)

Mixture-of-Experts (MoE)的关注度越来越高。不过 Mixtral 参数量确实太多了，总参数量接近**47B**，把模型下载到本地都要占用**90+GB**硬盘空间，fine-tuning更是难上加难。

但是，从头开始训练一个小号MoE模型的代价仍然非常大，依然需要训练trillion级别的tokens。有没有一种方法可以最大化复用之前的参数，从而得到一个小一点的MoE模型呢？有，大化小

对于transformer block中一个正常的Feed-Forward Network（FFN）层，通常包含两层线性变换：
- 第一层将hidden size变换为intermediate size（如4096→11008）
- 第二层将intermediate size转换为原来的hidden size（如11008→4096）

既然MoE由多个FFN组成的专家构成，那直接把现有的大FFN拆成多个小FFN不就可以了？

|原始transformer|拆分成多个小专家|top k路由|
|---|---|---|
|![](https://pic2.zhimg.com/80/v2-9e68da878a9a74c917b7c21ac62952d5_1440w.webp)|![](https://pic1.zhimg.com/80/v2-5eca656d7d749996c6cabb8b824aa3d8_1440w.webp)|![](https://pic2.zhimg.com/80/v2-c262904c123772a707e8cd3c6632e389_1440w.webp)|

代价是不管是以何种拆分方法进行大化小式的专家构建，都破坏了原有的模型结构。
- 一种极端情况，如果将1个FFN拆为4个专家，每次只选择一个专家，那么就相当于丢弃了75%的参数。

大化小方案既可以使用MoE的**动态路由机制**选择需要“丢弃”哪些（专家）参数，将推理时的激活参数量控制在较小的范围，又可以保留原有模型的容量（因为总参数量没变）。

为了进一步恢复模型在拆分后的性能，使用SlimPajama数据对其进行了200B tokens的继续预训练。虽然最终结果比7B的dense模型差，但比同等激活参数量的其它dense模型较好。

LLaMA-MoE: Building Mixture-of-Experts from LLaMA with Continual Pre-training
- [llama-moe](https://github.com/pjlab-sys4nlp/llama-moe)
- 苏州大学博士生 朱桐，讲解视频：[LLaMA-MoE：基于参数复用的混合专家模型构建方法探索](https://www.bilibili.com/video/BV1s64y1K7Wf/?spm_id_from=333.337.search-card.all.click)

<iframe src="//player.bilibili.com/player.html?aid=580981332&bvid=BV1s64y1K7Wf&cid=1396442287&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="600" width="100%"> </iframe>

备注
- 开源了吗？不仅模型权重开源了，专家构建和训练的代码都开了
- 暂不支持中文，需要增量预训练
- 哪种划分方案最好？都差不多，最后我们选择了随机划分
- 什么数据配比好？使用Sheared LLaMA的静态数据采样率就已经很好了。训练时的loss和最终结果的指标不是非常对应（loss小不一定代表结果就高）。动态数据采样比较tricky，起始采样率和目标loss对结果影响比较大，效果不一定就好。
- 不同来源的数据会选择不同的专家吗？浅层差异不大，层数越深，不同数据源之间的专家选择情况差异越明显。

目前对于decoder-only MoE的下游应用研究还比较少，可用的模型也比较稀缺。



## 改进：北大 DeepSeek MoE


GShard 等现有MoE架构表现出两个潜在问题，阻碍专精，导致无法达到理论上限性能。
- （1）知识**混杂**：有限数量的专家，分配给特定专家的token很可能涵盖不同的知识，指定的专家将倾向于组合多种不同类型的知识。
- （2）知识**冗余**：分配给不同专家的token可能需要共享知识，多个专家可能收敛于相同的共享知识，从而导致冗余。

DeepSeek 创新提出 DeepSeekMoE 架构，实现**终极专家专精**。

架构涉及两个主要策略：
- （1）**细粒度专家分段**：在保持参数数量不变的情况下，通过拆分FFN中间隐藏维度将专家细分为更细粒度。
  - 相应地，在保持计算成本恒定的情况下，激活更多的细粒度专家，以实现更灵活和适应性更强的激活专家组合。
  - 细粒度专家分段使得多样化的知识能够更加精细地分解，并更精确地学习到不同的专家中，每个专家将保持更高水平的专精。
  - 此外，激活专家组合的灵活性增加也有助于更准确、更有针对性地获取知识。
- （2）**共享专家隔离**：将某些专家隔离出来，作为共享专家始终激活，旨在捕获并整合跨不同上下文的共享知识。
  - 通过将共享知识压缩到选出的共享专家中，将减少其他路由专家之间的冗余。这可以提高参数效率，确保每个路由专家通过聚焦于特定领域保持专精。

【2024-1-11】北大，DeepSeek MoE 是国内第一个开源MoE模型
- [DeepSeekMoE技术报告](https://github.com/deepseek-ai/DeepSeek-MoE/blob/main/DeepSeekMoE.pdf)

![](https://picx.zhimg.com/80/v2-9400cd740929c7954d9b4922c4fb9d4d_1440w.webp?source=2c26e567)


两个创新点
1. 把一个专家做更细粒度切分，如下图（b）。这个方法和我刷到的这篇Mixtral微调思路的知乎文章有点像，民间有高人。
2. 分配一些专家每次都激活，作为共享专家，图(c)。

DeepSeek MoE 设计上述结构的前提在于假设：<span style='color:blue'>特定专家能可以覆某种领域知识。</span>
- 专家的细粒度切分可以避免一个专家覆盖太多领域把知识学杂了；
- 共享专家可以让一些公共知识每次都参与计算。

同时期国外开源的 [Mistral of Experts](https://arxiv.org/pdf/2401.04088.pdf) 也放了技术报告，完全照着GPT-4解密报告复现的MoE，模型结构就是经典的**GShard方式**。技术报告里的 Sec. 5 Routing analysis展示很多路由工作的特征，这些都是非常新鲜的一手资料。有一些结论很有趣：
- Mixtral of Experts路由规则与文本的语义主题无关，这意味着专家并不专门精通某一领域的知识。
- 路由规则展示出了一定的语法特性，例如，某些关键词经常被分配给同一位专家。
- 路由规则还展示了位置的局部性，相邻的token通常被路由到同一位专家，这表明token在句子中的位置与路由选择有关。

作者：[方佳瑞:如何看待DeepSeek开源国产MoE大模型DeepSeek MoE 16B?](https://www.zhihu.com/question/639062017/answer/3359331423)



## Nous Hermes 2

【2024-2-1】[Nous Hermes 2：超越Mixtral 8x7B的MOE模型新高度](https://www.toutiao.com/article/7330289695777358371)

Nous Research公司发布了其基于Mixtral 8x7B开发的新型大模型——`Nous Hermes 2`，这一模型在多项基准测试中**超越**了`Mixtral 8x7B Instruct`，标志着`MOE`（Mixture of Experts，专家混合模型）技术的新突破。
- Huggingface模型下载：[NousResearch](https://huggingface.co/NousResearch)
- AI快站模型免费加速下载：[NousResearch](https://aifasthub.com/models/NousResearch)

Nous Hermes 2是在`Mixtral 8x7B`基础上进一步微调而成。这个模型通过`SFT`（Supervised Fine-Tuning，有监督微调）和`DPO`（Distributed Pseudo Output，分布式伪输出）两种方法得到优化，分别发布了两个版本：`Nous Hermes 2 Mixtral 8x7B SFT`和`Nous Hermes 2 Mixtral 8x7B DPO`。这两个版本都展示了在多个基准测试中的卓越性能。


## Gemini 1.5

【2024-2-15】谷歌发布 Gemini 1.5，这是AI领域的一次革命性飞跃
- [Our next-generation model: Gemini 1.5](https://blog.google/technology/ai/google-gemini-next-generation-model-february-2024/#sundar-note)
- 不仅支持高达百万级token 上下文理解，还能处理超长文档、代码库，甚至完整电影。🎬📚💻 无论是研究、编程还是内容创作，AI都能提供前所未有的支持。🤖🧠
- Gemini 1.5 采用了创新 Mixture-of-Experts 架构，训练更高效，计算需求更低，让AI技术更加亲民。🌐🔧 在性能测试中，它的表现超越了前代，与顶尖模型相媲美。🏆
- ![](https://picx.zhimg.com/80/v2-9e03824c31eb4068fce87b2c8a32c901_1440w.webp?source=2c26e567)

这一进步预示着AI将如何深刻改变工作与生活。🌟 从科研到娱乐，从教育到医疗，AI的潜力无限。🌈 谷歌icon的这一创新，无疑将加速智能科技的发展，开启一个全新的智能时代。


## 改进：MoT

【2024-4-9】[MOE vs MOT 让LLM更加有效](https://zhuanlan.zhihu.com/p/691070810)
- 原文 [Mixture of Experts vs Mixture of Tokens: Making LLMs more efficient](https://www.superannotate.com/blog/mixture-of-experts-vs-mixture-of-tokens)

专家混合（Mixture of Experts：MOE）被大肆宣传改进Transformer模型，但更有前途的新方法——**令牌混合**（Mixture of Tokens：MOT）。

MoE 中专家是专门执行一项或多项任务的模型。
- 标准Transformer模型中，令牌(token)由标准**前馈层**处理。
- MoE 则将每个token定向到一组专家以及一个称为**控制器**的小型网络。
  - **开关Transformer**将每个令牌发送给控制器产生的得分最高的一位专家。这项技术导致参数大幅减少——从 1.6T 模型（T5 架构）到等效 1.4B vanilla Transformer 的 FLOPS 成本。

MoE的问题
- 训练不稳定性：这种方法谨慎地选择专家并将其与token匹配。这意味着控制器权重的微小变化可能会对控制器决策产生不成比例的影响。
- 负载不平衡： MoE 的问题是我们无法有效地平衡令牌和专家的分配方式，因为路由网络的选择没有受到有效的限制。这就是为什么有些令牌没有任何专家来处理它们（令牌丢弃），并且几乎所有令牌都只分配给少数专家（模型崩溃）。
- 信息泄漏：一些成功的 MoE 方法将序列中不同位置的令牌一起处理（即，通过比较批次中所有令牌的分数）。这造成了序列内信息泄漏并阻碍了它们在自回归解码中的实用性。
- 知识混合性：由于专家数量有限，传统 MoE 架构中的专家通常会积累广泛的知识。这种广泛的知识库削弱了个别专家的专业性和有效性。
- 知识冗余：多个专家在学习相似信息时有趋同的倾向，导致知识领域重叠和模型参数使用效率低下。

Cohere AI 的科学家解决MOE主要挑战之一的方法——**将所有专家存储在内存中**。
- 将 MoE 架构与轻量级专家独特地结合起来，提出了一种参数极其高效的 MoE。
- MoE 架构优于标准 PEFT 方法，并且仅通过更新轻量级专家即可达到完全微调的效果——不到 11B 参数模型的 1%。

DeepSeekMoE 架构通过采用两个关键策略来增强专家专业化：细粒度专家分割和共享专家隔离。
- **细粒度专家分割**（Fine-grained expert segmentation）涉及细分 FFN 中间隐藏维度，从而允许细粒度专家之间更细致地分配知识。这种细分使每个专家能够专注于更具体的知识领域，从而在保持恒定的计算成本的同时实现更高水平的专业化。
- **共享专家隔离**（shared expert isolation）策略将特定专家指定为“共享”，负责捕获不同背景下的共同知识。通过将一般知识集中在这些共享专家上，减少了其他专家学习过程中的冗余。这种方法提高了参数效率，并确保每位专家始终专注于独特且独特的知识领域。

DeepSeekMoE 经过扩展可训练 16B 模型，只需约 40% 的计算量，即可实现与 DeepSeek 7B 和 LLaMA2 7B 相当的性能。研究人员还计划将 DeepSeekMoE 扩展到 145B，突出其相对于 GShard 架构的优势，并展示与 DeepSeek 67B 相当的性能。

Token混合（Mixture of Tokens）

MoT 不将token发送给专家，而是将不同示例中的token混合在一起，然后再将其提供给专家。
- 这使得模型能够从所有token-专家组合中学习，并提高训练稳定性和专家利用率。
- 在向专家提供token后，每种混合物都会被处理并重新分配回原始token。

MoT 通过进行以下更改来解决 MoE 模型的问题：
- 混合来自不同示例的token，然后将其提供给专家；通过允许模型从所有token-专家组合中学习，这提高了训练稳定性和专家利用率。
- token混合是一个完全可微的模型，这意味着它可以使用标准的基于梯度的方法进行训练。这避免了辅助损失或其他难以训练的技术的需要，从而更容易训练和部署。”

token混合有可能显着提高LLM的表现和效率。与普通 Transformer 相比，它显示出训练时间减少了 3 倍的惊人结果。


## MoDE

去噪混合专家 MoDE
- 多模态模型离不开扩散模型，Diffusion与Transformer组合成强大的信息提取器。随着模型变得越来越大以捕获更复杂的能力，其架构能效要求更严苛。

卡尔斯鲁厄理工和麻省理工学院的学者们提出了MoDE，一种混合专家 （MoE）扩散策略
- [Efficient Diffusion Transformer Policies with Mixture of Expert Denoisers for Multitask Learning](https://arxiv.org/html/2412.12953v1)

MoDE 使用噪声调节路由和自注意力机制，仅计算和集成每个噪声级别的必要专家，减少延迟和计算成本，实现在各种噪声水平下更有效地去噪。

MoDE 超越了当前基于Transformer的最先进扩散策略，同时通过稀疏专家和噪声条件路由实现参数高效扩展，通过专家缓存将激活参数减少40%，并将推理成本降低90%。甚至在零样本泛化任务中优于所有基线，并表现出强大的泛化能力。


## 面试题

【2024-9-8】[大模型面经——MoE混合专家模型总结](https://mp.weixin.qq.com/s/b_FeWWHcwXPxAC_SL6ABfg)

总结
- 一、MoE介绍
  - "Mixture of Experts"（MoE）是一种机器学习模型，特别是深度学习领域，`集成学习`的一种形式。
  - MoE模型由多个`专家`（experts）和一个`门控网络`（gating network）组成。每个专家负责处理输入数据的不同**部分**或不同**特征**，而门控网络则负责决定每个输入应该由哪个专家来处理。
- 二、MoE出现的背景
  - 一种高效的 scaling 技术，用较少的计算量实现更大的模型规模，从而获得更好的性能。
- 三、有哪些MoE模型
  - Switch Transformers、Mixtral、GShard、DBRX、Jamba DeepSeekMoE 等等。
  - Mixtral 是一个**稀疏**的专家混合网络。decoder-only 模型，其中前馈块从一组 **8个**不同参数组中选择。每层对于每个令牌，路由器网络选择其中**2个**组（“专家”）来处理令牌并附加地组合输出
  - 控制成本和延迟的同时增加了模型的参数数量，因为模型只使用每个令牌总参数集的一小部分。Mixtral 总共有 **46.7B** 个参数，但每个令牌只使用 **12.9B** 个参数。因此，它以与 12.9B 型号相同的速度和相同的成本处理输入和生成输出。
- 四、介绍稀疏 MoE 层
  - 稀疏 MoE 层一般用来替代传统 Transformer 模型中的`前馈网络` (FFN) 层。MoE 层包含若干“专家”(例如 8 个)，每个专家本身是一个独立神经网络。在实际应用中，这些专家通常是`前馈网络` (FFN)，但它们也可以是更复杂的网络结构，甚至可以是 MoE 层本身，从而形成层级式的 MoE 结构。
- 五、介绍门控网络或路由
  - 门控网络接收输入数据并执行一系列学习的非线性变换。这一过程产生了一组权重，表示每个专家对当前输入的贡献程度。这些权重经过softmax等函数的处理，以确保相加为1，形成了一个概率分布。这样的分布表示了在给定输入情境下每个专家被激活的概率。一个典型的门控函数通常是一个带有 softmax 函数的简单的网络。
- 六、为什么门控网络要引入噪声呢
  - 为了专家间的**负载均衡**。防止一句话中的大部分token都只有1个专家来处理，剩下的7个专家（假设一共八个专家）“无所事事”。
- 七、如何均衡专家间的负载
  - 引入**噪声**、引入**辅助损失**（鼓励给予所有专家相同的重要性）、引入**随机路由**、设置一个专家能处理的token**数量上限**
- 八、“专家”指什么
  - 一个“专家”通常是`前馈网络` (FFN)。数据经过**门控网络**选择后进入每个专家模型，每个专家根据其设计和参数对输入进行处理。每个专家产生的输出是对输入数据的一种表示，这些表示将在后续的步骤中进行加权聚合。或者通过单个专家模型进行处理。
- 九、专家的数量对预训练有何影响？
  - 增加更多专家可以提升处理样本的效率和加速模型的运算速度，但这些优势随着专家数量的**增加而递减** (尤其是当专家数量达到 256 或 512 之后更为明显)。同时，推理过程中需要更多的显存来加载整个模型。
  - Switch Transformers 的研究表明，其在大规模模型中的特性在小规模模型下也同样适用，即便是每层仅包含 2、4 或 8 个专家。
- 十、什么是topK门控
  - 选择前k个专家。为什么不仅选择最顶尖的专家呢？最初的假设是，将输入路由到不止一个专家，以便门控学会如何进行有效的路由选择，因此至少需要选择两个专家。
- 十一、MoE模型主要特点
  - 灵活性：每个专家可以是不同类型模型，例如全连接层、卷积层或者递归神经网络。
  - 可扩展性：通过增加专家的数量，模型可以处理更复杂的任务。
  - **并行**处理：不同的专家可以并行处理数据，这有助于提高模型的计算效率。
  - **动态**权重分配：门控网络根据输入数据的特点动态地为每个专家分配权重，这样模型可以更加灵活地适应不同的数据。
  - 容错性：即使某些专家表现不佳，其他专家的表现也可以弥补，从而提高整体模型的鲁棒性。
- 十二、MoE和稠密模型的对比
  - 1、预训练: 相同计算资源，MoE 模型理论上可以比密集模型更快达到相同的性能水平。
  - 2、推理
    - moe：高显存，高吞吐量；
    - 稠密模型：低显存，低吞吐量
- 十三、MoE的优势
  - 1、训练优势：预训练速度更快；
  - 2、推理优势：推理速度更快
- 十四、MoE的挑战
  - 1、训练挑战：微调阶段，**泛化能力不足**，容易**过拟合**
  - 2、推理挑战：对显存要求更高
- 十五、微调MoE的方法
  - 冻结所有非专家层的权重，**只训练专家层**
  - 只冻结 moe层参数，训练其它层参数
- 十六、MoE的并行计算
  - DP(仅数据分割)/MP(仅模型分割)
  - DP+MP(模型分组共享,组内分割；数据分批,组内复制)
  - 专家+DP(专家分布在不同节点;数据按节点分割)
  - 专家+DP+MP(专家分布在不同节点;数据分批,组内复制)



# 结束
