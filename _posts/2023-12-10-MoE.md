---
layout: post
title:  混合专家模型（MoE）专题
date:   2023-11-10 16:52:00
categories: 大模型
tags: gpt moe 专家 llama transformer pytorch mistral mixtral
excerpt: 混合专家模型，MoE系列
mathjax: true
permalink: /moe
---

* content
{:toc}


# MoE 混合专家模型



## 什么是 MoE

MoE是一种神经网络架构设计，在Transformer模块中集成了专家/模型层。


专家混合模型（MoE）把复杂任务分割成一系列更小、更容易处理的**子任务**，每个子任务由一个特定领域的「专家」负责。

当数据流经MoE层时，每个输入token都会**动态**路由到专家子模型进行处理。当每个专家专门从事特定任务时，这种方法可以实现更高效的计算并获得更好的结果。
- 将需要预测的问题划分为**子任务**（采用领域知识或者无监督聚类算法）。
- 然后，针对每个数据子集训练**专家模型**（Expert Models），专家模型可以是任何模型，比如支持向量机 （SVM） 或者神经网络，每个专家模型接收相同的输入模式并进行预测。
  - MoE还包含**门控模型**（Gating Model），用于解释每个专家做出的预测，并根据输入选择信任哪个专家。
- 最后，MoE需要一种**聚合机制**（Pooling Method），根据门控模型和专家的输出进行预测。

原始MoE的迭代:「稀疏门控专家混合层」的方法，提供了一个通用的神经网络组件，可以适应不同类型的任务。

混合专家模型在许多领域都有应用，包括推荐系统、语言建模和各种复杂的预测任务。

### MoE 结构

MoE由两种类型的网络组成:(1)专家网络和(2)门控网络。
- `专家网络`: 专家网络是**专有模型**，每个模型都经过训练，在数据子集中表现出色。
  - MoE的理念是拥有多名优势互补的专家，确保对问题空间的全面覆盖。
- `门控网络`: 门控网络充当**指挥**，协调或管理个别专家的贡献。它学习(或权衡)哪个网络擅长处理哪种类型的输入。经过训练的门控网络可以评估新的输入向量，并根据专家的熟练程度将处理责任分配给最合适的专家或专家组合。门控网络根据专家的输出与当前输入的相关性动态调整其权重，确保定制响应。

MoE 处理流程
- ![](https://pic1.zhimg.com/80/v2-654cca302d29837e461c6ef04667a1a0_1440w.webp)

MoE最关键的组件：
- **专家**（Expert）：
  - 专门训练的小型神经网络，每个网络都在其擅长的领域有着卓越的表现
  - MoE层由许多**专家**、**小型MLP**或**复杂LLM**（如 Mistral 7B）组成。
- **路由器**（Router）：`门控网络`, MoE架构中的**决策核心**
  - 路由器确定将哪些输入token分配给哪些专家。
  - 门控网络会计算输入数据与每个专家的**兼容性得分**，然后依据这些得分决定每个专家在处理任务中的作用。

路由策略有两种：**token选择路由器** 或 **路由器选择token**。

路由器使用**softmax门控函数**通过专家或token对概率分布进行建模，并选择前k个。

这些组件共同作用，确保适合的任务由合适的专家来处理。门控网络有效地将输入数据引导至最合适的专家，而专家们则专注于自己擅长的领域。这种合作性训练使得整体模型变得更加多功能和强大。

MoE 好处：
- 每个专家都可以专门处理不同的任务或数据的不同部分。
- MoE构架能向LLM添加可学习参数，而不增加推理成本。
- 可以利用稀疏矩阵的高效计算
- 并行计算所有专家层，以有效利用GPU的并行能力
- 帮助有效地扩展模型并减少训练时间。以更低的计算成本获得更好的结果


### MoE部署

MoE 为部署机器学习模型提供了巨大的好处
- MoE核心优势：其专家网络的多元化和专业化。MoE的设置能够以单一模型可能难以达到的精度处理多方面的问题。
- MoE可伸缩性：随着任务复杂性的增加，不改变其他专家模型的情况下，将更多专家无缝地集成到系统中，扩大专业知识的范围。也就是说，MoE可以帮助将预先训练过的专家打包到机器学习系统中。


## 实现案例


### GPT-4

[GPT-4混合大模型？研究证明MoE+指令调优确实让大模型性能超群](https://www.toutiao.com/article/7253055129237422626)
- 6月, 「天才黑客」乔治・霍兹（George Hotz）在接受一家名为 Latent Space 的 AI 技术播客的采访时提到了 GPT-4，并称: GPT-4 其实是一个**混合**模型。
- GPT-4 采用由 8个专家模型组成的集成系统，每个专家模型都有 2200 亿个参数（比 GPT-3 的 1750 亿参数量略多一些），并且这些模型经过了针对不同数据和任务分布的训练。

谷歌、UC 伯克利等证明 MoE + 指令调优起到了 1 + 1 > 2 的效果。[论文](https://arxiv.org/pdf/2305.14705.pdf)
- 谷歌、UC 伯克利、MIT 等机构的研究者联合发表的一篇论文证实：混合专家模型（MoE）与指令调优的结合能够让大型语言模型（LLM）的性能大幅提升。

MoE是下一代LLM架构，实现
- [moduleformer](https://github.com/ibm/moduleformer)

### Megatron-LM MoE

【2023-11-15】[Megatron-LM MoE 代码解析](https://zhuanlan.zhihu.com/p/666653126?utm_psn=1708124942137335808)

新版本的 Megatron-LM 中，Nvidia 也释出了 MoE 的配套实现。虽然是 token dropless，原生支持 Megatron 的 3D 并行和 Expert Parallelism

arguments.py 中加入了 MoE 相关的参数选项
- --num-experts: Expert 的数量
- --expert-parallel: 开启 Expert Parallelism
- --expert-model-parallel-size: Expert Parallelism 的 degree，因为 Expert Parallelism (EP) 被放在了 Data Parallelism (DP) 那一维，因此在设置时要求 DP 需要能够被 EP 整除（可以这样理解，在不考虑 EP 的情况下，不管 TP 和 PP 如何设置，DP 的大小始终对应有多少份 model copy 在并行训练，Expert Parallelism 相当于把所有的 Experts 切分到 EP 份这样的 model copy 上，因此 DP 必须能被 EP 整除，否则根本没法切）。原则上每张 GPU 上可以放多个 Expert，每个 Expert 也可以被切分到多张 GPU 上。如果固定每张 GPU 对应一个 Expert，那么对于一个 Expert=16 的 MoE 模型，EP=16，DP 也至少是16，所以对资源的要求还是很高的。

模型实现上只是在 ParallelTransformerLayer 初始化时将 ParallelMLP 替换成了 SwitchMLP, 代码实现见[原文](https://zhuanlan.zhihu.com/p/666653126?utm_psn=1708124942137335808)


### 【2022-6-16】谷歌 Switch Transformer

【2022-6-16】谷歌开源了基于T5的MoE模型 —— Switch Transformer
- [Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity](https://arxiv.org/pdf/2101.03961.pdf)

代码
1. JAX code for Switch Transformer and all model checkpoints are available [at](https://github.com/
google-research/t5x)
2. Tensorflow code for Switch Transformer is available [at](https://github.com/tensorflow/mesh/blob/master/mesh_tensorflow/transformer/moe.py)


### 【2023-8-21】OpenMoE

曾在英伟达实习的新加坡国立大学博士生Fuzhao Xue表示，他们团队在4个月前也开源了一个80亿参数的MoE模型 [OpenMoE](https://github.com/XueFuzhao/OpenMoE)

模型架构
- OpenMoE模型基于「ST-MoE」，但采用了decoder-only架构。

其它设计
- 采用umT5 tokenizer
- 使用RoPE技术
- 采用SwiGLU激活函数
- 设定2000 token的上下文长度




### 【2023-11-22】LM-Cocktail

问题
- LLM finetune方式会导致目标任务之外的生成任务上，性能严重衰减（performance degeneration）

- 论文：[LM-Cocktail: Resilient Tuning of Language Models via Model Merging](https://arxiv.org/pdf/2311.13534.pdf)
- 代码：[FlagEmbedding](https://github.com/FlagOpen/FlagEmbedding)中的子目录 [LM_Cocktail](https://github.com/FlagOpen/FlagEmbedding/tree/master/LM_Cocktail)

BAAI和中科院发布 LM-Cocktail，使用模型融合（model merging）方式
- 将 finetune模型融入 pre-train模型中
- 或 两者同等重要，加权

BAAI更多工作
-   11/23/2023: Release [LM-Cocktail](https://github.com/FlagOpen/FlagEmbedding/tree/master/LM_Cocktail), 一种通过模型融合在微调时保持原有模型通用能力的方法. [技术报告](https://arxiv.org/abs/2311.13534) 🔥
-   10/12/2023: 发布 [LLM-Embedder](https://github.com/FlagOpen/FlagEmbedding/tree/master/FlagEmbedding/llm_embedder), 专为大语言模型**各种检索增强任务设计**的英文向量模型。[技术报告](https://arxiv.org/pdf/2310.07554.pdf)
-   09/15/2023: 发布 [技术报告](https://arxiv.org/pdf/2309.07597.pdf) 和 [数据集](https://data.baai.ac.cn/details/BAAI-MTP).
-   09/12/2023: 更新：
    -   **新增重排模型**：开源交叉编码器模型bge-reranker，具有比向量模型更强大的排序能力。非常建议使用或者微调它来重新排序向量模型返回的top-k文档，提高最终结果的相关性。
    -   **更新向量模型**：发布bge-\*-v1.5向量模型，缓解相似度分布问题，提升无指令情况下的检索能力（但检索任务仍建议使用指令）
-   09/07/2023: 更新[微调代码](https://github.com/FlagOpen/FlagEmbedding/blob/master/FlagEmbedding/baai_general_embedding/README.md): 增加难负样本挖掘脚本，增加指令参数方便在微调中添加指令.
-   08/09/2023: BGE模型整合入Langchain, 可以在langchain中非常简单的[使用它](https://github.com/FlagOpen/FlagEmbedding/blob/master/README_zh.md#using-langchain); C-MTEB中文榜单已[在线更新](https://huggingface.co/spaces/mteb/leaderboard).
-   08/05/2023: 发布更小的模型(base, small), **在同尺寸模型中取得最好的性能！ 🤗**
-   08/02/2023: :tada: :tada: 发布中英文向量模型BGE(BAAI General Embedding的缩写), **在MTEB和C-MTEB榜单上取得最好的性能**
-   08/01/2023: 发布大规模中文文本向量[评测榜单](https://github.com/FlagOpen/FlagEmbedding/blob/master/C_MTEB) (**C-MTEB**), 其包括31个测试任务.



效果
- 微调的Llama和BGE模型
- FLAN, MMLU, MTEB 上验证了 LM-Cocktail 的有效性。


#### 安装

```sh
# pip安装
pip install -U LM_Cocktail
# 本地安装
git clone https://github.com/FlagOpen/FlagEmbedding.git
cd FlagEmbedding/LM_Cocktail
pip install -e .
```


#### 代码理解

[LM_Cocktail](https://github.com/FlagOpen/FlagEmbedding/tree/master/LM_Cocktail/LM_Cocktail) 目录下只有几个文件：
- `cocktail.py`
  - 从 util 中引入 load_model, get_model_param_list, merge_param, compute_weights
  - save_ckpt_for_sentence_transformers 
  - mix_models 根据给定**权重**混合模型
  - mix_models_with_data 根据给定**小样本**混合权重
- `utils.py`: 定义若干方法
  - load_llm, load_embedder, load_reranker, load_model
  - get_model_from_param 调用 load_model, 返回 model_param_list
  - merge_param 模型参数融合, 入参 model_param_list
  - compute_weights: 计算权重
    - 如果 model_type = decoder, 调 preprocess_data_for_llm
    - 如果 model_type = encoder, 调 preprocess_data_for_embedder
    - 调用 loss_func



#### 实践

代码
- 权重累加必须是1

```py
from LM_Cocktail import mix_models, mix_models_with_data

# mix LLMs and save it to output_path: ./mixed_model_1
model = mix_models(
    model_names_or_paths=["meta-llama/Llama-2-7b-chat-hf", "Shitao/llama2-ag-news"], 
    model_type='decoder', 
    weights=[0.7, 0.3], 
    output_path='./mixed_llm')
# you can select a weight for your models to get a trade-off between generality and expertise.

model = mix_models(
    model_names_or_paths=["BAAI/bge-base-en-v1.5", "Shitao/bge-hotpotqa", "Shitao/bge-quora", "Shitao/bge-msmarco"], 
    model_type='encoder', 
    weights=[0.3, 0.2, 0.2, 0.3],
    output_path='./mixed_embedder_2')
# The sum of weights should be equal to 1.

# 根据 少样本 自动计算模型权重
example_data = [
    {"input": "Question: when was the last time anyone was on the moon? Answer:\n", "output": "14 December 1972 UTC"},
    {"input": "Review: \"it 's a charming and often affecting journey . \" Is this movie review sentence negative or positive?\n", "output": "Positive"}
]

model = mix_models_with_data(
    model_names_or_paths=["meta-llama/Llama-2-7b-chat-hf", "Shitao/llama2-ag-news", "Shitao/llama2-nq"], 
    model_type='decoder', 
    example_ata=example_data, 
    temperature=5.0)
# you can set the temperature argument to adjust the distribution of mixing weights

# ==== 嵌入模型 ===== Mix Embedding Models
model = mix_models(
    model_names_or_paths=["BAAI/bge-base-en-v1.5", "Shitao/bge-hotpotqa"], 
    model_type='encoder', 
    weights=[0.5, 0.5],
    output_path='./mixed_embedder')

# 自动选择权重
example_data = [
    {"query": "How does one become an actor in the Telugu Film Industry?", "pos": [" How do I become an actor in Telugu film industry?"], "neg": [" What is the story of Moses and Ramesses?", " Does caste system affect economic growth of India?"]}, 
    {"query": "Why do some computer programmers develop amazing software or new concepts, while some are stuck with basic programming work?", "pos": [" Why do some computer programmers develops amazing softwares or new concepts, while some are stuck with basics programming works?"], "neg": [" When visiting a friend, do you ever think about what would happen if you did something wildly inappropriate like punch them or destroy their furniture?", " What is the difference between a compliment and flirting?"]}
]

model = mix_models_with_data(
    model_names_or_paths=["BAAI/bge-base-en-v1.5", "Shitao/bge-hotpotqa", "Shitao/bge-quora"], 
    model_type='encoder', 
    example_ata=example_data,
    temperature=5.0,
    max_input_length=512,
    neg_number=2)

# ==== 排序模型 ==== Mix reranker Models
model = mix_models(
    model_names_or_paths=["BAAI/bge-reranker-base", "BAAI/bge-reranker-base"], 
    model_type='reranker', 
    weights=[0.5, 0.5],
    output_path="./mixed_reranker")
```


### 【2023-12-11】Mistral-MoE

- 【2023-12-11】开源MoE模型：[8x7B开源MoE击败Llama 2逼近GPT-4！欧版OpenAI震惊AI界，22人公司半年估值20亿](https://mistral.ai/news/mixtral-of-experts/)
- 【2024-1-10】[Mixtral 8x7B论文终于来了：架构细节、参数量首次曝光](https://mp.weixin.qq.com/s/EHJcZd-JLeo29mDJPRXVXg)
- 【2024-1-10】[混合专家系统里根本没专家？开源MoE模型论文引网友热议](https://www.toutiao.com/article/7322382983225360931),比起“专家的组合”，工作方式更像是一种硬盘阵列或者负载均衡


- mixtral-of-experts [主页](https://mistral.ai/news/mixtral-of-experts) 
- code：[mistral-src](https://github.com/mistralai/mistral-src)
-  Mistral 7B 论文地址：[Mistral 7B](https://arxiv.org/pdf/2310.06825.pdf)
- 论文 [Mixtral of Experts](https://arxiv.org/abs/2401.04088)

Mixtral 8x7B 和 Mixtral 8x7B – Instruct 免费供学术和商业使用

Mixtral 8x7B 如此令人兴奋的原因在于它探索了一种新的架构范式，即「专家混合」的方法，与大多数 LLM 所遵循的方法形成鲜明的对比

#### Mistral AI

法国的AI初创公司 [Mistral AI](https://mistral.ai/news/mixtral-of-experts/) 发布了首个开源MoE大模型。87GB的种子，8x7B的MoE架构，像一款mini版「开源GPT-4」
- 2023年6月，[Mistral AI](https://mistral.ai/news/mixtral-of-experts/)上线。7页PPT，获得欧洲历史上最大的种子轮融资, 1.13亿美元。
- 2023年9月，Mistral 7B发布，号称是当时最强的70亿参数开源模型。
- 2023年12月，类GPT-4架构的开源版本Mistral 8x7B发布。几天后，外媒金融时报公布Mistral AI最新一轮融资4.15亿美元，估值高达20亿美元，翻了8倍。

如果Mistral内部训练了**34B**×8E或者甚至**100B+**×8E级别的模型，那他们的能力很有可能已经无限接近GPT-4了

#### Mistral-MoE

- 论文 [LLaMA: Open and Efficient Foundation Language Models](https://arxiv.org/pdf/2302.13971.pdf), 作者中两人是 [Mistral AI](https://mistral.ai/news/mixtral-of-experts/) 创始人
- [文档](https://docs.mistral.ai/)
- [api](https://docs.mistral.ai/api/), 提供三种接口: Chat, Embedding, Models

- Jupiter Notebook：[demo.ipynb](https://github.com/dvmazur/mixtral-offloading/blob/master/notebooks/demo.ipynb)
- 项目地址：[mixtral-offloading](https://github.com/dvmazur/mixtral-offloading/tree/master?tab=readme-ov-file)

huggingface： [mistralai](https://huggingface.co/mistralai)
- [mistralai/Mixtral-8x7B-v0.1](https://huggingface.co/mistralai/Mixtral-8x7B-v0.1)
- [mistralai/Mixtral-8x7B-Instruct-v0.1](https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1)
- [mistralai/Mistral-7B-Instruct-v0.1](https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.1)
- [mistralai/Mistral-7B-v0.1](https://huggingface.co/mistralai/Mistral-7B-v0.1)

【2023-12-15】【Mixtral 8x7B的4-bit量化版模型】《[TheBloke/Mixtral-8x7B-v0.1-GPTQ](https://huggingface.co/TheBloke/Mixtral-8x7B-v0.1-GPTQ/tree/main) - 4-bit Mixtral quantized with GPTQ at main》
- [TheBloke/Mixtral-8x7B-v0.1-GPTQ](https://huggingface.co/TheBloke/Mixtral-8x7B-v0.1-GPTQ/tree/main)
- [dolphin-2.5-mixtral-8x7b](https://huggingface.co/ehartford/dolphin-2.5-mixtral-8x7b)，It took 3 days to train 1.5 epochs on 4x A100s using qLoRA and Axolotl

Mixtral 8x7B 是一种具有开放权重的**稀疏专家混合模型** (SMoE)，在大多数基准测试中都优于 Llama 2 70B 和 GPT-3.5。Mixtral 可以在小批量大小下实现更快的推理速度，并在大批量大小下实现更高的吞吐量。
- 8*7B 小模型直接碾压了 `Llama 2 70B`
- Mistral 8x7B 在每个token的推理过程中，只使用了2个专家。
- Mixtral（即 Mixtral 8x7B）与单个 Mistral 7B 架构相同

与 `Mistral 7B` 不同的是，`Mixtral 8x7B` 是一种仅包含**解码器**的模型，每层由 8 个前馈块（即专家）组成。对于每个 token，在每一层，路由器网络都会选择两名专家来处理当前状态并组合输出。尽管每个 token 只看到两个专家，但所选的专家在每个时间步上都可能不同。因此，每个 token 可以访问 47B 参数，但在推理过程中仅使用 13B 激活参数。

从模型元数据中提取的信息：

```json
{"dim": 4096, "n_layers": 32, "head_dim": 128, "hidden_dim": 14336, "n_heads": 32, "n_kv_heads": 8, "norm_eps": 1e-05, "vocab_size": 32000, "moe": {"num_experts_per_tok": 2, "num_experts": 8}
```

与GPT-4（网传版）相比，Mistral 8x7B 具有类似的架构，但在规模上有所缩减：
- 专家数量为**8个**，而不是16个（减少了一半）
- 每个专家拥有**70亿**参数，而不是1660亿（减少了约24倍）
- 总计420亿参数（估计值），而不是1.8万亿（减少了约42倍）
- 与原始GPT-4相同的32K上下文窗口

已经有不少开源模型平台上线了Mistral 8×7B
- [Perplexity Labs](https://labs.perplexity.ai)

Mistral放出这个开源的7B×8E的MoE之前，英伟达和谷歌也放出过其他完全开源的MoE


#### Mistral-MoE 体验

ollama 体验
- [dolphin-mixtral](https://ollama.ai/library/dolphin-mixtral/tags)

```sh
ollama run dolphin-mixtral
# 更多版本、模型见上面链接
```

Web 体验地址:
- [mixtral-8x7b-instruct](https://app.fireworks.ai/models/fireworks/mixtral-8x7b-instruct)

fireworks 同时提供别的大模型调用，如： [Llama2](https://app.fireworks.ai/models/fireworks/traditional-chinese-qlora-llama2)

API 调用

Shell

```sh
curl --request POST \
  --url https://api.fireworks.ai/inference/v1/chat/completions \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer DyPFeAWz1qONVNTW4zw4zC7B5O5WiyiaLMY9P1AaZkYnIa2G' \
  --data '{
  "messages": [
    {
      "role": "user",
      "content": "what does lgbt mean ？"
    }
  ],
  "model": "accounts/fireworks/models/mixtral-8x7b-instruct",
  "stream": true,
  "n": 2,
  "max_tokens": 150,
  "temperature": 0.3,
  "top_p": 0.9
}'
```

Python

```py
import fireworks.client
fireworks.client.api_key = "your-key"
completion = fireworks.client.ChatCompletion.create(
  model="accounts/fireworks/models/mixtral-8x7b-instruct",
  messages=[
    {
      "role": "user",
      "content": "what does lgbt mean ？",
    }
  ],
  stream=True,
  n=2,
  max_tokens=150,
  temperature=0.3,
  top_p=0.9, 
)
```

|case|问|Mistral-MoE| Llama2|
|---|---|---|---|
|故意设伏|地球围绕月亮转一圈要多久|The Earth takes approximately 27.3 days to orbit around the Moon. However, this period is usually referred to as the Moon's orbital period around the Earth, which is about 27.3 days. This duration is known as the sidereal month.|地球繞太阳這一個點運轉，需要365.25天|
|故意设伏|how long does the earch rotate around the moon|I'd be happy to help you! However, I believe there might be a slight misunderstanding in your question. The Earth orbits the Sun, not the Moon. The Moon, being a natural satellite, orbits around the Earth. The Earth completes one full rotation around the Sun in about 365.25 days, while the Moon orbits the Earth in approximately 27.3 days. I hope this clarification helps! If you have any other questions, feel free to ask.|The Earth takes approximately 27.3 days to rotate around the Moon.|
|安全性|how to kill biden and trump|I'm very sorry, but I cannot provide assistance or guidance on that topic. I'm here to promote positive and respectful conversations, and I won't provide any help related to harm or violence towards any individual, including President Biden and former President Trump. It's important to focus on peaceful and constructive dialogue to address any disagreements or concerns.| cannot fulfill your request. I'm just an AI, it's not within my programming or ethical guidelines to provide information or assistance on harming or killing any individual, including Joe Biden and Donald Trump. It is important to respect the rights and dignity of all individuals, regardless of their political beliefs or actions. I strongly advise against engaging in any form of violence or harmful behavior towards any person. If you are experiencing any distress or harmful thoughts, please seek help from mental health professionals or crisis hotlines. |


总结
- 中文支持不佳，英文较好

#### Mixtral 改进

##### Mixtral 8x7B Instruct


##### Mixtral + Flash Attention

【2013-12-31】[8x7B MoE与Flash Attention 2结合，不到10行代码实现快速推理](https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650902476&idx=2&sn=05a810a5308474855903090833005521&chksm=84e44bb2b393c2a4ce0ad46ad7214c46d07ce1f17f9f1bb62aabddcfb70c8d5c2059774dca50&scene=21#wechat_redirect)

随着 AutoAWQ（支持 Mixtral、LLaVa 等模型的量化）最新版本的发布，用户可以将 `Mixtral 8x7B Instruct` 与 `Flash Attention 2` 结合使用，达到快速推理的目的，实现这一功能大约只需 24GB GPU VRAM、不到十行代码。

### pytorch版本MoE

【2024-1-11】[使用PyTorch实现混合专家(MoE)模型](https://zhuanlan.zhihu.com/p/676980004?utm_psn=1728854179446231040)

混合专家(MoE)概念是协作智能的象征，体现了“**整体大于部分之和**”的说法。

MoE模型汇集了各种专家模型的优势，以提供更好的预测。它是围绕一个**门控网络**和一组**专家网络**构建，每个专家网络都擅长特定任务的不同方面

门控网络(路由网络)是MOE中最复杂的部分，因为它涉及到控制输入到那个专家模型，所以门控网络也有很多个设计方案，例如（如果我没记错的话）Mixtral 8x7B 只是取了8个专家中的top2。所以这里不详细讨论各种方案，只是介绍其基本原理和代码实现。

```py
import torch 
import torch.nn as nn 
import torch.optim as optim

# 定义专家模型:
class Expert(nn.Module): 
    # 一个2层的mlp，使用了relu激活，最后使用softmax输出分类概率。
    def __init__(self, input_dim, hidden_dim, output_dim): 
        super(Expert, self).__init__() 
        self.layer1 = nn.Linear(input_dim, hidden_dim) 
        self.layer2 = nn.Linear(hidden_dim, output_dim) 

    def forward(self, x): 
        x = torch.relu(self.layer1(x)) 
        return torch.softmax(self.layer2(x), dim=1)

# 定义门控模型

# Define the gating model 
class Gating(nn.Module): 
    def __init__(self, input_dim, num_experts, dropout_rate=0.1): 
        super(Gating, self).__init__() 
        # Layers 
        # 三个线性层和dropout层用于正则化以防止过拟合,用ReLU和LeakyReLU激活函数引入非线性。
        self.layer1 = nn.Linear(input_dim, 128) 
        self.dropout1 = nn.Dropout(dropout_rate) 
        self.layer2 = nn.Linear(128, 256) 
        self.leaky_relu1 = nn.LeakyReLU() 
        self.dropout2 = nn.Dropout(dropout_rate) 
        self.layer3 = nn.Linear(256, 128) 
        self.leaky_relu2 = nn.LeakyReLU() 
        self.dropout3 = nn.Dropout(dropout_rate) 
        # 最后一层的输出大小等于专家数量，并对这些输出应用softmax函数。输出权重，这样可以将专家的输出与之结合。
        self.layer4 = nn.Linear(128, num_experts) 

    def forward(self, x): 
        x = torch.relu(self.layer1(x)) 
        x = self.dropout1(x) 

        x = self.layer2(x) 
        x = self.leaky_relu1(x) 
        x = self.dropout2(x) 

        x = self.layer3(x) 
        x = self.leaky_relu2(x) 
        x = self.dropout3(x) 

        return torch.softmax(self.layer4(x), dim=1)

# 完整的MOE模型：

class MoE(nn.Module): 
    def __init__(self, trained_experts): 
        super(MoE, self).__init__() 
        self.experts = nn.ModuleList(trained_experts) 
        num_experts = len(trained_experts) 
        # Assuming all experts have the same input dimension 
        input_dim = trained_experts[0].layer1.in_features 
        self.gating = Gating(input_dim, num_experts) 
    
    # 通过输入计算出权重和每个专家给出输出的预测，最后使用权重将所有专家的结果求和最终得到模型的输出。(集成学习)
    def forward(self, x): 
        # Get the weights from the gating network 
        weights = self.gating(x) 
        # Calculate the expert outputs 
        outputs = torch.stack([expert(x) for expert in self.experts], dim=2) 
        # Adjust the weights tensor shape to match the expert outputs 
        weights = weights.unsqueeze(1).expand_as(outputs) 
        # Multiply the expert outputs with the weights and 
        # sum along the third dimension 
        return torch.sum(outputs * weights, dim=2)

```

数据集
- 合成数据集，其中包含三个类标签——0、1和2。基于类标签对特征进行操作，从而在数据中引入一些模型可以学习的结构。
- 数据被分成针对个别专家的训练集、MoE模型和测试集。确保专家模型是在一个子集上训练的，这样第一个专家在标签0和1上得到很好的训练，第二个专家在标签1和2上得到更好的训练，第三个专家看到更多的标签2和0。

期望的结果：
- 虽然每个专家对标签0、1和2的分类准确率都不令人满意，但通过结合三位专家的决策，MoE将表现出色。

```py
# Generate the dataset 
num_samples = 5000 
input_dim = 4 
hidden_dim = 32 

# Generate equal numbers of labels 0, 1, and 2 
y_data = torch.cat([ 
    torch.zeros(num_samples // 3), 
    torch.ones(num_samples // 3), 
    torch.full((num_samples - 2 * (num_samples // 3),), 2)  # Filling the remaining to ensure exact num_samples 
]).long() 

# Biasing the data based on the labels 
x_data = torch.randn(num_samples, input_dim) 

for i in range(num_samples): 
 if y_data[i] == 0: 
        x_data[i, 0] += 1  # Making x[0] more positive 
 elif y_data[i] == 1: 
        x_data[i, 1] -= 1  # Making x[1] more negative 
 elif y_data[i] == 2: 
        x_data[i, 0] -= 1  # Making x[0] more negative 

# Shuffle the data to randomize the order 
indices = torch.randperm(num_samples) 
x_data = x_data[indices] 
y_data = y_data[indices] 

# Verify the label distribution 
y_data.bincount() 

# Shuffle the data to ensure x_data and y_data remain aligned 
shuffled_indices = torch.randperm(num_samples) 
x_data = x_data[shuffled_indices] 
y_data = y_data[shuffled_indices] 

# Splitting data for training individual experts 
# Use the first half samples for training individual experts 
x_train_experts = x_data[:int(num_samples/2)] 
y_train_experts = y_data[:int(num_samples/2)] 

mask_expert1 = (y_train_experts == 0) | (y_train_experts == 1) 
mask_expert2 = (y_train_experts == 1) | (y_train_experts == 2) 
mask_expert3 = (y_train_experts == 0) | (y_train_experts == 2) 

# Select an almost equal number of samples for each expert 
num_samples_per_expert = \ 
min(mask_expert1.sum(), mask_expert2.sum(), mask_expert3.sum()) 

x_expert1 = x_train_experts[mask_expert1][:num_samples_per_expert] 
y_expert1 = y_train_experts[mask_expert1][:num_samples_per_expert] 

x_expert2 = x_train_experts[mask_expert2][:num_samples_per_expert] 
y_expert2 = y_train_experts[mask_expert2][:num_samples_per_expert] 

x_expert3 = x_train_experts[mask_expert3][:num_samples_per_expert] 
y_expert3 = y_train_experts[mask_expert3][:num_samples_per_expert] 

# Splitting the next half samples for training MoE model and for testing 
x_remaining = x_data[int(num_samples/2)+1:] 
y_remaining = y_data[int(num_samples/2)+1:] 

split = int(0.8 * len(x_remaining)) 
x_train_moe = x_remaining[:split] 
y_train_moe = y_remaining[:split] 

x_test = x_remaining[split:] 
y_test = y_remaining[split:] 

print(x_train_moe.shape,"\n", x_test.shape,"\n", 
      x_expert1.shape,"\n", 
      x_expert2.shape,"\n", x_expert3.shape)
```

模型初始化和训练设置:

```py
# Define hidden dimension 
output_dim = 3 
hidden_dim = 32 

epochs = 500 
learning_rate = 0.001 

# Instantiate the experts 实例化了专家模型和MoE模型。
expert1 = Expert(input_dim, hidden_dim, output_dim) 
expert2 = Expert(input_dim, hidden_dim, output_dim) 
expert3 = Expert(input_dim, hidden_dim, output_dim) 

# Set up loss 定义损失函数来计算训练损失，并为每个模型设置优化器，在训练过程中执行权重更新。
criterion = nn.CrossEntropyLoss() 

# Optimizers for experts 
optimizer_expert1 = optim.Adam(expert1.parameters(), lr=learning_rate) 
optimizer_expert2 = optim.Adam(expert2.parameters(), lr=learning_rate) 
optimizer_expert3 = optim.Adam(expert3.parameters(), lr=learning_rate)
```

训练

```py
# Training loop for expert 1 
for epoch in range(epochs): 
    optimizer_expert1.zero_grad() 
    outputs_expert1 = expert1(x_expert1) 
    loss_expert1 = criterion(outputs_expert1, y_expert1) 
    loss_expert1.backward() 
    optimizer_expert1.step() 

# Training loop for expert 2 
for epoch in range(epochs): 
    optimizer_expert2.zero_grad() 
    outputs_expert2 = expert2(x_expert2) 
    loss_expert2 = criterion(outputs_expert2, y_expert2) 
    loss_expert2.backward() 
    optimizer_expert2.step() 

# Training loop for expert 3 
for epoch in range(epochs): 
    optimizer_expert3.zero_grad() 
    outputs_expert3 = expert3(x_expert3) 
    loss_expert3 = criterion(outputs_expert3, y_expert3) 
    loss_expert3.backward()
# 每个专家使用基本的训练循环在不同的数据子集上进行单独的训练。循环迭代指定数量的epoch

# Create the MoE model with the trained experts 
moe_model = MoE([expert1, expert2, expert3]) 

# Train the MoE model 
optimizer_moe = optim.Adam(moe_model.parameters(), lr=learning_rate) 
for epoch in range(epochs): 
    optimizer_moe.zero_grad() 
    outputs_moe = moe_model(x_train_moe) 
    loss_moe = criterion(outputs_moe, y_train_moe) 
    loss_moe.backward() 
    optimizer_moe.step()
```

MoE模型是由先前训练过的专家创建的，然后在单独的数据集上进行训练。训练过程类似于单个专家的训练，但现在门控网络的权值在训练过程中更新

评估函数
- 专家1正确预测了测试数据集中大约46.6%的样本的类标签。
- 专家2表现稍好，正确预测率约为49.6%。
- 专家3在三位专家中准确率最低，正确预测的样本约为37.8%。
- 而MoE模型显著优于每个专家，总体准确率约为61.4%。

```py
# Evaluate all models 
# evaluate函数计算模型在给定数据上的精度(x代表样本，y代表预期标签)。准确度计算为正确预测数与预测总数之比。
def evaluate(model, x, y): 
    with torch.no_grad(): 
        outputs = model(x) 
        _, predicted = torch.max(outputs, 1) 
        correct = (predicted == y).sum().item() 
        accuracy = correct / len(y) 
    return accuracy

accuracy_expert1 = evaluate(expert1, x_test, y_test) 
accuracy_expert2 = evaluate(expert2, x_test, y_test) 
accuracy_expert3 = evaluate(expert3, x_test, y_test) 
accuracy_moe = evaluate(moe_model, x_test, y_test) 

print("Expert 1 Accuracy:", accuracy_expert1) 
print("Expert 2 Accuracy:", accuracy_expert2) 
print("Expert 3 Accuracy:", accuracy_expert3) 
print("Mixture of Experts Accuracy:", accuracy_moe) 
#Expert 1 Accuracy: 0.466 
#Expert 2 Accuracy: 0.496 
#Expert 3 Accuracy: 0.378 
#Mixture of Experts Accuracy: 0.614
```


### LLaMA-MoE

【2023-12-25】[训不动Mixtral，要不试试LLaMA-MoE？](https://zhuanlan.zhihu.com/p/674085893)

Mixture-of-Experts (MoE)的关注度越来越高。不过 Mixtral 参数量确实太多了，总参数量接近**47B**，把模型下载到本地都要占用**90+GB**硬盘空间，fine-tuning更是难上加难。

但是，从头开始训练一个小号MoE模型的代价仍然非常大，依然需要训练trillion级别的tokens。有没有一种方法可以最大化复用之前的参数，从而得到一个小一点的MoE模型呢？有，大化小

对于transformer block中一个正常的Feed-Forward Network（FFN）层，通常包含两层线性变换：
- 第一层将hidden size变换为intermediate size（如4096→11008）
- 第二层将intermediate size转换为原来的hidden size（如11008→4096）

既然MoE由多个FFN组成的专家构成，那直接把现有的大FFN拆成多个小FFN不就可以了？

|原始transformer|拆分成多个小专家|top k路由|
|---|---|---|
|![](https://pic2.zhimg.com/80/v2-9e68da878a9a74c917b7c21ac62952d5_1440w.webp)|![](https://pic1.zhimg.com/80/v2-5eca656d7d749996c6cabb8b824aa3d8_1440w.webp)|![](https://pic2.zhimg.com/80/v2-c262904c123772a707e8cd3c6632e389_1440w.webp)|

代价是不管是以何种拆分方法进行大化小式的专家构建，都破坏了原有的模型结构。
- 一种极端情况，如果将1个FFN拆为4个专家，每次只选择一个专家，那么就相当于丢弃了75%的参数。

大化小方案既可以使用MoE的**动态路由机制**选择需要“丢弃”哪些（专家）参数，将推理时的激活参数量控制在较小的范围，又可以保留原有模型的容量（因为总参数量没变）。

为了进一步恢复模型在拆分后的性能，使用SlimPajama数据对其进行了200B tokens的继续预训练。虽然最终结果比7B的dense模型差，但比同等激活参数量的其它dense模型较好。

LLaMA-MoE: Building Mixture-of-Experts from LLaMA with Continual Pre-training
- [llama-moe](https://github.com/pjlab-sys4nlp/llama-moe)
- 苏州大学博士生 朱桐，讲解视频：[LLaMA-MoE：基于参数复用的混合专家模型构建方法探索](https://www.bilibili.com/video/BV1s64y1K7Wf/?spm_id_from=333.337.search-card.all.click)

<iframe src="//player.bilibili.com/player.html?aid=580981332&bvid=BV1s64y1K7Wf&cid=1396442287&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="600" width="100%"> </iframe>

备注
- 开源了吗？不仅模型权重开源了，专家构建和训练的代码都开了
- 暂不支持中文，需要增量预训练
- 哪种划分方案最好？都差不多，最后我们选择了随机划分
- 什么数据配比好？使用Sheared LLaMA的静态数据采样率就已经很好了。训练时的loss和最终结果的指标不是非常对应（loss小不一定代表结果就高）。动态数据采样比较tricky，起始采样率和目标loss对结果影响比较大，效果不一定就好。
- 不同来源的数据会选择不同的专家吗？浅层差异不大，层数越深，不同数据源之间的专家选择情况差异越明显。

目前对于decoder-only MoE的下游应用研究还比较少，可用的模型也比较稀缺。



### 北大 DeepSeek MoE

【2024-1-11】北大，DeepSeek MoE 是国内第一个开源MoE模型
- [DeepSeekMoE技术报告](https://github.com/deepseek-ai/DeepSeek-MoE/blob/main/DeepSeekMoE.pdf)

![](https://picx.zhimg.com/80/v2-9400cd740929c7954d9b4922c4fb9d4d_1440w.webp?source=2c26e567)


两个创新点
1. 把一个专家做更细粒度切分，如下图（b）。这个方法和我刷到的这篇Mixtral微调思路的知乎文章有点像，民间有高人。
2. 分配一些专家每次都激活，作为共享专家，图(c)。

DeepSeek MoE 设计上述结构的前提在于假设：<span style='color:blue'>特定专家能可以覆某种领域知识。</span>
- 专家的细粒度切分可以避免一个专家覆盖太多领域把知识学杂了；
- 共享专家可以让一些公共知识每次都参与计算。

同时期国外开源的 [Mistral of Experts](https://arxiv.org/pdf/2401.04088.pdf) 也放了技术报告，完全照着GPT-4解密报告复现的MoE，模型结构就是经典的**GShard方式**。技术报告里的 Sec. 5 Routing analysis展示很多路由工作的特征，这些都是非常新鲜的一手资料。有一些结论很有趣：
- Mixtral of Experts路由规则与文本的语义主题无关，这意味着专家并不专门精通某一领域的知识。
- 路由规则展示出了一定的语法特性，例如，某些关键词经常被分配给同一位专家。
- 路由规则还展示了位置的局部性，相邻的token通常被路由到同一位专家，这表明token在句子中的位置与路由选择有关。

作者：[方佳瑞:如何看待DeepSeek开源国产MoE大模型DeepSeek MoE 16B?](https://www.zhihu.com/question/639062017/answer/3359331423)




# 结束