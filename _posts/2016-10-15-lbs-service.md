---
layout: post
title:  "LBS 技术专题"
date:   2016-10-15 10:30:00
categories: 技术工具
tags: 高德 gps geohash base64
author : 鹤啸九天
excerpt: LBS 技术相关知识
mathjax: true
permalink: /lbs
---

* content
{:toc}

# LBS 技术

汇总 LBS 相关技术

## 地理坐标


### 如何判断距离

【2022-7-13】高德用户常驻点挖掘，拿用户过去一个月的定位点数据聚类，大大超过阿里odps单机800m限制，于是开始思考如何精简数据，方法：
- ① 根据时间信息计算定位点瞬时速度，加速度，剔除运动点，漂移点，过滤了大概2/3
- ② geohash，将地理坐标投射到直线上，降低数据量
  - [geometry](https://halfrost.com/go_spatial_search/) 比geohash 好？
  - [geohash](https://www.cnblogs.com/tgzhu/articles/6204173.html)
- ③ 改进密度聚类算法dbscan，球面距离计算公式部分改成根据经纬度明式距离直接排除噪声点…最终在odps跑通了…另外，调研过路径匹配的方案，微软有篇文章

### GeoHash 技术原理

【2023-8-9】[GeoHash 技术原理及应用实战](https://zhuanlan.zhihu.com/p/645078866)

场景
- 打开手机中的地图 app，检索附近1 公里范围内的餐馆，挑选合适的用餐地点

问题
- 如何对指定范围内的餐馆信息进行精确推送和展示
- ![](https://pic2.zhimg.com/80/v2-79b243c3135441d8f67405be3f5a806d_1440w.webp)

解法
- 暴力：遍历所有 经纬度坐标，选最近（不考虑3D城市重庆）

#### 暴力解

简单粗暴的实现方式：
-   把地球上所有餐馆的 (lng,lat) 坐标都维护在一个 list 里
-   获取到小徐先生所在的北京人家的坐标 (lng0,lat0)
-   遍历 list 中所有餐馆的 (lng,lat) 坐标，求出和 (lng0,lat0) 的相对距离，如果大于指定距离就过滤，小于等于指定距离就保留
-   最终被保留在 list 中的餐馆集合就是我们所求的目标
- ![](https://pic4.zhimg.com/80/v2-dcbf193590cb60cd5ede62c0a720221b_1440w.webp)

分析
- 全量餐馆数据规模何其庞大，每次执行范围检索时都要全量遍历计算，工作量足以击垮任何一个服务集群.

#### 索引法

优化思路: 以空间换取时间. 

核心挑战: 如何合理设计用于存储位置信息的空间结构.

常规思路: 
- 利用**索引**提高检索效率
- 本场景中，每个位置是由二维的 (lng,lat) 坐标组成的，这要如何设计成索引呢？

geohash 把这种**二维经纬度坐标**转换成带**前缀索引**性质的**一维坐标**，这个特殊一维坐标称为"geohash 字符串". 

geohash 技术实现很大程度上保证两个 geohash 字符串<span style='color:blue'>公共前缀长度越长，两个区域距离就越接近，并且相对距离范围是可以通过公共前缀的长度估算出具体量级的</span>.
- 该性质只能做到 “**一定程度**上保证”
- 一些边界 case 中可能会出现两个位置本身距离很接近，但是 geohash 字符串的前缀却又差别很大的情况. 

将经纬度坐标(lng,lat) 转为一维 geohash 字符串的示例：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td>索引 index</td><td>点 point</td><td>经度 lng</td><td>纬度 lat</td></tr><tr><td>YJXY433V</td><td>A</td><td>101</td><td>77</td></tr><tr><td>Y8M76SJ6</td><td>B</td><td>120</td><td>47</td></tr><tr><td>K6BE10DN</td><td>C</td><td>12</td><td>-29</td></tr><tr><td>PBQE6KPD</td><td>D</td><td>178</td><td>-88</td></tr></tbody></table>


#### GeoHash 原理


将**球形**表面“展开”成了一张**矩形平面**，每个位置对应的(lnt,lat) 坐标都可以很方便的在矩形平面上进行定位.
- 沿着经度 -180/180° 的交接位置 “咔嚓”一刀将圆柱体的侧面纵向剪开，将其展开成一个矩形平面图
- 地球在纵向上由 -90°~90° 的纬度范围组成,在横向上由 -180°~180° 的经度范围组成. 因此我们把球面投影成一个矩形平面后，矩形的宽、高刻度就分别对应着经度和纬度，宽度方向上自左向右以 -180°为起点，180°为终点，每个刻度的单位为 1° 经度；高度自底向上以 -90°为起点，90°为终点，每个刻度单位为 1° 纬度.

|示意图|球面|平面|
|---|---|---|
||![](https://pic3.zhimg.com/80/v2-2a47c3c2974119aca084bc4d42043e6e_1440w.webp)|![](https://pic1.zhimg.com/80/v2-4cfd5b8992d3c39046d3faa80bd09064_1440w.webp)|

变换过程
- 沿着**经度**（矩形宽度）的方向进行递归二分，将一个具体经度拆解成一个由二进制数字组成的字符串.
  - 第一轮：经度范围为 -180°~180°，可以拆分成 -180°~0° 以及 0°~180° 两部分，如果经度从属于前者，则令首个 bit 位取 0，否则令首个 bit 位取 1；
  - 第二轮：-180°~0° 可以拆分为 -180°~-90° 和 -90°~0°，如果经度从属于前者，则令第二个 bit 位取 0，否则令第二个 bit 位取 1；0°~180° 可以拆分为 0°~90° 和 90°~180°，前者令第二个 bit 位取 0，后者令第二个 bit 位取 1
  - 第 3 ~ N 轮：重复上述步骤的思路，最终递归二分，将经度表示成一个由二进制数字组成的字符串
- 同样的流程可以应用在**纬度**（矩形高度）的递归二分当中，最终每个具体的纬度也可以被拆分成一个由二进制数字组成的字符串.
- 将沿经度方向的切分和沿纬度方向的切分**合并**在一起，于是整个矩形平面会被切割成网状，形成一个个小的矩形块.

每个矩形块经度区间，会对应有一个经度二进制字符串；同时根据纬度区间，也会有一个纬度二进制字符串. 化二维为一维的关键就是按照经度字符串+纬度字符串依次交错排列的形式，将其组织在一起，最终形成一个一维字符串.
- 这个一维字符串的位数越多，意味着对应的矩形块就越小；同时拥有相同前缀的小矩形块必然从属在同一个大矩形块的范围之内，比如下图左上方的 4 个小矩形：0101、0111、0100、0111 都拥有着公共前缀 "01"，因此，他们都从属于由 "01"表示的这个大矩形块当中.

一维字符串具有前缀索引的性质，他能够保证两个字符串前缀匹配位数越长，两个矩形块的相对位置就越靠近。
- ![示意图](https://pic2.zhimg.com/80/v2-08738864cf35255759b650304b80f395_1440w.webp)

|经度|纬度|合并|
|---|---|---|
|![](https://pic1.zhimg.com/80/v2-f49beb4f7d33b5063cffc7a54a3fef08_1440w.webp)|![](https://pic3.zhimg.com/80/v2-083900d3cd3f593ce896ca0685044b0e_1440w.webp)|![](https://pic4.zhimg.com/80/v2-1316f134d93b33d21d4a034e546d129b_1440w.webp)|


geohash 编码格式
- 为了进一步节省空间，geohash 采用 Base32 编码替代了原始的二进制字符串.
- Base32 编码主要是以 10 个数字字符 ‘0’-‘9’ 加上 26 个英文字母 ‘A’-‘Z’ 组成，并在其中把几个容易产生混淆的字符 'I' 'L' 'O' 以及字母 'A' 去掉了，最终总计保留下来 32 个字符

遵循 geohash 思路，将一个二进制字符串转为 Base32 编码形式的示例：
- ![](https://pic4.zhimg.com/80/v2-1ad764cbfae3103a3ca165bfb336c8ff_1440w.webp)

将地球表面上每个递归二分得到的小矩形块表示成 geohash 字符串的形式. 下图是通过 6 位 geohash 字符串，对北京西二旗附近区域进行切分表示的示例：
- ![](https://pic1.zhimg.com/80/v2-d9ffc0645f3ec66cdde09f2739922b28_1440w.webp)

**长度决定精度**

在 geohash 字符串中，字符串的长度决定了矩形块的大小，进一步决定了距离的精度. 在对经纬度进行递归二分时，每多一轮二分，矩形一个方向上的边长就会减半，因此矩形区域就越小，对应的精度就越高. 下面是 geohash 字符串长度和距离精度的映射关系：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td>geohash字符串长度（base32）</td><td>lat bits纬度二进制位数</td><td>lng bits经度二进制位数</td><td>lat error纬度方向长度（°）</td><td>lng error经度方向长度（°）</td><td>km error矩形边长（km）</td></tr><tr><td>1</td><td>2</td><td>3</td><td>±23</td><td>±23</td><td>±2500</td></tr><tr><td>2</td><td>5</td><td>5</td><td>±2.8</td><td>±5.6</td><td>±630</td></tr><tr><td>3</td><td>7</td><td>8</td><td>±0.70</td><td>±0.70</td><td>±78</td></tr><tr><td>4</td><td>10</td><td>10</td><td>±0.087</td><td>±0.18</td><td>±20</td></tr><tr><td>5</td><td>12</td><td>13</td><td>±0.022</td><td>±0.022</td><td>±2.4</td></tr><tr><td>6</td><td>15</td><td>15</td><td>±0.0027</td><td>±0.0055</td><td>±0.61</td></tr><tr><td>7</td><td>17</td><td>18</td><td>±0.00068</td><td>±0.00068</td><td>±0.076</td></tr><tr><td>8</td><td>20</td><td>20</td><td>±0.000085</td><td>±0.00017</td><td>±0.019</td></tr></tbody></table>

geohash 实现步骤
- 取得经纬度
  - 如经纬度信息：(116.311126,40.085003)
- 经度递归二分
  - 预期生成的 geohash 字符串长度为 6 位，则对应的经度和纬度二进制字符串的 bit 位长度需要为 15 位. 最终取得的 geohash 字符串所对应的矩形块边长范围约为 610 m.
  - 最终，递归二分得到经度方向上的二进制字符串为 110100101011010，长度为 15 位.
- 纬度递归二分： 对经度 40.085003 进行二分，首轮从 -90°~90°的范围开始
  - 最终，递归二分得到纬度方向上的二进制字符串为 101110010000001，长度为 15 位.
- 经纬度字符串拼接
  - 结合经度字符串 110100101011010 和纬度字符串 101110010000001，我们遵循先经度后纬度的顺序，逐一交错排列，最终得到的一维字符串为 11100 11101 00100 11000 10100 01001.
  - ![](https://pic3.zhimg.com/80/v2-57d0f241933ee63175c03c431a29f50e_1440w.webp)
- Base32编码
  - 一维二进制字符串 11100 11101 00100 11000 10100 01001 的基础上，我们从左往后，以每 5 个 bit 成一组，转为 Base32 编码的表达形式，最终得到的编码结果为 WX4SN9
  - ![](https://pic1.zhimg.com/80/v2-4a50c91bc1e82ce5ec4b5589af026ec4_1440w.webp)


#### geohash 具体实现

geohash 
- 转换
  - ![](https://pic2.zhimg.com/80/v2-66fb7497cf630241cbcb4dcbd011afb5_1440w.webp)
- 查询
  - ![](https://pic3.zhimg.com/80/v2-c662d8aa82cb45762bc6453735b47ef6_1440w.webp)
- 添加
  - ![](https://pic1.zhimg.com/80/v2-4571fdba68cf186472a82d0b285c8250_1440w.webp)
- 前缀查询
  - ![](https://pic4.zhimg.com/80/v2-ca4712cf466ac9e65b29e78738bfa317_1440w.webp)
- 删除
  - ![](https://pic1.zhimg.com/80/v2-487cf51a237a793325d63a202e085f9c_1440w.webp)
- 范围查询
  - ![](https://pic2.zhimg.com/80/v2-5301cd681bfe8308816ea78c245a0ead_1440w.webp)

go 源码见[原文](https://zhuanlan.zhihu.com/p/645078866)

geohash 与 trie
- 首先要对 geohash 字符串的存储数据结构进行选型.

geohash 服务模块需要对外提供的几个 API 整理如下：
- Hash：将用户输入的经纬度 lng、lat 转为 geohash 字符串
- Get：通过传入的 geohash 字符串，获取到对应于矩形区域块的 GEOEntry 实例
- Add：通过用户传入的经纬度 lng、lat，构造出 point 实例并添加到对应的矩形区域中
- ListByPrefix：通过用户输入的 geohash 字符串，获取到对应矩形区域块内所有子矩形区域块的 GEOEntry 实例（包含本身）
- Rem：通过用户输入的 geohash 字符串，删除对应矩形区域块的 GEOEntry
- ListByRadiusM：通过用户输入的中心点 lng、lat，以及对应的距离范围 radius，返回范围内所有的点集合

#### geohash 问题


(1) **边缘性局限**问题

- 将矩形平面通过递归二分的方式，切分成一个个小的矩形块，而每个矩形块有着自己与毗邻矩形块的交界区域，倘若有两个点分别从属于两个毗邻矩形块，但是又同时靠近于它们的交界线，此时就会出现两个点实际距离接近，但前缀匹配长度不足的情况.
- ![](https://pic1.zhimg.com/80/v2-b2aa459166b4d4fd4fa5d5c65d087f50_1440w.webp)
- A、B 两个点同属于一个矩形块中，有着更长的公共前缀；C、D、E 三个点和 A 不从属于同一个矩形块，与A 的 geohash 字符串前缀匹配长度相较于 B 而言要更短，然而其本身和 A 的相对距离却是要更接近的.

为了避免在近距离位置检索过程中出现目标的遗漏，通常会在通过 geohash 锁定一个小的矩形块后，以其作为中心，将周围 8 个矩形块范围内的点也同时检索出来，再根据实际的相对距离进行过滤.

(2) 最短距离问题

找到距离点 A 最近的目标点. 以 A 所在矩形为中心，基于“回”字形的拓扑结构向外逐层向外拓宽，此时我们是无法保证靠内侧的“回”字形层次中出现的目标点一定比外层的点距离点 A 更近.

比如以下图为例，点 F 相比于点 G ，在层次上与点 A 更加靠近，但是实际上与点 A 的相对距离要长于点 G.
- ![](https://pic4.zhimg.com/80/v2-e4b6e8e1a16a14887848fb324f262ef3_1440w.webp)

为了解决这个问题，遇到首个目标点后，额外向外扩展几圈，直到保证扩展范围边界与点 A 的相对距离已经长于首个目标点后才能停止扩展流程. 接下来需要取出扩展范围内所有的点，分别计算出与点 A 的相对距离，最终取出距离最小的那个点，即为我们所求的结果.

(3) 范围检索思路

应用 geohash 技术的一类场景是：
> 给定一个指定位置作为中心点，想要检索出指定半径范围内的所有点集合.

解决思路
- 首先求出中点所在的矩形块及其对应的 geohash 字符串
- 然后基于回字形向外逐层拓宽，直到能保证拓展范围一定能完全包含以中心点为圆心、指定距离为半径的圆后，求出拓展范围内所有的点（此时可能有多余的结果），再通过其与中心点的相对距离进行过滤，保留满足条件的目标点集合.
  - ![](https://pic3.zhimg.com/80/v2-a2367bce85a3042881be976781a9e612_1440w.webp)


## 定位


### 卫星导航系统

《日本经济新闻》2020年8月20日报道，美国长期以来一直是全球卫星定位系统的领导者，但现在，中国的北斗卫星导航系统在规模上已经超过美国的GPS。
- [中国北斗与美国GPS差距有多大？核心数据曝光，日媒惊叹](https://zhuanlan.zhihu.com/p/79153773)

全球4大卫星导航系统对比

| 系统 | GPS | 北斗 | GLONASS | Galileo |
|---|---|---|---|---|
| 研制国家 | 美国 | 中国 | 俄罗斯 | 欧盟 |
| 首颗卫星升空时间 | 1985年 | 1989年 | 2000年 | 2011年 |
| 卫星总数 | 43颗 | 38颗 | 24颗 | 30颗 |
| 应用时间 | 1994年 | 2000年北斗一号、2012年北斗二号、2020年北斗三号 | 2016年（早期工作能力) | 2007年（服务俄罗斯)、2009年(服务全球) |
| 竞争优势 | 成熟 | 开放且具备短信通信功能 | 抗干扰能力强 | 精度高 |
| 后期发展 | 预计于2033年部署完成由GPS三代卫星组成的空间星座，届时定位精度可达：水平2.1m、高程3.2m | 预计于2020年完成全球覆盖，届时定位精度最高可达2.5m | 计划于2025年前将其更新为GLONASS-K，系统届时定位精度可达3m | 预计于2019年建成，届时将具备完全工作能力，最高精度可达1m以内 |

GPS仅向地面发送信号，难以锁定接收信号的终端的位置信息，但北斗还有一点优势，它具备收发信号的功能。

美国曾借助GPS在全球定位服务领域先行一步，而中国正一步步夺取美国的地位。可以清晰地看到，在卫星领域中国已开始反超美国。

卫星导航定位行业按照定位精度差别可区分为两大服务群体：
- 一是**高精度GNSS**行业（常规使用的定位误差在**米级**以下），应用在测绘勘探、地理信息、地质灾害监测、精细农林业、国防、时间同步等领域
- 二是**消费类**行业（常规使用的定位误差在1米至**10米**以上），例如手机导航、车载导航等。近年来，随着大数据、物联网特别是无人驾驶等新兴技术的不断进步，用定位精度来区分服务群体的界限已逐渐模糊。例如高精度定位在无人驾驶技术中占据了极为重要的位置，而无人驾驶显然未来的属性为消费类。

北斗将在自动驾驶领域大放异彩，北斗高精度芯片将作为新车的标配，为自动驾驶提供亚米级甚至厘米级定位服务，而相关的北斗高精度服务也将迎来最大的客户需求。


### GPS

待定

### 北斗

#### 哪些手机支持北斗

中科院官方科普平台“科学大院”介绍，北斗信号的获取主要取决于**手机处理器**（SOC）中集成的**定位芯片**，目前大多SOC都能同时支持`GPS`、`北斗`和`GlONASS`：
- 高通骁龙800、600、400系列，其中目前常见的820、821、835高端型号是支持北斗的，中低端的652、650、625、436，甚至更老的一些型号也都是支持。
- 联发科类似，目前常见的P10、P15、P20、X20，之前的X10都支持接收北斗信号。
- 华为海思很早就支持了北斗。从麒麟930开始，集成的Hi1101四合一芯片可以同时接收GPS、北斗和GLonass三种信号。
- 也就是说，除了任性的苹果，采用这些SOC的华为、O&V、小米、一加、魅族、HTC、努比亚等品牌的大部分型号手机都支持北斗定位

#### 如何切换北斗

测试软件试试，比如“GPS状态”、“北斗伴”、“AndroiTS GPS Test Pro”等等，以AndroiTS GPS Test Pro为例：找个户外开阔的地方，打开手机的“位置服务”，然后运行[AndroiTS GPS Test Pro](http://www.danji100.com/app/139506.html)软件，效果如下：
- ![](https://pic3.zhimg.com/80/v2-d66172d2edc6a3d7a6cdd12a8463c682_720w.jpg)
- 1、在手机桌面点击打开“应用市场”。
- 2、点击搜索“AndroiTS GPS Test Pro”软件下载安装到手机。
- 3、点击“设置”。
- 4、点击列表中“定位服务”。
- 5、将右侧滑动按钮开启。
- 6、AndroiTS GPS Test Pro软件，点击最下方第三个图标，就是我国的北斗导航卫星系统。


手机导航，其实是北斗进入比较晚的行业了。现任中国卫星导航系统管理办公室主任、北斗系统新闻发言人冉承其曾给出一组数据：过去5年，我国480万辆营运车辆上线“北斗”，建成全球最大的北斗车联网平台，全国4万余艘渔船安装“北斗”。他以北京为例，已有33500辆出租车、21000辆公交车安装“北斗”，实现“北斗”定位全覆盖；1500辆物流货车及19000名配送员，使用“北斗”终端和手环接入物流云平台，实现实时调度。


# 结束
















