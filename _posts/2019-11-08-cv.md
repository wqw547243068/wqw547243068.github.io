---
layout: post
title:  "计算机视觉-Computer Vision"
date:   2019-11-08 16:52:00
categories: 计算机视觉
tags: 深度学习 计算机视觉 GAN 扫地机器人 自动驾驶 何恺明 CVPR 论文 sota OCR ocr opencv 数字图像 滤波 三维 水印 ffmpeg 视频 婴儿 插件 chrome
excerpt: 图像风格迁移是什么原理？具体如何实施？可以迁移到文本吗？
mathjax: true
permalink: /cv
---

* content
{:toc}


# 说明

- 【2022-8-25】生成人脸：[this-person-does-not-exist.com](https://this-person-does-not-exist.com/en)
- 【2022-8-23】[国产AI作画神器火了，更懂中文，竟然还能做周边](https://mp.weixin.qq.com/s/xh6Q0Pnv9OfP8Je3lDiyZg), “一句话生成画作”这个圈子里，又一个AI工具悄然火起来了,不是你以为的Disco Diffusion、DALL·E，再或者Imagen……而是全圈子都在讲中国话的那种, 文心·一格
  - 操作界面上，Disco Diffusion开放的接口不能说很复杂，但确实有点门槛。它直接在谷歌Colab上运行，需要申请账号后使用（图片生成后保存在云盘），图像分辨率、尺寸需要手动输入，此外还有一些模型上的设置。好处是可更改的参数更多，对于高端玩家来说可操作性更强，只是比较适合专门研究AI算法的人群;相比之下，文心·一格的操作只需三个步骤：输入文字，鼠标选择风格&尺寸，点击生成。
  - 提示词，Disco Diffusion的设置还要更麻烦一些。除了描述画面的内容以外，包括画作类别和参考的艺术家风格也都得用提示词来设置，通常大伙儿会在其他文档中编辑好，再直接粘过来。相比之下文心·一格倒是没有格式要求，输入150字的句子或词组都可以
  - 性能要求上，Disco Diffusion是有GPU使用限制的，每天只能免费跑3小时。抱抱脸（HuggingFace）上部分AI文生图算法的Demo虽然操作简单些，但一旦网速不行，就容易加载不出来; 文心·一格除了使用高峰期以外，基本上都是2分钟就能生成，对使用设备也没有要求。
  - 总体来看，同样是文字生成图片AI，实际相比文心·一格的“真·一句话生成图片”，DALL·E和Disco Diffusion的生成过程都不太轻松。
- 【2022-7-11】AI工具：[解你描述的东西还可以画出来的AI，真就全靠想象](https://www.ixigua.com/7117201327523892488?wid_try=1)
  - 一、[DALL•E2](https://openai.com/dall-e-2/)：openai出品，理解并画出你描述的所有东西，如：一直粉红色大象在撒哈拉沙漠玩扑克
  - 二、[AI智能图片放大](https://bigjpg.com/zh)：还原马赛克图片，就连表情包也能高清重置
  - 三、线稿自动上色：[Style2paints](http://paintstransfer.com/), [GitHub 链接](https://github.com/lllyasviel/style2paints)
    - 用 AI 技术为黑白线稿快速自动上色。在最近推出的 2.0 版中，研究人员使用了完全无监督的生成对抗网络（GAN）训练方法大幅提高了上色的准确性。Style2paints 的作者表示，该工具在精细度、漫画风格转换等方面超越了目前其他所有工具。
- 【2021-11-22】image2text的反向：text2image，NVIDIA Demo; 用深度学习模型(GauGAN)可以将文本转换成图片, demo，[GauGAN AI Art Demo](http://gaugan.org/gaugan2)，只要输入一句简短的描述就可以生成图片了。下图是他们演示的“海浪击打岩石”的效果。
  - [The absurd beauty of hacking Nvidia's GauGAN 2 AI image machine](https://www.zdnet.com/article/the-absurd-beauty-of-hacking-nvidias-gaugan-2-ai-image-machine/)
  - ![](https://p6.toutiaoimg.com/img/tos-cn-i-qvj2lq49k0/50832d2763094d32ab1c2e974d7a625a~tplv-obj:480:272.gif)
- 汇总计算机视觉的应用案例
- 【2021-3-26】[视频大脑：视频内容理解的技术详解和应用](https://www.infoq.cn/article/vhIXoD0CAqmojPHeKP5f/)，[极客时间视频](https://time.geekbang.org/dailylesson/detail/100022917),黄君实 奇虎360 人工智能研究院资深研发科学家
  - ![](https://static001.infoq.cn/resource/image/46/6a/46ccd482ad8a09752bca0a184aaca56a.png)

## sota

【2021-6-22】[CVPR 2021大奖公布！何恺明获最佳论文提名，代码已开源](https://mp.weixin.qq.com/s/sdboE0KmvCV-Zc2R6hs0Tg)

推特上，有学者打趣说，CV论文可以分为这几类：
- 「只想混文凭」
- 「教电脑生成更多猫的照片」
- 「ImageNet上实验结果提升0.1%！」
- 「手握超酷数据集但并不打算公开」
- 「3年过去了，代码仍在赶来的路上」
- 「实验证明还是老baseline性能更牛」
- 「我们的数据集更大！」
- 「研究范围超广，无他，我们有钱」
- 「花钱多，结果好」......

何恺明和Xinlei Chen的论文Exploring Simple Siamese Representation Learning（探索简单的连体表征学习）获得了最佳论文提名。

「连体网络」（Siamese networks）已经成为最近各种无监督视觉表征学习模型中的一种常见结构。这些模型最大限度地提高了一个图像的两个增量之间的相似性，但必须符合某些条件以避免collapse的解决方案。在本文中，我们报告了令人惊讶的经验结果，即简单的连体网络即使不使用以下任何一种情况也能学习有意义的表征。(i) 负样本对，(ii) 大batch，(iii) 动量编码器。我们的实验表明，对于损失和结构来说，collapse的解决方案确实存在，但stop-gradient操作在防止collapse方面发挥了重要作用。我们提供了一个关于stop-gradient含义的假设，并进一步展示了验证该假设的概念验证实验。我们的 「SimSiam 」方法在ImageNet和下游任务中取得了有竞争力的结果。我们希望这个简单的基线能促使人们重新思考连体结构在无监督表征学习中的作用。

代码已开源 https://github.com/facebookresearch/simsiam


## 何恺明

### 何恺明成就

在CV领域所做的工作，涵盖ResNet、Faster RCNN、Mask RCNN、MoCO和MAE。
- 【2023-3-14】何恺明回归[学界](https://www.toutiao.com/article/7210257484534137379)，进入MIT，成为MIT被引次数最高的人。
- MIT全校被引用次数最高的，是化学与生物医学工程系的重量级教授Robert Langer，次数为38万+。而何恺明被引用次数高达40万+。

何恺明
- 最出圈的研究非ResNet莫属，在2021年底突破10万大关，如今已经涨到15万。
- 主要贡献还包括Faster R-CNN及后续的Mask R-CNN等一系列研究，在很多年都是目标检测的主流方法。
- 近期主要研究兴趣是无监督学习，21年底提出的MAE，将语言模型的掩码预训练方法用在视觉模型上，为视觉大规模无监督预训练大模型开路。最近他还将掩码方法引入众多AI绘画应用的基础模型CLIP，把训练速度提升了3.7倍。

### 何恺明履历

何恺明编年史

![](https://pic1.zhimg.com/v2-5e022845e2440e673f98a11f99ac6dac_1440w.jpg?source=172ae18b)
- [何恺明：从高考状元到CV领域年轻翘楚，靠“去雾算法”成为“CVPR最佳论文”首位华人得主](https://zhuanlan.zhihu.com/p/55621213)

何恺明履历
- 出生于广州的何恺明是家中独子，父母均在企业里从事管理工作，从小就接触到优良的教学环境。实际上，能从众多学子中脱颖而出，除了教学环境之外，更多的是靠自己的努力。
- 何恺明年少时就被送到少年宫学习绘画，有时一待就是大半天，这也不断使他练就出沉稳的性格。同绘画一样，他对于文化课的钻研也十分耐得住性子，学习成绩优秀而且稳定。在老师的心目中，他是一个“性格比较内向”但是“目标明确”的学生，“从小就立志上清华”。
- 高中时，全国物理竞赛一等奖被保送进清华大学机械工程及其自动化专业，不去，偏要考，结果成了2003年广东理科状元；
- 大学期间，何恺明继续着自己沉稳而优秀的表现，不仅连续3年获得清华奖学金，2007年，还未毕业的他就进入了微软亚洲研究院（MSRA）实习。
- 本科毕业后，他进入香港中文大学攻读研究生，师从AI名人汤晓鸥；
- 2009年，第一篇论文“Single ImageHaze Removalusing Dark Channel Prior”被计算机视觉领域顶级会议CVPR接收并被评为年度最佳论文，CVPR创办25年来华人学者第一次获此殊荣，也使何恺明在CV领域声名鹊起
- 2011年，博士毕业的何恺明正式加入MSRA计算机视觉和深度学习的研究工作。
- 2015年的ImageNet图像识别大赛中，何恺明和他的团队凭借152层深度残差网络ResNet-152，击败谷歌、英特尔、高通等业界团队，荣获第一。目前ResNets也已经成为计算机视觉领域的流行架构，同时也被用于机器翻译、语音合成、语音识别和AlphaGo的研发上。
- 2016年，何恺明凭借ResNets论文再次获得CVPR最佳论文奖，也是目前少有的一人两次获得CVPR最佳论文奖的学者。
- 后来，何恺明和孙剑相继离开MSRA。与孙剑的选择不同，何凯明走得还是那条学院路。他选择了去Facebook，担任其人工智能实验室研究科学家，选择了进一步走学术之路。
- 2017年3月，何恺明和同事公布了其最新的研究Mask R-CNN，提出了一个概念上简单、灵活和通用的用于目标实例分割（object instance segmentation）框架，能够有效地检测图像中的目标，同时还能为每个实例生成一个高质量的分割掩码。同年，凭借《利用焦点损失提升物体检测效果》这篇论文，他一举夺下了另一个计算机视觉顶级会议ICCV最佳论文奖。
- 2018年，何恺明在美国盐湖城召开的CVPR上，获得了PAMI青年研究者奖。几个月前，何恺明等人发表论文称，ImageNet预训练却并非必须。何恺明和其同事使用随机初始化的模型，不借助外部数据就取得了不逊于COCO 2017冠军的结果，再次引发业内关注。

【2022-1-12】[何恺明编年史](https://zhuanlan.zhihu.com/p/415353143)

别人的荣誉都是在某某大厂工作，拿过什么大奖，而何恺明的荣誉是best，best，best ...... kaiming科研嗅觉顶级，每次都能精准的踩在最关键的问题上，提出的方法简洁明了，同时又蕴含着深刻的思考，文章赏心悦目，实验详尽扎实，工作质量说明一切。

何恺明的研究兴趣大致分成这么几个阶段：
- 传统视觉时代：Haze Removal(3篇)、Image Completion(2篇)、Image Warping(3篇)、Binary Encoding(6篇)
- 深度学习时代：Neural Architecture(11篇)、Object Detection(7篇)、Semantic Segmentation(11篇)、Video Understanding(4篇)、Self-Supervised(8篇)

代表作
- 2009 CVPR best paper Single Image Haze Removal Using Dark Channel Prior
  - 利用实验观察到的暗通道先验，巧妙的构造了图像**去雾算法**。现在主流的图像去雾算法还是在Dark Channel Prior的基础上做的改进。
- 2016 CVPR best paper Deep Residual Learning for Image Recognition
  - 通过**残差连接**，可以训练非常深的卷积神经网络。不管是之前的CNN，还是最近的ViT、MLP-Mixer架构，仍然摆脱不了残差连接的影响。
- 2017 ICCV best paper **Mask R-CNN**
  - 在Faster R-CNN的基础上，增加一个实例分割分支，并且将RoI Pooling替换成了RoI Align，使得实例分割精度大幅度提升。虽然最新的实例分割算法层出不穷，但是精度上依然难以超越Mask R-CNN。
  - ![](https://pic1.zhimg.com/80/v2-55b2b7227b553659dd7deea52082bef4_720w.jpg)
- 2017 ICCV best student paper Focal Loss for Dense Object Detection
  - 构建了一个**One-Stage**检测器RetinaNet，同时提出Focal Loss来处理One-Stage的类别不均衡问题，在目标检测任务上首次One-Stage检测器的速度和精度都优于Two-Stage检测器。近些年的One-Stage检测器(如FCOS、ATSS)，仍然以RetinaNet为基础进行改进。
  - ![](https://pic3.zhimg.com/80/v2-7628af32f42bc07197bdc27bc02f9d52_720w.jpg)
- 2020 CVPR Best Paper Nominee Momentum Contrast for Unsupervised Visual Representation Learning
  - 19年末，NLP领域的Transformer进一步应用于Unsupervised representation learning，产生后来影响深远的BERT和GPT系列模型，反观CV领域，ImageNet刷到饱和，似乎遇到了怎么也跨不过的屏障。就在CV领域停滞不前的时候，Kaiming He带着**MoCo**横空出世，横扫了包括PASCAL VOC和COCO在内的7大数据集，至此，CV拉开了Self-Supervised研究新篇章。


# 计算机视觉


## 人如何接收环境信息

[视觉、听觉、嗅觉、味觉和触觉：人体如何接收感觉信息](https://www.visiblebody.com/zh/learn/nervous/five-senses)
 
![五感示意图](https://www.visiblebody.com/hubfs/learn/assets/zh/nervous/2020-The%20Senses%20Chinese.jpg "五感示意图")

**神经系统**必须接收和处理**外界信息**以作出反应、进行通信并确保身体的健康与安全。
- 这些信息大部分来自感觉器官：`眼睛`、`耳朵`、`鼻子`、`舌头`和`皮肤`。
- 这些器官中的细胞和组织会接收原始刺激，并将其转化为神经系统可以使用的**信号**。神经将信号传递到大脑，大脑将其解释为**影像**（视觉）、**声音**（听觉）、**气味**（嗅觉）、**味道**（味觉）和**触感**（触觉）。

大脑必须依靠感觉器官来收集感觉讯息。相关的五种感觉器官是：
- 耳朵（听觉）
- 皮肤及毛发（触觉）
- 眼睛（视觉）
- 舌头（味觉）
- 鼻子（嗅觉

![](https://askthescientists.com/wp-content/uploads/2019/06/AdobeStock_244914939.jpg)
 
视觉系统的出现和不断完善迫使不同物种间的竞争加剧，进而极大地缩短了它们的进化时间，最终导致了大爆炸现象的出现。
- ![](https://pic2.zhimg.com/80/v2-f277f98264ec8adee3a4565446382299_1440w.webp)

### 婴儿如何学习

【2024-2-4】Nature，纽约大学最新研究：给婴儿戴上摄像头，让神经网络自主学习，像婴儿一样感知环境，学习语言
- [This AI learnt language by seeing the world through a baby’s eyes](https://www.nature.com/articles/d41586-024-00288-1?share_token=ae24e9e4-d845-4095-b1c1-78bc2e76727c)

婴儿视角
- Vong 和同事通过一个男婴头盔上的摄像机进行 61 小时记录，从婴儿的角度收集信息。
- Sam 住在澳大利亚阿德莱德附近，从六个月大到两岁左右，每周两次佩戴相机，每次每次一小时左右（大约是他清醒时间的 1%）。

研究人员根据视频中的帧以及从录音中转录出来的对山姆说的话训练神经网络（一种受大脑结构启发的人工智能）。该模型接触了 250,000 个单词和相应的图像，这些图像是在玩耍、阅读和吃饭等活动中捕获的。
- 该模型使用了**对比学习**技术了解哪些图像和文本倾向于结合在一起，哪些不结合在一起，从而建立可用于预测某些单词（例如“球”和“碗”）所指的图像的信息。


### 1. 眼睛将光线转化为供大脑处理的图像信号

![眼睛横截面示意图](https://www.visiblebody.com/hubfs/learn/assets/zh/nervous/2020-The%20Eye%20Chinese.jpg "眼睛横截面示意图")
 
眼睛位于头骨的眼眶中，受到骨骼和脂肪的保护。眼睛的白色部分是**巩膜**。它保护内部结构，包围着角膜、虹膜和瞳孔形成的圆形入口。角膜是透明的，允许光线进入眼睛，并发生弯曲来引导光线进入其后的瞳孔。瞳孔实际上是虹膜有色圆盘中的开孔。虹膜扩张或收缩，调节有多少光线通过瞳孔并进入晶状体。接下来，弯曲的晶状体将图像会在视网膜（眼的内层）上聚焦。视网膜是一层精细的神经组织膜，包含了感光细胞。这些视杆细胞和视锥细胞将光转化为神经信号。视神经将信号从眼睛传递到脑部，由脑将其解释为视觉图像。
 
### 2. 耳朵使用听小骨和液体将声波转换为声音信号
 
![单击查看描述听觉如何进行的动画描述](https://www.visiblebody.com/hubfs/Learn_Articles/Nervous_System/Hearing-Clip-Cover.jpg)
 
音乐、笑声、汽车鸣笛—都作为空气中的声波传入耳朵。外耳将声波沿着耳道（外耳道）汇聚到鼓膜（“耳鼓”）。声波敲击鼓膜，在膜中产生机械振动。鼓膜将这些振动传递到三块被称为听小骨的微小骨骼，可在充满空气的中耳腔室内看到它们。这些骨骼（锤骨、砧骨和镫骨）承载振动并敲击内耳的开口。内耳由充满液体的管道组成，包括螺旋形的耳蜗。随着听小骨的撞击，耳蜗中的特殊毛细胞会检测到液体中的压力波。它们激活神经感受器，通过蜗神经向脑发送信号，后者将信号解释为声音。
 
### 3. 皮肤中的特殊感受器向大脑发送触觉信号
 
![显示出触觉感受器的皮肤截面图](https://www.visiblebody.com/hubfs/learn/assets/zh/nervous/2020-Touch%20Receptors%20Chinese.jpg "显示出触觉感受器的皮肤截面图")
 
皮肤由三个主要组织层构成：外层表皮、中层真皮和内层皮下组织。

这些组织层中专门的感受器细胞检测触觉，并通过周围神经向脑部传递信号。不同类型感受器的存在和位置使特定身体部位更加敏感。嘴唇、手和外生殖器官下表皮可见Merkel细胞。迈斯纳小体可见于无毛发皮肤的上真皮层内—指甲、乳头、嘴唇、足底、阴蒂、龟头和舌尖。这两种感受器都可以检测到触摸、压力和振动。其他触觉感受器还包括环层小体，它也能记录压力和振动。还有能感受到疼痛、瘙痒和刺痒的特异性神经自由末梢。
 
### 4. 嗅觉：空气中的化学物质刺激发出被大脑解释为气味的信号。
 
![单击查看描述嗅觉如何进行的动画描述](https://www.visiblebody.com/hubfs/Learn_Articles/Nervous_System/Olfaction-Clip-Cover.jpg)
 
气味的感觉被称为嗅觉。它开始于鼻腔的顶部上皮中的毛状纤毛上的感受器。当我们用鼻子嗅和吸气时，一些空气中的化学物质会与感受器结合。这会触发一个顺着神经纤维向上传递的信号，穿过上皮和上方的颅骨到达嗅球。嗅球包含神经元细胞体，其将信号顺着延伸至嗅球的颅神经传递。然后将信号朝着大脑皮层的嗅觉区域向下传递到嗅神经。
 
### 5. 味蕾的载体：舌头是味觉的主要器官

舌头的四块内在肌协同工作，使舌头具有很大的灵活性。
- ![舌头和味蕾示意图](https://www.visiblebody.com/hubfs/learn/assets/zh/nervous/2020-Tongue%20and%20Taste%20Buds%20Chinese.jpg "舌头和味蕾示意图")
 
舌头上的那些小疙瘩是什么？它们叫做舌乳头。它们中包括轮廓乳头和菌状乳头在内的多数都包含味蕾。当我们进食时，食物中的化学物质会进入舌乳头并到达味蕾。这些化学物质（或促味剂）刺激味蕾内部特殊的味觉细胞，激活神经感受器。感受器将信号发送至面神经、舌咽神经和迷走神经的神经纤维。这些神经将信号传递到延髓，延髓将信号传递到脑部的丘脑和大脑皮层。

## 什么是计算机视觉

相对于生物视觉系统漫长的进化历程，计算机视觉显然是“非常年轻而且稚嫩”的，因为人们是从20世纪50年代才开始尝试赋予计算机系统这一重要的感知能力。而且，这个学科的涉及面比较宽泛，它不仅依赖于计算机科学知识，同时还涉及生物学、数学、神经科学等多个领域
- ![cv_history](https://github.com/HusterHope/blogimage/raw/master/CS231n1-2.png)

What is computer vision?
- Computer vision is the field of computer science that focuses on creating **digital systems** that can process, analyze, and make sense of visual data (images or videos) in the same way that humans do. The concept of computer vision is based on teaching computers to process an image at a pixel level and understand it. Technically, machines attempt to retrieve visual information, handle it, and interpret results through special software algorithms.
- 向人脑一样处理、分析、感知视觉数据（图像/视频）的数字系统 [img](https://xd.adobe.com/ideas/wp-content/uploads/2020/07/what-is-computer-vision-how-does-it-work-1.png.webp)
- ![](https://xd.adobe.com/ideas/wp-content/uploads/2020/07/what-is-computer-vision-how-does-it-work-1.png.webp)

CMU ppt：[主页](http://www.cs.cmu.edu/~16385/)，[介绍](http://www.cs.cmu.edu/~16385/lectures/lecture1.pptx)
- The goal of computer vision is to give computers (super) human-level perception
- typical perception pipeline: representation --> fancy math(black box) --> output
  - representation: what should we look at? (image features)
  - fancy math: easy to get lost in the techniques
  - output: what can we understand? (semantic segmentation)
  - The parts that we are most interested in: representation & output
- Important note: 
  - <span style='color:red'>In general, computer vision does not work</span>, <span style='color:green'>except in certain situations/conditions</span>
  - 当前的计算机视觉方案行不通（暂无解法），但特定领域下可行
- 朱松纯[观点](2017/11/02/ai-talk/#%E7%AC%AC%E4%B8%80%E8%8A%82-%E7%8E%B0%E7%8A%B6%E8%AF%84%E4%BC%B0%E6%AD%A3%E8%A7%86%E7%8E%B0%E5%AE%9E)
  - 现在的人工智能和机器人，关键问题是缺乏物理的常识和社会的常识“Common sense”。 这是人工智能研究最大的障碍。
  - 我们要寻找“乌鸦”模式的智能，而不要“鹦鹉”模式的智能
  - ![](http://5b0988e595225.cdn.sohucs.com/images/20180410/d345e1d8d05d4c068688fe634db49736.jpeg)

Here are a few common tasks that computer vision systems can be used for:
- `Object classification`. The system parses visual content and classifies the object on a photo/video to the defined category. For example, the system can find a dog among all objects in the image.
- `Object identification`. The system parses visual content and identifies a particular object on a photo/video. For example, the system can find a specific dog among the dogs in the image.
- `Object tracking`. The system processes video finds the object (or objects) that match search criteria and track its movement.

- ![image](https://xd.adobe.com/ideas/wp-content/uploads/2020/07/what-is-computer-vision-how-does-it-work-2.png.webp)
- ![video](https://lh5.googleusercontent.com/23ABhlO-DZ-8f2LGZ7mmu0VWASGDp9qRLp0efXiIqCmJL5BdAVBUWWy9UzcKWC701XB4s4XDMCtud7ZoRWE_I1D_hGyyk6OadSlqrP9Y-IA-HyRfKcQGwf1FNXj_DTvPmi0X0FUGeM09bc7E_OALgG7iR12W3pXsRLy-fLC4IJFa6_DCX0CBl81ncyFFfw)


### CV 与 CG

计算机视觉（CV）和计算机图形学（CG）该如何区别？
- 计算机视觉输入的是**图像**或**视频**，输出的是对画面内容的**理解**，也就是对世界的理解。
- 而计算机图形学输入的是对**虚拟**场景的描述，输出的则是**图像**。

随着两者的共同进步，无论是算法还是解决问题的思路上都互有借鉴，不过基础的分界仍未改变。

## 发展史

计算机视觉是深度学习领域**最热门**的研究领域之一，目前在各领域应用广泛，而它是如何发展至今，一起回顾一下计算机视觉的发展史。
- [计算机视觉发展史](https://zhuanlan.zhihu.com/p/142927311), [2](https://zhuanlan.zhihu.com/p/378538460)
- [李飞飞：计算机视觉的发展历史](https://leohope.com/%E5%81%9A%E7%AC%94%E8%AE%B0/2017/08/19/CS231n-1/)


自从20世纪中期开始，计算机视觉不断发展，研究经历了从**二维图像**到**三维**到**视频**到**真实空间**的探知，操作方法从**构建三维**向**特征识别**转变，算法从**浅层神经网络**到**深度学习**，数据的重要性逐渐被认知，伴随着计算机从理论到应用的速度加快，高质量的各种视觉数据不断沉淀，相信无论在社会经济农业还是工业领域，还是视频直播、游戏、电商不断发展，一定还会有更多好玩炫酷的计算机视觉应用出现在我们身边。

### 四个阶段

计算机视觉经历了4个主要历程。
- [中国科学院自动化研究所胡占义研究员撰写的《计算机视觉简介：历史、现状和发展趋势》](https://www.yanxishe.com/blogDetail/15432)
- 马尔计算视觉、主动和目的视觉、多视几何与分层三维重建和基于学习的视觉。

#### 马尔计算视觉（Computational Vision）

马尔计算视觉理论包含两个主要观点：
- 首先，人类视觉的主要功能是复原三维场景的可见几何表面，即三维重建问题；
- 其次，马尔认为这种从二维图像到三维几何结构的复原过程是可以通过计算完成的，并提出了一套完整的计算理论和方法。

所以，马尔视觉计算理论在一些文献中也被称为**三维重建**理论。

马尔认为，从二维图像复原物体的三维结构，涉及三个不同的层次。
- 首先是计算理论层次，也就是说，需要使用何种类型的约束来完成这一过程。马尔认为合理的约束是场景固有的性质在成像过程中对图像形成的约束。
- 其次是表达和算法层次，也就是说如何来具体计算。
- 最后是实现层次。马尔对表达和算法层次进行了详细讨论。

他认为从二维图像恢复三维物体，经历了三个主要步骤，即: 图像初始略图（sketch）—> 物体2.5维描述 —> 物体3维描述
- 其中，初始略图是指高斯拉普拉斯滤波图像中的过零点（zero-crossing）、短线段、端点等基元特征。
- 物体2.5维描述是指在观测者坐标系下对物体形状的一些粗略描述，如物体的法向量等。
- 物体3维描述是指在物体自身坐标系下对物体的描述，如球体以球心为坐标原点的表述。

马尔视觉计算理论是上世纪八十年代初提出的，之后三十多年的研究中，人们发现马尔理论的基本假设："人类视觉的主要功能是复原三维场景的可见几何表面"——基本上是不正确的，"物体识别中的三维表达的假设"——也基本与人类物体识别的神经生理机理不相符。尽管如此，马尔计算视觉理论在计算机视觉领域的影响是深远的，他所提出的层次化三维重建框架，至今是计算机视觉中的主流方法。尽管文献中很多人对马尔理论提出了质疑、批评和改进，但就目前的研究状况看，还没有任何一种理论可以取代马尔理论，或与其相提并论。

#### 昙花一现的主动和目的视觉

很多人介绍计算机视觉时，将这部分内容不作为一个单独部分加以介绍，主要是因为“主动视觉和目的视觉”并没有对计算机视觉后续研究形成持续影响。

20世纪80年代初马尔视觉计算理论提出后，学术界兴起了“计算机视觉”的热潮。人们想到的这种理论的一种直接应用就是给工业机器人赋予视觉能力，典型的系统就是所谓的“基于部件的系统”（parts-based system）。然而，10多年的研究，使人们认识到，尽管马尔计算视觉理论非常优美，但“鲁棒性”（Robustness）不够，很难想人们预想的那样在工业界得到广泛应用。这样，人们开始质疑这种理论的合理性，甚至提出了尖锐的批评。

对马尔计算视觉理论提出批评最多的有二点：
- 一是认为这种三维重建过程是"纯粹自底向上的过程"（pure bottom-up process），缺乏高层反馈（top-down feedback）；
- 二是"重建"缺乏"目的性和主动性"。由于不同的用途，要求重建的精度不同，而不考虑具体任务，仅仅"盲目地重建一个适合任何任务的三维模型"似乎不合理。

对马尔视觉计算理论提出批评的代表性人物有：马里兰大学的 J. Y. Aloimonos;宾夕法尼亚大学的R. Bajcsy和密西根州立大学的A. K. Jaini。 Bajcsy 认为，视觉过程必然存在人与环境的交互，提出了**主动视觉**的概念（active vision）. Aloimonos认为视觉要有目的性，且在很多应用，不需要严格三维重建，提出了"目的和定性视觉"（purpose and qualitative vision） 的概念。 Jain 认为应该重点强调应用，提出了"应用视觉"（ practicing vision）的概念。上世纪80年代末到90年代初，可以说是计算机视觉领域的"彷徨"阶段。真有点"批评之声不绝，视觉之路茫茫"之势。

值得指出的是，"主动视觉"应该是一个非常好的概念，但困难在于"如何计算"。 主动视觉往往需要"视觉注视"（visual attention），需要研究脑皮层（cerebral cortex）高层区域到低层区域的反馈机制，这些问题，即使脑科学和神经科学已经较20年前取得了巨大进展的今天，仍缺乏"计算层次上的进展"可为计算机视觉研究人员提供实质性的参考和借鉴。

#### 多视几何和分层三维重建（Multiple View Geometry and Stratified 3D Reconstruction）

20世纪90年代初计算机视觉从"萧条"走向重新"繁荣"，主要得益于以下二方面的因素：首先，瞄准的应用领域从精度和鲁棒性要求太高的"工业应用"转到要求不太高，特别是仅仅需要"视觉效果"的应用领域，如远程视频会议（teleconference），考古，虚拟现实，视频监控等。另一方面，人们发现，多视几何理论下的分层三维重建能有效提高三维重建的鲁棒性和精度。

2000 年Hartley 和Zisserman 合著的书 (Hartley & Zisserman 2000) 对这方面的内容给出了比较系统的总结，而后这方面的工作主要集中在如何提高"大数据下鲁棒性重建的计算效率"。大数据需要全自动重建，而全自动重建需要反复优化，而反复优化需要花费大量计算资源。所以，如何在保证鲁棒性的前提下快速进行大场景的三维重建是后期研究的重点。

举一个简单例子，假如要三维重建北京中关村地区，为了保证重建的完整性，需要获取大量的地面和无人机图像。假如获取了1万幅地面高分辨率图像（4000×3000），5 千幅高分辨率无人机图像（8000×7000）（这样的图像规模是当前的典型规模），三维重建要匹配这些图像，从中选取合适的图像集，然后对相机位置信息进行标定并重建出场景的三维结构，如此大的数据量，人工干预是不可能的，所以整个三维重建流程必须全自动进行。这样需要重建算法和系统具有非常高的鲁棒性，否则根本无法全自动三维重建。在鲁棒性保证的情况下，三维重建效率也是一个巨大的挑战。所以，目前在这方面的研究重点是如何快速、鲁棒地重建大场景。


#### 基于学习的视觉（Learning based vision）

基于学习的视觉，是指以机器学习为主要技术手段的计算机视觉研究。基于学习的视觉研究，文献中大体上分为二个阶段：本世纪初的以流形学习( manifold Learning)为代表的子空间法( subspace method)和目前以深度神经网络和深度学习（deep neural networks and deep learning）为代表的视觉方法。

1、流形学习（Manifold Learning）

正像前面所指出的，物体表达是物体识别的核心问题。给定图像物体，如人脸图像，不同的表达，物体的分类和识别率不同。另外，直接将图像像素作为表达是一种"过表达"，也不是一种好的表达。流形学习理论认为，一种图像物体存在其"内在流形"（intrinsic manifold）, 这种内在流形是该物体的一种优质表达。所以，流形学习就是从图像表达学习其内在流形表达的过程，这种内在流形的学习过程一般是一种非线性优化过程。
流形学习始于2000年在Science 上发表的二篇文章（ Tenenbaum et al., 2000） (Roweis & Lawrence 2000)。流形学习一个困难的问题是没有严格的理论来确定内在流形的维度。人们发现，很多情况下流形学习的结果还不如传统的PCA （Principal Component Analysis），LDA（ linear DiscriminantAnalysis ）， MDS（ Multidimensional Scaling）等。流形学习的代表方法有：LLE（Locally Linear Embedding ）(Roweis & Lawrence 2000)，Isomap （ Tenenbaum et al., 2000）， Laplacian Eigenmaps (Belkin & Niyogi, 2001)等。

2、深度学习（Deep Learning）

深度学习的成功，主要得益于数据积累和计算能力的提高。深度网络的概念20世纪80年代就已提出来了，只是因为当时发现"深度网络"性能还不如"浅层网络"，所以没有得到大的发展。目前似乎有点计算机视觉就是深度学习的应用之势，这可以从计算机视觉的三大国际会议：国际计算机视觉会议（ICCV），欧洲计算机视觉会议（ECCV）和计算机视觉和模式识别会议（CVPR）上近年来发表的论文就可以看出。
目前的基本状况是，人们都在利用深度学习来"取代"计算机视觉中的传统方法。"研究人员"成了"调程序的机器"，这实在是一种不正常的"群众式运动"。
关于深度网络和深度学习，详细内容可参阅相关文献，这里仅仅强调以下几点：
- （1）深度学习在物体视觉方面较传统方法体现了巨大优势，但在空间视觉，如三维重建，物体定位方面，仍无法与基于几何的方法相媲美。这主要是因为深度学习很难处理图像特征之间的误匹配现象。在基于几何的三维重建中，RANSAC （Random Sample Consensus）等鲁棒外点（误匹配点）剔除模块可以反复调用，而在深度学习中，目前还很难集成诸如RANSAC等外点剔除机制。如果深度网络不能很好地集成外点剔除模块，深度学习在三维重建中将很难与基于几何的方法相媲美，甚至很难在空间视觉中得到有效应用；
- （2） 深度学习在静态图像物体识别方面已经成熟，这也是为什么在ImageNet上的物体分类竞赛已不再举行的缘故；
- （3） 目前的深度网络，基本上是前馈网络。不同网络主要体现在使用的代价函数不同。下一步预计要探索具有"反馈机制"的层次化网络。反馈机制，需要借鉴脑神经网络机制，特别是连接组学的成果。
- （4） 目前对视频的处理，人们提出了RCNN (Recurrent Neural Networks)。循环是一种有效的同层作用机制，但不能代替反馈。大脑皮层远距离的反馈可能是形成大脑皮层不同区域具有不同特定功能的神经基础。所以，研究反馈机制，特别具有"长距离反馈"（跨多层之间）的深度网络, 将是今后研究图像理解的一个重要方向；
- （5）尽管深度学习和深度网络在图像物体识别方面取得了"变革性"成果，但为什么"深度学习"会取得如此好的结果目前仍然缺乏坚实的理论基础。目前已有一些这方面的研究，但仍缺乏系统性的理论。事实上，"层次化"是本质，不仅深度网络，其它层次化模型，如Hmax 模型（Riesenhuber & Poggio,1999） HTM （Hierarchical Temporal memory）模型（George & Hawkins, 2009）存在同样的理论困惑。为什么"层次化结构"（ hierarchical structure ）具有优势仍是一个巨大的迷。


### 1、20世纪50年代：生物视觉原理

研究生物视觉工作原理

人们总是在探索着所处世界中的万事万物—-这其中当然包括人类自身。
- 20世纪50年代左右，生物学家们做了很多努力来试图理解动物的**视觉系统**，其中比较有名的是Hubel和Wiesel的一些研究成果。他们从**电生理学**的角度来分析**猫**(猫和人类的大脑比较相近)的视觉皮层系统，从中发现了视觉通路中的信息分层处理机制，并提出了**感受野**的概念，实验示意图。
- 他们也因此获得了诺贝尔生理学或医学奖。
- ![](https://pic1.zhimg.com/80/v2-7334eca9fb28599d32acb25b6f880554_1440w.webp)
- ![exp](https://github.com/HusterHope/blogimage/raw/master/CS231n1-5.png)

主题是二维图像的分析和识别

1959年，神经生理学家 David Hubel 和 Torsten Wiesel 通过猫的**视觉实验**，首次发现了**视觉初级皮层神经元**对于移动边缘刺激敏感，发现了视功能柱结构，为视觉神经研究奠定了基础——促成了计算机视觉技术40年后的突破性发展，奠定了深度学习之后的核心准则。
- ![](https://pic4.zhimg.com/80/v2-198336fcd159146af1263f19c7483a4b_1440w.webp)
- 图片来源 [https://www.sohu.com/a/302537186_114877](https://www.sohu.com/a/302537186_114877)

1959年，Russell 和同学研制了一台可以把图片转化为被二进制机器所理解的灰度值的仪器——这是第一台**数字图像扫描仪**，处理数字图像开始成为可能。
 
这一时期，研究的主要对象如**光学字符识别**、**工件表面**、**显微图片**和**航空图片**的分析和解释等。
 
### 2、20世纪60年代：三维视觉理解

开创了三维视觉理解为目的的研究
- 计算机视觉严格来说是在20世纪60年代逐步发展起来的。
- 这个时期诞生了人类历史上的第一位计算机视觉博士，即Larry Roberts。
- 1963年撰写的论文“Machine perception of three-dimensional solids”中将物体简化为**几何形状**(立方体、棱柱体等)来加以识别。
- 当时人们相信只要提取出物体形状并加以空间关系的描述，那么就可以像“搭积木”般拼接出任何复杂的三维场景。人们的研究热情空前高涨，研究范围遍布角点特征、边缘、颜色、纹理提取以及推理规则建立等很多方面。
 
1965年， Lawrence Roberts《三维固体的机器感知》描述了从**二维**图片中推导**三维**信息的过程。
- 现代计算机视觉的前导之一，开创了理解三维场景为目的的计算机视觉研究。
- 他对积木世界的创造性研究给人们带来极大的启发，之后人们开始对**积木世界**进行深入的研究，从**边缘检测**、**角点特征**的提取，到线条、平面、曲线等几何要素分析，到图像明暗、纹理、运动以及成像几何等，并建立了各种数据结构和推理规则。
- ![](https://pic2.zhimg.com/80/v2-6291c7ebbe13d38f9cb749c78ff4774d_1440w.webp)
- 图片来源 [http://cs231n.stanford.edu/](https://link.zhihu.com/?target=http%3A//cs231n.stanford.edu/)

1966， MIT AI 实验室的 Seymour Papert 教授决定启动夏季视觉项目（“Summer Vision Project”），与会人员“雄心勃勃”地希望在一个暑假的时间里彻底解决计算机视觉问题。没错，几个月内解决机器视觉问题。Seymour 和 Gerald Sussman 协调学生将设计一个可以自动执行背景/前景分割，并从真实世界的图像中提取非重叠物体的平台。
- 虽然未成功，但是计算机视觉作为一个科学领域的正式诞生的标志。
- 随后几十年人们对于计算机视觉的热情却持续高涨，其影响范围也蔓延到了全世界。

1969年秋天，贝尔实验室的两位科学家Willard S. Boyle和George E. Smith正忙于电荷耦合器件（CCD）的研发。它是一种将光子转化为电脉冲的器件，很快成为了高质量数字图像采集任务的新宠，逐渐应用于工业相机传感器，标志着计算机视觉走上应用舞台，投入到工业机器视觉中。
 
### 3、20世纪70年代：理论体系

出现课程和明确理论体系

MIT的人工智能实验室在计算机视觉领域中发挥了相当积极的推动作用。
- 一方面，它于20世纪70年代设置了**机器视觉**(Machine Vision)课程；
- 同时人工智能实验室还吸引了全球很多研究人员参与到计算机视觉的理论和实践研究中。

70年代中期，麻省理工学院（MIT）人工智能（AI）实验室：CSAIL正式开设计算机视觉课程。
- ![](https://pic1.zhimg.com/80/v2-fd07bafc8fd56ad386d57b4d8a4a3db8_1440w.webp)
- 图片来源 [https://www.sohu.com/a/84165588_297710](https://link.zhihu.com/?target=https%3A//www.sohu.com/a/84165588_297710)

David Marr 教授在计算机视觉理论方面做出了非常多的贡献。他融合了心理学、神经生理学、数学等多门学科，提出了有别于前人的计算机视觉分析理论，并在前后二十年的时间里影响了这一领域的发展。
- 主要著作：<span style='color:blue'>Vision: A computational investigation into the human representation and processing of visual information</span>
- 由于David在1980年不幸病逝，这本书据说是由其学生归纳总结出来的
- 书中将视觉识别过程划分为三个阶段
- ![](https://pic3.zhimg.com/80/v2-df1216349fcf66fb62a11b1e4add39ba_1440w.webp)
- ![](https://pic4.zhimg.com/80/v2-c06609956132fa12e44fea4a7e1fd02f_1440w.webp)

1977年David Marr在MIT的AI实验室提出了，**计算机视觉理论**（Computational Vision），这是与 Lawrence Roberts当初引领的**积木世界分析方法**截然不同的理论。计算机视觉理论成为80年代计算机视觉重要理论框架，使计算机视觉有了明确的体系，促进了计算机视觉的发展。  
 
### 4、20世纪80年代：独立学科应用

独立学科形成，理论从实验室走向应用

20世纪80年代，逻辑学和知识库等理论在人工智能领域占据了主导地位。人们试图建立**专家系统**来存储先验知识，然后与实际项目中提取的特征进行规则匹配。这种思想也同样影响了计算机视觉领域，于是诞生了很多这方面的方法。
- David G. Lowe在论文“Three-Dimensional Object Recognition from Single Two-Dimensional Images”中提出了基于知识的视觉(Knowledge-based Vision)的概念
- ![](https://pic1.zhimg.com/80/v2-1b45da74adeead74228a30b4b121aea4_1440w.webp)

1980年，日本计算机科学家 Kunihiko Fukushima 在 Hubel 和 Wiesel 的研究启发下，建立了一个自组织的简单和复杂细胞的**人工网络**——Neocognitron，包括几个卷积层（通常是矩形的），他的感受野具有权重向量（称为`滤波器`）。
- 这些`滤波器`的功能是在输入值的二维数组（例如图像像素）上滑动，并在执行某些计算后，产生激活事件（2维数组），这些事件将用作网络后续层的输入。Fukushima 的 Neocognitron 可以说是第一个神经网络，是现代 CNN 网络中卷积层+池化层的最初范例及灵感来源。

1982年，David Marr 发表了有影响的论文--“<span style='color:blue'>愿景：对人类表现和视觉信息处理的计算研究</span>”。基于Hubel和Wiesel的想法视觉处理不是从整体对象开始, David介绍了一个**视觉框架**，其中检测边缘，曲线，角落等的**低级算法**被用作对视觉数据进行**高级理解**的铺垫。
- 同年《视觉》（Marr, 1982）一书的问世，标志着计算机视觉成为了一门独立学科。
- ![](https://pic2.zhimg.com/80/v2-0cd407e1f47871ec4d514b6dc7c7ff19_1440w.webp)

1982年 日本COGEX公司于生产的视觉系统 DataMan，是世界第一套工业**光学字符识别**（OCR）系统。

1989年，法国的 Yann LeCun 将一种后向传播风格学习算法应用于 Fukushima 的**卷积神经网络**结构。在完成该项目几年后，LeCun 发布了LeNet-5 -- 第一个引入今天仍在CNN中使用的一些基本成分的现代网络。现在卷积神经网络已经是图像、语音和手写识别系统中的重要组成部分。
 
### 5、20世纪90年代：特征对象识别

特征对象识别开始成为重点

此时计算机视觉虽然已经发展了几十年，但仍然没有得到大规模的应用，很多理论还处于实验室的水平，离商用要求相去甚远。
- 人们逐渐认识到计算机视觉是一个非常难的问题，以往的尝试似乎都过于“复杂”，于是有的学者开始“转向”另一个看上去更简单点儿的方向—**图像分割**(Image Segmentation)。后者的目标在于运用一些图像处理方法将物体分离出来，以此作为图像分类的第一步。

另外，伴随着**统计学理论**在人工智能中的逐渐“走红”，计算机视觉在20世纪90年代也同样经历了这个转折。学者们利用统计学手段来提取物体的本质特征描述，而不是由人工去定义这些规则。这一时期产生的多种基础理论直到现在还有广泛的应用，例如图像搜索引擎。

1997年，伯克利教授 Jitendra Malik（以及他的学生Jianbo Shi）发表了一篇论文，试图解决**感性分组**的问题。研究人员试图让机器使用**图论**算法将图像分割成合理的部分（自动确定图像上的哪些像素属于一起，并将物体与周围环境区分开来）

1999年， David Lowe 发表《基于局部尺度不变特征（`SIFT`特征）的物体识别》，标志着研究人员开始停止通过创建三维模型重建对象，而转向基于特征的对象识别。
- ![](https://pic2.zhimg.com/80/v2-a95479b4dde8cae49e96b1ec2b9db135_1440w.webp)
- 图片来源 [https://wenku.baidu.com/view/152b0a9302020740be1e9b9e.html](https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/152b0a9302020740be1e9b9e.html)
- ![](https://pic4.zhimg.com/80/v2-9169bad52aa497851337bab82671be37_1440w.webp)

1999年，Nvidia 公司在推销 Geforce 256芯片时，提出了GPU概念。GPU是专门为了执行复杂的数学和集合计算而设计的数据处理芯片。伴随着GPU发展应用，游戏行业、图形设计行业、视频行业发展也随之加速，出现了越来越多高画质游戏、高清图像和视频。
 
### 6、21世纪初：图像特征工程

随着机器学习的兴起，CV领域开始取得一些实际的应用进展。
- Paul Viola和Michael Johns等人利用Adaboost算法出色地完成了人脸的**实时检测**，并被富士公司应用到商用产品中；同时SPM、HoG、DPM等经典算法也如“雨后春笋”般涌现了出来。
- ![](https://pic2.zhimg.com/80/v2-47675449a368518193a6b7e49525b091_1440w.webp)

图像特征工程,出现真正拥有标注的高质量数据集
- 2001年，Paul Viola 和 Michael Jones 推出了第一个实时工作的**人脸检测**框架。虽然不是基于深度学习，但算法仍然具有深刻的学习风格，因为在处理图像时，通过一些特征可以帮助定位面部。该功能依赖于Viola / Jones算法，五年后，Fujitsu 发布了一款具有**实时人脸检测**功能的相机。
- 2005年，由 Dalal & Triggs 提出来**方向梯度直方图**，`HOG`（Histogramof Oriented Gradients）应用到行人检测上。是目前计算机视觉、模式识别领域很常用的一种描述图像局部纹理的特征方法。
- 2006年，Lazebnik, Schmid & Ponce 提出一种利用**空间金字塔**即 `SPM` （Spatial Pyramid Matching）进行图像**匹配**、**识别**、**分类**的算法，是在不同分辨率上统计图像特征点分布，从而获取图像的局部信息。
- 2006年，Pascal VOC项目启动。它提供了用于对象分类的标准化数据集以及用于访问所述数据集和注释的一组工具。创始人在2006年至2012年期间举办了年度竞赛，该竞赛允许评估不同对象类识别方法的表现。检测效果不断提高。
- 2006年左右，Geoffrey Hilton 和他的学生发明了用GPU来优化深度神经网络的工程方法，并发表在《Science》和相关期刊上发表了论文，首次提出了“**深度信念网络**”的概念。他给多层神经网络相关的学习方法赋予了一个新名词–“深度学习”。随后深度学习的研究大放异彩，广泛应用在了图像处理和语音识别领域，他的学生后来赢得了2012年 ImageNet 大赛，并使CNN家喻户晓。
- 2009年，由 Felzenszwalb 教授在提出基于 HOG 的 deformable parts model(DPM)，可变形零件模型开发，它是深度学习之前最好的最成功的objectdetection & recognition算法。它最成功的应用就是检测行人，目前DPM已成为众多分类、分割、姿态估计等算法的核心部分，Felzenszwalb本人也因此被VOC授予"终身成就奖"。
- ![](https://pic2.zhimg.com/80/v2-27dbf54f9a9a0db131618fa288a7d85d_1440w.webp)
- 图片来源 [http://www.360doc.com/content/14/0722/16/10724725_396297961.shtml](https://link.zhihu.com/?target=http%3A//www.360doc.com/content/14/0722/16/10724725_396297961.shtml)
 
### 7、2010年-至今：深度学习

大家有幸正在经历人工智能大爆发的这个历史阶段—-包括计算机视觉在内的多项人工智能领域取得了长足的进步。
- ① 计算机运算能力呈现指数级的增长。
- ② ImageNet、PASCAL等超大型图片数据库使得深度学习训练成为可能
  - 注：大型图片数据库虽然在2000年后期就已经出现了，但真正大放异彩还是在最近十年
- 同时，业界一些极具影响力的竞赛项目(例如ILSVRC)激励了全世界范围内的学者们竞相加入，从而催生了一个又一个优秀的深度学习框架。

深度学习在视觉中的流行，在应用上百花齐放

2009年，`李飞飞`教授等在 CVPR2009 上发表了一篇名为《ImageNet: A Large-Scale Hierarchical Image Database》的论文，发布了`ImageNet`数据集，这是为了检测计算机视觉能否识别自然万物，回归机器学习，克服过拟合问题，经过三年多在筹划组建完成的一个大的数据集。从10年-17年，基于ImageNet数据集共进行了7届ImageNet挑战赛，李飞飞说
- ImageNet改变了AI领域人们对数据集的认识，人们真正开始意识到它在研究中的地位，就像算法一样重要

ImageNet是计算机视觉发展的重要推动者，和深度学习热潮的关键推动者，将目标检测算法推向了新的高度。
- ![](https://pic2.zhimg.com/80/v2-d61843e9d089eae746c46aff69e2f631_1440w.webp)
- 图片来源 [http://cs231n.stanford.edu/](https://link.zhihu.com/?target=http%3A//cs231n.stanford.edu/)

2012 年，Alex Krizhevsky、Ilya Sutskever 和 Geoffrey Hinton 创造了一个“大型的深度卷积神经网络”，即现在众所周知的 `AlexNet`，赢得了当年的 ILSVRC。这是史上第一次有模型在 ImageNet 数据集表现如此出色。
- 论文“ImageNet Classification with Deep Convolutional Networks”，迄今被引用约 7000 次，被业内普遍视为行业最重要的论文之一，真正展示了 CNN 的优点。机器识别的错误率从25%左右。降低了百分之16%左右，跟人类相比差别不大。是自那时起，CNN 才成了家喻户晓的名字。  
- ![](https://pic3.zhimg.com/80/v2-f3344631fc7d73618d97ba3f18701d42_1440w.webp)
- ![](https://pic1.zhimg.com/80/v2-bf3867966fc46feac560ed35f269fedc_1440w.webp)
- 图片来源 [http://cs231n.stanford.edu/](https://link.zhihu.com/?target=http%3A//cs231n.stanford.edu/)

2014年，蒙特利尔大学提出**生成对抗网络**（`GAN`）：拥有两个相互**竞争**的神经网络可以使机器学习得更快。一个网络尝试模仿真实数据生成假的数据，而另一个网络则试图将假数据区分出来。随着时间的推移，两个网络都会得到训练，**生成对抗网络**（`GAN`）被认为是计算机视觉领域的重大突破。  

2017-2018 年深度学习框架的开发发展到了**成熟期**。PyTorch 和 TensorFlow 已成为首选框架，都提供了针对多项任务（包括图像分类）的大量预训练模型。

近年来，国内外巨头纷纷布局计算机视觉领域，开设计算机视觉研究实验室。以计算机视觉新系统和技术赋能原有的业务，开拓战场。
- 如Facebook 的 AI Research（FAIR）在视觉方面2016年声称其 DeepFace 人脸识别算法有着 97.35% 的识别准确率，几乎与人类不分上下。
- 2017，Lin, Tsung-Yi等提出**特征金字塔**网络，可以从深层特征图中捕获到更强的语义信息。同时提出 Mask R-CNN，用于图像的实例分割任务，它使用简单、基础的网络设计，不需要多么复杂的训练优化过程及参数设置，就能够实现当前最佳的实例分割效果，并有很高的运行效率。
- 2016，亚马逊收购了一支欧洲顶级计算机视觉团队，为 Prime Air无人机加上识别障碍和着陆区域的能力, 开发无人机送货。
- 2017年亚马逊网络服务（AWS）宣布对其识别服务进行了一系列更新，为云客户提供基于机器学习的计算机视觉功能。客户将能够在数百万张面孔的集合上进行实时人脸搜索。例如，Rekognition 可用于验证一个人的图像与现有数据库中的另一个图像相匹配，数据库高达数千万个图像，具有亚秒级延迟。
- 2018年末，英伟达发布的**视频到视频生成**（Video-to-Video synthesis），它通过精心设计的发生器、鉴别器网络以及时空对抗物镜，合成高分辨率、照片级真实、时间一致的视频，实现了让AI更具物理意识，更强大，并能够推广到新的和看不见的更多场景。
- 2019， BigGAN，同样是一个GAN，只不过更强大，是拥有了更聪明的课程学习技巧的GAN，由它训练生成的图像连它自己都分辨不出真假，因为除非拿显微镜看，否则将无法判断该图像是否有任何问题，因而，它更被誉为史上最强的**图像生成器**。
- 2020年5月末，Facebook发布新购物AI，通用计算机视觉系统GrokNet让“一切皆可购买”。
- ![](https://pic1.zhimg.com/80/v2-4828268313995260c7d94959a7077ed0_1440w.webp)
- 图片来源[https://baijiahao.baidu.com/s?id=1667315579098237070&wfr=spider&for=pc](https://link.zhihu.com/?target=https%3A//baijiahao.baidu.com/s%3Fid%3D1667315579098237070%26wfr%3Dspider%26for%3Dpc)


## cv知识体系

内容：
- 数字图像处理：图像处理（特征提取+分割+配准）、识别（分类）、变换
- 视频处理：[目标检测](2020/03/08/object-detection)、目标跟踪
- [计算机图形学](graphic)：三维建模（面绘制、体绘制）
- [元宇宙](/2021/11/03/meta-universe)
- 算法：机器学习、[深度学习](https://wqw547243068.github.io/2020/01/14/dl-note/?query=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C)（神经网络）

### 教程

【2022-12-28】
- 华盛顿大学，[Computer Vision: Algorithms and Applications, 2nd](http://szeliski.org/Book/)

### 【CMU】cv

CMU计算机视觉课程：[16-385 Computer Vision, Spring 2020](http://www.cs.cmu.edu/~16385/), 包含ppt
- Course Description
- This course provides a comprehensive introduction to computer vision. Major topics include image processing, detection and recognition, geometry-based and physics-based vision and video analysis. Students will learn basic concepts of computer vision as well as hands on experience to solve real-life vision problems.

Syllabus
- Introduction 计算机视觉介绍
- Image filtering 图像过滤
- Image pyramids and Fourier transform 图像金字塔与傅里叶变换
- Hough transform 霍夫变换
- Feature and corner detection 角点检测
- Feature descriptors and matching 特征匹配
- 2D transformations 二维变换
- Image homographies 单应图像
- Camera models 相机模型
- Two-view geometry 双视点几何
- Stereo 立体影响
- Radiometry and reflectance 辐射测量和反射率
- Photometric stereo and shape from shading 立体与阴影形状
- Image processing pipeline 图像处理流程
- Image classification 图像分类
- Bag of works
- Neural networks 神经网络
- Convolutional neural networks 卷积神经网络
- Optical flow 光流
- Alignment 对齐
- Tracking 跟踪
- Segmentation 图像分割
- graph-based techniques 图形学
- Structure from motion and wrap-up 运动结构

### 【斯坦福】cs231n

- 斯坦福cs 231, CS231n 是顶级院校斯坦福出品的深度学习与计算机视觉方向专业课程，核心内容覆盖神经网络、CNN、图像识别、RNN、神经网络训练、注意力机制、生成模型、目标检测、图像分割等内容。
  - 解读：[深度学习与CV教程](https://www.showmeai.tech/tutorials/37)

目录
- CV引言与基础
- 图像分类与机器学习基础
- 损失函数与最优化
- 神经网络与反向传播
- 卷积神经网络
- 神经网络训练技巧 (上)
- 神经网络训练技巧 (下)
- 常见深度学习框架介绍
- 典型CNN架构 (Alexnet, VGG, Googlenet, Restnet等)
- 轻量化CNN架构 (SqueezeNet, ShuffleNet, MobileNet等)
- 循环神经网络及视觉应用
- 目标检测 (两阶段, R-CNN系列)
- 目标检测 (SSD, YOLO系列)
- 图像分割 (FCN, SegNet, U-Net, PSPNet, DeepLab, RefineNet)
- 视觉模型可视化与可解释性
- 生成模型 (PixelRNN, PixelCNN, VAE, GAN)
- 深度强化学习 (马尔可夫决策过程, Q-Learning, DQN)
- 深度强化学习 (梯度策略, Actor-Critic, DDPG, A3C)

## 计算机视觉任务

### 示例

【2023-4-7】[visive.ai](https://www.visive.ai/solutions/ai-image-recognition)

Image Recognition is natural for humans, but now even computers can achieve good performance to help you automatically perform tasks that require computer vision. 
- Tagging
- Classification
- Object Detection
- Scene information

Object Detection & Segmentation
- AI can instantly detect people, products & backgrounds in the images

| 任务 | 示例 | 备注 |
| --- | --- | --- |
| 原图 | ![](https://lh3.googleusercontent.com/Q3xp-y0nZdZPowHcO0zk4MNMWUE42j93wxtRHvWrP8WVjRbEEbVRhuC3j3YzyDE7cCcvo0F-gEfiUA-WqKmFWm9WvBxa3xZqRsdyK-A2Yhzfnx4i=w1280) | |
| 目标检测 | ![](https://lh5.googleusercontent.com/VBQ_dYqZNzu7GfeXWsucsBvLkLmSEpS6HSxDUzkNfOLJA6NmO03lDobTlve59mHg7NWsAWmENkVGBTje5O_gx5OyItNwGGAVb7RAozTU4-t2WJe7=w1280) | |
| 姿态估计 | ![](https://lh4.googleusercontent.com/ftgsLSYBeC-50izdU04NHjqRUkPnHdc5fBNSU0PLetmnoc86OeSqftrOT56MkA4ZLxiKND6rFd545DM_dVAIB1V_3srL62chrblIFEZmncjn8tYB=w1280) | | 
| 图像分割 |  ![](https://lh6.googleusercontent.com/IzVEJFJJeZhjHL603cqHIv2y_bk6nCmOF5Fyqj2zmBbQMWP_sel86TXGwY_ggduF_Ckodmz5DMZMFQEDYr2JuxaEhLuqznb4_fB6fgSWsJTN2xI1=w1280) | | 
| 图像分割 | ![](https://lh4.googleusercontent.com/rPq9YTRLMGAZBb4fEe7-VgetO-3ETmVMGN89KXVgdLyj3ZwQ5rvLJCHOhZ477aiiSuqf8x6pqwlu96FoBPS32rIevPWuaFRhguonrbZpLRp1Zdj_=w1280) | | 
| 图像分割 |  ![](https://lh3.googleusercontent.com/OGkVSz2KAKok-NxvrmOZx3n9y6vxoRks2BZyGHV49HGSc4f-jDALqr_vvqaFL6TMeYNEbg8k9WEUvNbf04GjjYIXw9MBFVp-LGOO_hsItmyO2N5K=w1280) | | 

### 任务

计算机视觉有四个核心任务：图像分类、物体检测、语义分割和视频分析。
- （1）`图像分类`（image classification）：给定一张输入图像，图像分类任务旨在判断该图像所属类别。
- （2）`目标检测`（Object Recognition）：相对于目标定位，目标种类和数目不定。
  - `目标定位`：以包围框的(bounding box)形式得到图像类别位置，通常只有一类目标或固定数目的目标和背景类。
  - 详见专题文章：[目标检测](object-detection)
- （3）`图像分割`（Image Segmentation）
  - `语义分割`（Semantic Segmentation）：语义分割需要判断图像中哪些像素属于哪个目标。
  - `实例分割`（Instance Segmentation）：语义分割不区分属于相同类别的不同实例。
- （4）视频分析（Video Analysis）

从**核心**任务到`人脸支付`、`自动驾驶`、`影像辅助诊断`等落地的真实应用，中间还衍生了许多同样很重要的任务。
- `人体姿态识别`，可以让我们更好地理解运动员的动作方式，或是识别、预测人类的行为；
- `目标跟踪`，即对视频中的人脸、车辆等目标进行持续的识别和跟随，在安防等领域有非常广泛的应用；
- `SLAM` 可以通过视频图像对现实空间进行重建
- `OCR` 则是识别图片中的字符，将图片转换为文字。

![](https://pic4.zhimg.com/80/v2-e042f8a28d9eebff7f16af61281e6717_1440w.jpg)

除此之外，还有`边缘检测`、`细粒度识别`、`稠密运动估计`等任务。这些任务之间交叉组合，有时还会结合 NLP 、语音识别等技术，最终才变成了真正的落地应用。
- ![](https://pic2.zhimg.com/80/v2-9744199eecd022692a66b454f438251d_1440w.webp)

参考：[知智一分钟，什么是计算机视觉？](https://zhuanlan.zhihu.com/p/35652529)

<iframe src="//player.bilibili.com/player.html?aid=22045225&bvid=BV17W411L7TS&cid=36439064&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width='800' height='600'> </iframe>

例如，当图像中有多只猫时
- `语义分割`会将两只猫整体的所有像素预测为“猫”这个类别。
- `实例分割`需要区分出哪些像素属于第一只猫、哪些像素属于第二只猫。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08f68c43e558443c8d2d10dde6ea91be~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)

难点
- 语义鸿沟，拍摄视角变化，目标占据图像的比例变化，光照变化，背景相似，目标形变，遮挡。

作者：[离殇花开](https://juejin.cn/post/7023196910957953032)


## 专题

核心应用和关键知识点
- 基础部分：**图像安全**（加密、解密、信息隐藏、隐身）、**图像识别**（答题卡、手势、车牌、指纹、数字）、**物体计数**、图像**检索**、次品排查等。
- 机器学习：KNN**字符识别**（数字、字母）、数独求解（KNN）、SVM**数字识别**、**行人检测**、艺术画（K均值聚类）等。
- 深度学习：图像**分类**、**目标检测**（YOLO、SSD方法）、语义分割、实例分割、**风格迁移**、**姿势识别**等。
- 人脸相关：人脸检测、**人脸识别**、勾勒五官、人脸对齐、**表情识别**、**疲劳驾驶**检测、易容术、性别与年龄识别等。

案例：
- [计算机视觉40例](https://zhuanlan.zhihu.com/p/549251554)
- 商汤科技[技术演示](https://www.sensetime.com/cn/technology-detail?categoryId=43&gioNav=1)，覆盖图像、视频

### 特征识别

特征匹配
- ![](https://pic1.zhimg.com/80/v2-1b53412ec3736ef215799825dcc999bc_1440w.webp)
- ![](https://pic2.zhimg.com/80/v2-82ff0cae618329fdb09dd84dfd671db1_1440w.webp)


### 图像处理

图像滤波
- ![](https://pic3.zhimg.com/80/v2-935991f18dd8d5b3b6988e09860e491a_1440w.webp)

风格迁移
- ![](https://pic3.zhimg.com/80/v2-22bda1142ff108bd4bd15bef7f3993c2_1440w.webp)

### 图像增强

图像增强是对图像进行处理，使其比原始图像更适合于特定的应用，它需要与实际应用相结合。对于图像的某些特征如边缘、轮廓、对比度等，图像增强是进行强调或锐化，以便于显示、观察或进一步分析与处理

部分图像会出现整体较**暗**或较**亮**的情况，这是由于图片的**灰度值范围较小**，即**对比度低**。
- 实际应用中，通过绘制图片的**灰度直方图**，可以判断图片的灰度值分布，区分其对比度高低。
- 对于对比度较低的图片，可以通过一定的算法来增强其对比度。常用的方法有`线性变换`，`伽马变换`，`直方图均衡化`，`局部自适应直方图均衡化`等。

#### 灰度直方图

绘制灰度分布曲线图，灰度分布直方图和两者叠加图形
- ![](https://img2018.cnblogs.com/blog/1483773/201906/1483773-20190612223116340-827573379.png)



```py
#coding:utf-8

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np
                
img = cv.imread(r"C:\Users\Administrator\Desktop\maze.png",0)

hist = cv.calcHist([img],[0],None,[256],[0,256])

plt.subplot(1,3,1),plt.plot(hist,color="r"),plt.axis([0,256,0,np.max(hist)])
plt.xlabel("gray level")
plt.ylabel("number of pixels")

plt.subplot(1,3,2),plt.hist(img.ravel(),bins=256,range=[0,256]),plt.xlim([0,256])
plt.xlabel("gray level")
plt.ylabel("number of pixels")

plt.subplot(1,3,3)
plt.plot(hist,color="r"),plt.axis([0,256,0,np.max(hist)])
plt.hist(img.ravel(),bins=256,range=[0,256]),plt.xlim([0,256])
plt.xlabel("gray level")
plt.ylabel("number of pixels")

plt.show()
```

numpy 绘制

```py
import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np


img = cv.imread(r"C:\Users\Administrator\Desktop\maze.png",0)
histogram,bins = np.histogram(img,bins=256,range=[0,256])
print(histogram)
plt.plot(histogram,color="g")
plt.axis([0,256,0,np.max(histogram)])
plt.xlabel("gray level")
plt.ylabel("number of pixels")
plt.show()
```

matplotlib 绘制

```py
import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

img = cv.imread(r"C:\Users\Administrator\Desktop\maze.png",0)
rows,cols = img.shape
hist = img.reshape(rows*cols)
histogram,bins,patch = plt.hist(hist,256,facecolor="green",histtype="bar") #histogram即为统计出的灰度值分布
plt.xlabel("gray level")
plt.ylabel("number of pixels")
plt.axis([0,255,0,np.max(histogram)])
plt.show()
```

#### 图像增强方法

对比度增强: [详见](https://www.cnblogs.com/silence-cho/p/11006958.html)
- 将图片的灰度范围拉宽，如图片灰度分布范围在\[50,150]之间，将其范围拉升到\[0,256]之间。
- 线性变换，直方图正规化，伽马变换，全局直方图均衡化，限制对比度自适应直方图均衡化等算法。

图像增强方法
- 空间域
  - 点运算：灰度变换、直方图修正法
  - 区域运算：平滑、锐化
    - 平滑：平滑算法有邻域平均法、中指滤波、边界保持类滤波等。
    - 锐化
- 频率域
  - 高通滤波
  - 低通滤波
  - 同态滤波增强
- 彩色增强
  - 假彩色增强
  - 伪彩色增强
  - 彩色变换增强
- 代数运算


[图像平滑之均值滤波、方框滤波、高斯滤波及中值滤波](https://www.toutiao.com/article/6836292532251394567)

图像处理中噪声：主要有三种：
- 椒盐噪声（Salt & Pepper）：含有随机出现的黑白亮度值。
- 脉冲噪声：只含有随机的正脉冲和负脉冲噪声。
- 高斯噪声：含有亮度服从高斯或正态分布的噪声。高斯噪声是很多传感器噪声的模型，如摄像机的电子干扰噪声。

#### 滤波

滤波器主要两类：线性和非线性
- 线性滤波器：使用连续窗函数内像素加权和来实现滤波，同一模式的权重因子可以作用在每一个窗口内，即线性滤波器是空间不变的。
  - 如果图像的不同部分使用不同的滤波权重因子，线性滤波器是空间可变的。因此可以使用卷积模板来实现滤波。线性滤波器对去除高斯噪声有很好的效果。常用的线性滤波器有均值滤波器和高斯平滑滤波器。
  - (1) 均值滤波器：最简单均值滤波器是局部均值运算，即每一个像素只用其局部邻域内所有值的平均值来置换。
  - (2) 高斯平滑滤波器是一类根据高斯函数的形状来选择权值的线性滤波器。 高斯平滑滤波器对去除服从正态分布的噪声是很有效的。
- 非线性滤波器:
  - (1) 中值滤波器:均值滤波和高斯滤波运算主要问题是有可能模糊图像中尖锐不连续的部分。中值滤波器的基本思想使用像素点邻域灰度值的中值来代替该像素点的灰度值，它可以去除脉冲噪声、椒盐噪声同时保留图像边缘细节。中值滤波不依赖于邻域内与典型值差别很大的值，处理过程不进行加权运算。中值滤波在一定条件下可以克服线性滤波器所造成的图像细节模糊，而对滤除脉冲干扰很有效。
  - (2) 边缘保持滤波器:由于均值滤波：平滑图像外还可能导致图像边缘模糊和中值滤波：去除脉冲噪声的同时可能将图像中的线条细节滤除。边缘保持滤波器是在综合考虑了均值滤波器和中值滤波器的优缺点后发展起来的，它的特点是：滤波器在除噪声脉冲的同时，又不至于使图像边缘十分模糊。

#### 加噪声

增加噪声

```py
# -*- coding:utf-8 -*-
import cv2
import numpy as np
#读取图片
img = cv2.imread("test.jpg", cv2.IMREAD_UNCHANGED)
rows, cols, chn = img.shape
#加噪声
for i in range(5000):  
  x = np.random.randint(0, rows)  
  y = np.random.randint(0, cols)  
  img[x,y,:] = 255
cv2.imshow("noise", img)
#等待显示
cv2.waitKey(0)
cv2.destroyAllWindows
```

![](https://p3-sign.toutiaoimg.com/pgc-image/S1PQANUHUzvv2v~noop.image?_iz=58558&from=article.pc_detail&x-expires=1672886951&x-signature=aImTitbc%2F%2Bd4cj0q6LgP%2B6ftUV8%3D)


#### 均值滤波

均值滤波
- 均值滤波是指任意一点的像素值，都是周围N*M个像素值的均值。例如下图中，红色点的像素值为蓝色背景区域像素值之和除25。
- ![](https://p3-sign.toutiaoimg.com/pgc-image/S1PQAOWBKmVEju~noop.image?_iz=58558&from=article.pc_detail&x-expires=1672886951&x-signature=A8tTul6nQ8qFr1QM%2BAfB1Y6MA9M%3D)

```py
#encoding:utf-8
import cv2 
import numpy as np 
import matplotlib.pyplot as plt
#读取图片
img = cv2.imread('test01.png')
source = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
#均值滤波
result = cv2.blur(source, (5,5)) # 核设置为（10，10）和（20，20）会让图像变得更加模糊
#显示图形
titles = ['Source Image', 'Blur Image'] 
images = [source, result] 
for i in xrange(2):  
  plt.subplot(1,2,i+1)
  plt.imshow(images[i], 'gray')  
  plt.title(titles[i]) 
  plt.xticks([]),plt.yticks([]) 
  plt.show
```

输出结果如下图所示：
- ![](https://p3-sign.toutiaoimg.com/pgc-image/S1PQBHv6oIZHwm~noop.image?_iz=58558&from=article.pc_detail&x-expires=1672886951&x-signature=gko2c3dp3wwoNGu9VhieIRLyBlQ%3D)

#### 方框滤波

方框滤波
- 方框滤波和均值滤波核基本一致，区别是需不需要均一化处理。OpenCV调用boxFilter函数实现方框滤波。函数如下：
- result = cv2.boxFilter(原始图像, 目标图像深度, 核大小, normalize属性)

#### 高斯滤波

高斯滤波
- 为了克服简单局部平均法的弊端(图像模糊)，目前已提出许多保持边缘、细节的局部平滑算法。它们的出发点都集中在如何选择邻域的大小、形状和方向、参数加平均及邻域各店的权重系数等。

图像高斯平滑也是邻域平均的思想对图像进行平滑的一种方法，在图像高斯平滑中，对图像进行平均时，不同位置的像素被赋予了不同的权重。高斯平滑与简单平滑不同，它在对邻域内像素进行平均时，给予不同位置的像素不同的权值

#### 中值滤波

中值滤波
- 在使用邻域平均法去噪的同时也使得边界变得模糊。而中值滤波是非线性的图像处理方法，在去噪的同时可以兼顾到边界信息的保留。选一个含有奇数点的窗口W，将这个窗口在图像上扫描，把窗口中所含的像素点按灰度级的升或降序排列，取位于中间的灰度值来代替该点的灰度值

### 图像识别

数字识别
- ![](https://pic2.zhimg.com/80/v2-49554e752e9ffeb8fb61c60462fa813d_1440w.webp)

人脸识别
- ![](https://pic4.zhimg.com/80/v2-1637c2414c72ca3fd8434869c3b4f623_1440w.webp)

属性识别（年龄、性别）
- ![](https://pic4.zhimg.com/80/v2-35af17b3c50063b36f9d9e465c9fd397_1440w.webp)

手势识别
- ![](https://pic3.zhimg.com/80/v2-1c844e2e524f07f26135b25c6eb71426_1440w.webp)

【2022-12-29】[隐形键盘要来了？鲍哲南等人开发新型智能皮肤，可实现手部任务快速识别](https://mp.weixin.qq.com/s/sGRWG4SYnwVSYdqhEXuLQw)
- 在隐形键盘上打字、仅凭触摸就能识别物体、通过手势便可以实现与应用程序的交互。


缺陷检测
- ![](https://pic2.zhimg.com/80/v2-3ea564958b58f32661c206127e64d67d_1440w.webp)

车牌识别
- ![](https://pic4.zhimg.com/80/v2-834582c9b73b823bedee7908c4c14ecf_1440w.webp)

疲劳驾驶检测
- ![](https://pic1.zhimg.com/80/v2-829a72902cc5dd8a03aaea0ec32bb278_1440w.webp)
- ![](https://pic2.zhimg.com/80/v2-772eafa621aaa7a68c070e01f388c2b1_1440w.webp)

### 目标检测

行人检测
- ![](https://pic3.zhimg.com/80/v2-715909ee83eed755d72ea3f3728761d6_1440w.webp)
- ![](https://tryolabs.com/assets/guides/introductory-guide-computer-vision/object-detection-cars-48e1a4793f.gif)

目标计数
- ![](https://pic1.zhimg.com/80/v2-43204d761de013ce83f35f3c72c2d7fc_1440w.webp)

姿势识别
- ![](https://pic3.zhimg.com/80/v2-dd79a5708fde72afda4ebe6fd73eb512_1440w.webp)

### 图像分割

语义分割与实例分割
- ![img](https://pic2.zhimg.com/80/v2-09db83410da4affd809a93c908fa955d_1440w.webp)

#### Segment Anything

【2023-4-6】Meta 于宣布推出 [Segment Anything](https://segment-anything.com/demo#) 工具，可准确识别图像中的对象。
- [论文](https://scontent-hkg4-1.xx.fbcdn.net/v/t39.2365-6/10000000_900554171201033_1602411987825904100_n.pdf?_nc_cat=100&ccb=1-7&_nc_sid=3c67a6&_nc_ohc=Ald4OYhL6hgAX8Qn-qh&_nc_ht=scontent-hkg4-1.xx&oh=00_AfAKufiDsOcwIOv2nNjtYgavXwutWQSgfWmBrp8pMnl7-Q&oe=643306A7)

该项目包括模型、数据集。
- 该模型名为 Segment Anything Model（SAM），其数据集名称为 Segment Anything 1-Billion mask dataset（SA-1B）
- ![](https://pic4.zhimg.com/80/v2-ef24a8cbd27d1c65a71665f9359064eb_720w.webp)
- Segment Anything (SA) 项目：用于图像分割的新任务、模型和数据集。在数据收集循环中使用我们的高效模型，我们构建了迄今为止最大的分割数据集，在 1100 万张图像上有超过 10 亿个掩码。

Meta 官方表示这是有史以来最大的分割数据集（Segmentation Dataset）

Segment Anything 图像分割
- 从NLP中获得灵感。通过prompt工程解决各种下游任务，通过定义类似的任务，建立用于分割的基础模型。
- ![](https://pic1.zhimg.com/80/v2-6cd4c5e798f568908cc029a67bd7b718_720w.webp)

Zero-Shot Edge Detection 零样本边缘检测
- 该模型被设计和训练为可**提示**的，因此它可以将零样本转移到新的图像分布和任务中。评估了它在众多任务上的能力，发现它的零样本性能令人印象深刻——通常与之前的完全监督结果具有竞争力，甚至优于之前的结果。
- ![](https://pic1.zhimg.com/80/v2-4aab7e293d3a3babf102524e781b1d4c_720w.webp)


#### Inpaint-Anything

【2023-4-13】【Inpaint-Anything：SAM + 补全模型实现**自动化清除**图像里包含的目标】
- Inpaint-Anything - Inpaint anything using SAM + inpainting models.
- [论文链接](http://arxiv.org/abs/2304.06790)
-  Tao Yu [GitHub](github.com/geekyutao/Inpaint-Anything)
- ![](https://github.com/geekyutao/Inpaint-Anything/raw/main/example/fill-anything/sample1/with_mask.png)

来自中国科学技术大学和东方理工高等研究院的研究团队给出了令人惊艳的答案。基于 SAM，他们提出「修补一切」（Inpaint Anything，简称 IA）模型。区别于传统图像修补模型，IA 模型无需精细化操作生成掩码，支持了一键点击标记选定对象，IA 即可实现移除一切物体（Remove Anything）、填补一切内容（Fill Anything）、替换一切场景（Replace Anything），涵盖了包括目标移除、目标填充、背景替换等在内的多种典型图像修补应用场景。

尽管当前图像修补系统取得了重大进展，但它们在选择掩码图和填补空洞方面仍然面临困难。基于 SAM，研究者首次尝试无需掩码（Mask-Free）图像修复，并构建了「点击再填充」（Clicking and Filling） 的图像修补新范式，他们将其称为修补一切 （Inpaint Anything）（IA）。IA 背后的核心思想是结合不同模型的优势，以建立一个功能强大且用户友好的图像修复系统。

IA 拥有三个主要功能：
- (i) 移除一切（Remove Anything）：用户只需点击一下想要移除的物体，IA 将无痕地移除该物体，实现高效「魔法消除」；
- (ii) 填补一切（Fill Anything）：同时，用户还可以进一步通过文本提示（Text Prompt）告诉 IA 想要在物体内填充什么，IA 随即通过驱动已嵌入的 AIGC（AI-Generated Content）模型（如 Stable Diffusion）生成相应的内容填充物体，实现随心「内容创作」；
- (iii) 替换一切（Replace Anything）：用户也可以通过点击选择需要保留的物体对象，并用文本提示告诉 IA 想要把物体的背景替换成什么，即可将物体背景替换为指定内容，实现生动「环境转换」。

 「移除一切」步骤如下：
- 第 1 步：用户点击想要移除的物体；
- 第 2 步：SAM 将该物体分割出来；
- 第 3 步：图像修补模型（LaMa）填补该物体。

### 信息安全

数字水印
- ![](https://pic3.zhimg.com/80/v2-f122c8ab40e528066a3c42b34375380a_1440w.webp)

隐身术
- ![](https://pic1.zhimg.com/80/v2-245e8ff807f04f51a742c62573a558b8_1440w.webp)

### 图像检索

图像哈希
- ![](https://pic3.zhimg.com/80/v2-cfff2d6ad18088ddac3f76270ee7d9f2_1440w.webp)

Bing 图片搜索
- [Visual Search](https://cn.bing.com/visualsearch?mkt=zh-CN)
- [图像搜索 API v7](https://learn.microsoft.com/zh-cn/rest/api/cognitiveservices-bingsearch/bing-images-api-v7-reference)

支持功能
- Find chairs like this 输入图片
- Search for navy heels 输入文本
- Find similar images
- Explore landmarks 地标景点
- This looks like a... 输入图片，文本提示
- Pinpoint locations 景点打卡，输入图片
- Identify dog breeds 物种识别
- Shop for furniture 商品识别



## 图像处理-基础知识

《数字图像处理》，冈萨雷斯第三版，MATLAB实践
- 《数字图像处理》冈萨雷斯（第四版）[读书笔记目录](https://zhuanlan.zhihu.com/p/569167720)
- [北大ppt课件](https://wenku.baidu.com/view/055297b327fff705cc1755270722192e45365883.html?_wkts_=1672129716473), 百度文库版
- github上的[课件资料:数字图像处理](https://github.com/fei-hdu/courses/tree/main/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/2022), 杭州电子科技大学，[高飞](https://aiart.live/)
- 计算机视觉[ppt资料](https://github.com/fei-hdu/courses/tree/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89)


目录
- 第一章 概述
- 第二章 图像处理知识点全面整理
- 第三章 灰度变换与空间滤波知识点整理
- 第四章 频率域图像处理知识点整理
- 第五章 图像复原与重建知识点整理
- 第六章 彩色图像处理基础

### 灰度图

图像通常分为彩色图像和灰度图像两种。
- 在灰度图像中，每个像素都只有**一个**分量用来表示该像素的灰度值。这个分量就是该点的亮度值。
  - 常用的表示像素值所需的数据长度有8 bit或10 bit两种，即图像的位深为8 bit（256）或10 bit（1024）。
- 二值图
  - 灰度图有过度，二值图没有过渡，只有两种0(黑)、1(白)
- 在彩色图像中，每个像素都由**多个**颜色分量组成；每个颜色分量被称为一个通道（Channel）。
  - 图像中所有像素的通道数是一致的，即每个通道都可以表示为一幅与原图像内容相同但颜色不同的分量图像。
  - 以RGB格式的彩色图像为例，一幅完整的图像可以被分割为蓝（B分量）、绿（G分量）、红（R分量）三基色的单色图
  - ![](https://pic2.zhimg.com/80/v2-55fa93deb68f2b99370953a3ea7b8ea1_720w.webp)

RGB图像的宽、高为1920 像素×1080 像素，每个颜色通道的图像位深为 8 bit，则图像的数据体积为1920×1080×3×8bit，即49,766,400bit，约为5.93MB左右。

注： 
- ② 1 Byte＝8bit（位）。
- ③ 1KB＝1024Byte（字节）
- ④ 1 MB＝1024KB

![](https://pic4.zhimg.com/80/v2-627bf6d9d2f637442d2346958e67420b_720w.webp)

### 颜色空间

![](https://pic2.zhimg.com/80/v2-12c573c72e81a5be358de22a5d683675_720w.webp)

`颜色空间`（彩色模型、色彩空间、 彩色系统etc）是对色彩的一种描述方式，定义有很多种，区别在于面向不同的应用背景。
- 显示器中采用的`RGB`颜色空间是基于**物体发光**定义的（RGB正好对应光的三原色：Red，Green，Blue）；
- 工业印刷中常用的`CMY`颜色空间是基于**光反射**定义的（CMY对应了绘画中的三原色：Cyan，Magenta，Yellow）；
- `HSV`、`HSL`两个颜色空间都是从**人视觉**的直观反映而提出来的（H是色调，S是饱和度，I是强度）。

#### RGB（加法混色）

RGB颜色空间 基于颜色的**加法混色**原理，从黑色不断叠加Red，Green，Blue的颜色，最终可以得到白色光。 
- 将R、G、B三个通道作为笛卡尔坐标系中的X、Y、Z轴，就得到了一种对于颜色的空间描述
- ![](https://i0.hdslb.com/bfs/article/347f4ac7d52d301eb2560fc24c2394d99abad0e5.png@675w_635h_progressive.webp)

计算机中编程RGB每一个分量值都用8位（bit）表示，可以产生256*256*256=16777216中颜色，这就是经常所说的“24位真彩色”。 

作者：[unity_某某师_高锦锦](https://www.bilibili.com/read/cv5841645/)

#### CMY（减法混色）

相比于`RGB`，`CMY`（CMYK）颜色空间是另一种基于颜色**减法混色**原理的颜色模型。
- 在工业印刷中它描述的是需要在白色介质上使用何种油墨，通过光的**反射**显示出颜色的模型。
- CMYK描述的是`青`，`品红`，`黄`和`黑`四种油墨的数值。
- ![](https://i0.hdslb.com/bfs/article/20eefed4bae71f1f107b4519b029395d9dca9d93.png@300w_285h_progressive.webp)

打印机彩打时，会发现屏幕上看见的图像和实际打印出来的图像颜色不一样。
- 体现了肉眼的量化能力很好
- 打印机采用了不同的CMY颜色空间（映射关系）

CMYK颜色空间的颜色值与RGB颜色空间中的取值可以通过线性变换相互转换。

#### HSV（人视觉）

`HSV`颜色空间是根据颜色的直观特性, 由A. R. Smith在1978年创建的一种颜色空间, 也称`六角锥体模型`(Hexcone Model)。
- `RGB`和`CMY`颜色模型都是面向**硬件**的
- 而`HSV`（Hue Saturation Value）颜色模型是面向**用户**的。

这个模型中颜色的参数分别是：`色调`（H：hue），`饱和度`（S：saturation），`亮度`（V：value）。
- 这是根据人观察色彩的生理特征而提出的颜色模型
- 人的视觉系统对亮度的敏感度要强于色彩值，这也是为什么计算机视觉中通常使用灰度即亮度图像来处理的原因之一。

- 色调H：用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°；
- 饱和度S：取值范围为0.0～1.0；
- 亮度V：取值范围为0.0(黑色)～1.0(白色)。

HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。与加法减法混色的术语相比，使用色相，饱和度等概念描述色彩更自然直观。
- ![](https://i0.hdslb.com/bfs/article/e9e72c7ba0963c50c0d6b5cbe9b4bdf0a2681d72.png@942w_942h_progressive.webp)

HSL颜色空间与HSV类似，只不过把V：Value替换为了L：Lightness。这两种表示在用目的上类似，但在方法上有区别。二者在数学上都是圆柱，但HSV（色相，饱和度，色调）在概念上可以被认为是颜色的倒圆锥体（黑点在下顶点，白色在上底面圆心），HSL在概念上表示了一个双圆锥体和圆球体（白色在上顶点，黑色在下顶点，最大横切面的圆心是半程灰色）。注意尽管在HSL和HSV中“色相”指称相同的性质，它们的“饱和度”的定义是明显不同的。对于一些人，HSL更好的反映了“饱和度”和“亮度”作为两个独立参数的直觉观念，但是对于另一些人，它的饱和度定义是错误的，因为非常柔和的几乎白色的颜色在HSL可以被定义为是完全饱和的。对于HSV还是HSL更适合于人类用户界面是有争议的。 作者：unity_某某师_高锦锦 https://www.bilibili.com/read/cv5841645/ 出处：bilibili

#### 颜色空间转换

颜色空间之间的转换关系可以分类两类：
- 一类是颜色空间之间可以直接变换；
- 另一类是颜色空间之间不能直接转换，它们之间的变换需要通过借助其他颜色空间的过渡来实现，如，RGB和CIE L*a*b*。
- ![](https://pic2.zhimg.com/80/v2-80732f19238cdd34cbd04ac0f63e0cb9_720w.webp)

### 图像表示

[数字图像与模拟图像](https://zhuanlan.zhihu.com/p/252635549)

#### 模拟图像

（1）模拟图像
- `模拟图像`：在图像处理中，像纸质照片、电视模拟图像等，这种通过某种物理量（如光、电等）的强弱变化来记录图像亮度信息的图像。
- 特点：物理量的变化是**连续**的。

#### 数字图像

（2）数字图像
- `数字图像`：用一个数字阵列来表达客观物体的图像，离散采样点的集合，每个点具有其各自的属性。
- 特点：把**连续**模拟图像离散化成规则网格，并用计算机以数字的方式来记录图像上各网格点的亮度信息的图像。

小结：
- 一切肉眼能看见的，都是模拟图像（投影仪透出到幕布上的PPT也是模拟图像）。
- 而数字图像肉眼看不见，本质就是一个存储数字的矩阵，一团数据。

数码相机屏幕上呈现的图像是模拟图像。但是你看见的图像是你的相机把经过了光学透镜的模拟图像（光信号），先转化为电信号存储为你内存卡上的一个图片文件（模数转换），即是一个数字图像（在内存里存着，你看不见），然后经过数字图像上记录的信息经过相应颜色空间的映射（数模转换），最后又以光信号的方式呈现在相机的监视屏幕上（又变成模拟图像了）。

数字图像呈现在现实世界中（不论黑白/彩色）时，这个图像究竟是数字图像还是模拟图像？答案当然是模拟图像

#### 模数转换 or 数模转换

数字图像与模拟图像转换
- ![img](https://pic1.zhimg.com/80/v2-35da1f8acba8c338f5ff7afba5acebe8_720w.webp)
- 数字相机经过了模数转换的过程之后，实际是将现实世界的连续的以物理量（比如光）呈现的图像以一定的分辨率（像素）离散化了

#### 遥感图像

遥感图像都是有着一定的大小的，比如3000像素×5000像素。而空间分辨率即是指图片中的每一个像素代表的实际空间大小，比如250m×250m。


### 图像处理-基本步骤

图像处理[基本步骤](https://zhuanlan.zhihu.com/p/558711657)
- （1）图像获取
- （2）图像**增强**，对图像进行某种操作，使其在某种应用中比原图像更能得到合适的结果。
- （3）图像**复原**，改进图像外观，图像增强技术是主观的，图像复原是客观的。复原技术倾向于以图像退化的数学或概率模型为基础，而增强技术以好的增强效果这种主观偏好为基础
- （4）**彩色图像**处理
- （5）**小波变换**和其他**图像变换**，小波是以不同分辨率来表示图像的基础，小波变换可应用与图像压缩和金字塔特征表示。
- （6）**压缩**是指减少图像存储量或降低传输图像的带宽的处理。
- （7）**形态学**处理是提取图像中用于表示和描述形状的成分处理工具。
- （8）**分割**可以将一幅图像或分为各个组成部分或目标。
- （9）**特征提取**，在分割后一步进行，从分割中获取组成图像区域的像素的集合。特征提取包括特征检测和特征描述。特征检测是指寻找一幅图像中的特征、区域或边界。特征描述是指对检测到的特征规定量化属性。
- (10) 图像**模式分类**是指根据目标特征描述对子目标属于标记的过程。

总结：[img](https://pic4.zhimg.com/80/v2-2c50e078dc083216a5ea78338cb2a073_1440w.webp), [中文](https://pic1.zhimg.com/80/v2-17417fabe9df8bf82f62e1bd26921780_1440w.webp)
- ![](https://pic4.zhimg.com/80/v2-2c50e078dc083216a5ea78338cb2a073_1440w.webp)
- ![](https://pic1.zhimg.com/80/v2-17417fabe9df8bf82f62e1bd26921780_1440w.webp)


### 图像处理-知识点

数字图像处理
1. 模拟图像和数字图像
  - `模拟图像`指空间坐标和亮度都是连续变化
  - `数字图像`是一种空间坐标和灰度均不连续，用离散数字表示的图像
2. 数字图像处理系统组成
  - `采集`、`显示`、`存储`、`通信`、`图像处理与分析`五个模块
3. 相比模拟图像处理，数字图像处理的优点
  - 精度高，再现性好，灵活性、通用性强
4. 图像数字化步骤：`采样` -> `量化`
  - `采样`：将空间上连续的图像变换成离散点。圆，椭圆，正方，长方。采样间隔大，像素少，空间分辨率低。
  - `量化`：将像素灰度变换成离散的整数值。量化等级越多，层次越丰富，灰度分辨率越高，但数据量大。
5. `灰度直方图`：一幅图像中各灰度等级像素出现的频率之间的关系
  - 反应图像灰度的分布情况，不反映像素位置，
  - 应用：判断图像量化是否恰当，确定图像**二值化**阀值，计算图像中物体面积，
6. 图像变换目的：使图像处理问题简化，有利于图像特征提取，有利于从概念上增强对图像信息的理解
7. 图像变换算法：`二维傅立叶`变换，`沃尔什—哈达玛`变换，`哈尔`变换，`小波`变换
  - 二维傅立叶后的频谱：四角低频（反映大概样貌），中央高频（反应细节）
8. 图像增强不是以图像保真度为原则，而是通过处理设法有选择地突出，便于人或机器分析某些感兴趣的信息，抑制一些无用信息。
9. 图像增强方法可分为`空间域`（直接对像素灰度操作）和`频域`（对图像经傅立叶变换后的频谱操作）
  - `空间域`：
    - 灰度级校正，灰度变换，直方图修正法；
    - 局部平滑，最大均匀性平滑；
    - 阶梯锐化，Laplacian增强算子
  - `频域`： 
    - `平滑`：**低通**滤波器
    - `锐化`：**高通**滤波器
  - `彩色增强`：
    - 伪彩色增强：密度分割 
    - 彩色图像增强：彩色平衡
10. 图像复原与重建：图像增强可以不顾增强后是否失真，图像复原是要恢复原形
11. 图像恢复方法：
  - 1. 代数恢复：无约束复原 
  - 2. 频率域恢复：逆滤波恢复法 ，维纳滤波器
  - 3. 几何校正：像素灰度内插（最近邻元法，双线性内插）
12. 几种图像退化：模糊、失真、有噪声等
13. 保真度准则：描述解码图像相对原始图像偏离程度的测度：客观保真度准则+主观保真度准则
14. 图像压缩技术：有损压缩和无损压缩
  - `无损`压缩：霍夫曼编码，香农编码，算数编码
  - `有损`压缩：预测编码（线性预测和非线性预测），变换编码
15. 无损和有损预测编码算法不同之处？
  - 无损编码中删除的仅仅是图像数据中冗余的数据，经解码重建的图像没有任何失真。
  - 有损编码是指解码重建的图像与原图像相比有失真，不能精确的复原，但视觉效果上基本相同，是实现高压缩比的编码方式。
16. `图像分割`是指把图像分成互不重叠的区域并提取出感兴趣目标的技术
17. 按分割途径不同可以分为：
  - 1. 基于边缘提取的分割算法
  - 2. 区域分割算法 
  - 3. 区域增长（简单区域扩张法、质心形增长）
  - 4. 分裂—合并分割算法
18. 几个常用的边缘检测算子：
  - Canny 算子
  - Laplacian算子
  - Sobel 算子
19. Hough变换检测直线和圆算法


## 图像处理内容

包含
- · 基本概念：亮度、对比度、分辨率、饱和度、尖锐化等基础概念
- · 图像灰度变换：线性、分段线性、对数、反对数、幂律(伽马)变换等
- · 图像滤波：线性滤波和非线性滤波、空间滤波和频率域滤波，均值滤波、中值滤波、高斯滤波、逆滤波、维纳滤波等各种图像的基本操作

高级的图像操作:
- · 文本图像的倾斜矫正方法：霍夫变换、透视变换等
- · 图像边缘检测：canny算子、sobel算子、Laplace算子、Scharr滤波器等


## 图像分割

- 【2020-7-17】图像分割（Image Segmentation）是计算机视觉领域中的一项重要基础技术，是图像理解中的重要一环。图像分割是将数字图像细分为多个图像子区域的过程，通过简化或改变图像的表示形式，让图像能够更加容易被理解。
   - 图像分割技术自 60 年代数字图像处理诞生开始便有了研究，随着近年来深度学习研究的逐步深入，图像分割技术也随之有了巨大的发展。
   - 早期的图像分割算法不能很好地分割一些具有抽象语义的目标，比如文字、动物、行人、车辆。这是因为早期的图像分割算法基于简单的像素值或一些低层的特征，如边缘、纹理等，人工设计的一些描述很难准确描述这些语义，这一经典问题被称之为“语义鸿沟”。
   - 第三代图像分割很好地避免了人工设计特征带来的“语义鸿沟”，从最初只能基于像素值以及低层特征进行分割，到现在能够完成一些根据高层语义的分割需求。
   - 参考：[基于深度学习的图像分割在高德的实践](https://yqh.aliyun.com/detail/15920?utm_content=g_1000154176)
   - ![](https://p1-tt-ipv6.byteimg.com/img/pgc-image/9811c9fff31a4fe282dbce591f7642b8~tplv-obj:745:306.image)

## 图片小工具

【2022-10-19】[神奇海螺试验场](https://lab.magiconch.com/)出品
- [电子包浆](https://magiconch.com/patina/)，图片赛博做旧
- [梗图生成器](https://x.magiconch.com/)
- [颜色图片识别](https://magiconch.com/nsfw/)
- 切图：[九宫格](https://v.magiconch.com/sns-image)
- [你画我猜](https://draw.magiconch.com/)在线游戏


## 图像动态化

[Live2D](https://www.live2d.com/en/download/cubism/)

Live2D是一种应用于电子游戏的绘图渲染技术，通过一系列的连续图像和人物建模来生成一种类似二维图像的三维模型。对于以动画风格为主的冒险游戏来说非常有用。该技术由日本Guyzware公司开发，Live2D的前身为TORA系统，衍生技术是OIU系统。
- 知乎：[如何看待live2D这项技术？](https://www.zhihu.com/question/28130936)

<video width="620" height="440" controls="controls" autoplay="autoplay">
  <source src="https://vdn.vzuu.com/SD/fc42fe58-2322-11eb-a20b-9a794694b530.mp4" type="video/mp4" />
</video>


## 图像3D化-三维重建

- [2017-9-21]自拍照三维重建[3D Face Reconstruction from a Single Image](http://www.cs.nott.ac.uk/~psxasj/3dme/index.php)
- ![demo](https://cdn.vox-cdn.com/thumbor/fXbE0rbXW6WlcmtB1cKBiTsV1b0=/0x0:482x334/1820x1213/filters:focal(203x129:279x205):no_upscale()/cdn.vox-cdn.com/uploads/chorus_image/image/56734861/3d_mark_take_2.0.gif)
- 【2020-7-23】2D照片转3D的效果，代码：[3d-photo-inpainting](https://github.com/vt-vl-lab/3d-photo-inpainting)
- ![](https://p1-tt-ipv6.byteimg.com/img/pgc-image/54a7f500dc92415f91e0766e2f74c45a~tplv-obj:340:424.image?from=post)
- 【2020-11-18】端到端面部表情合成 Speech-Driven Animation [Github代码](https://github.com/DinoMan/speech-driven-animation)
  - ![](https://github.com/DinoMan/speech-driven-animation/raw/master/example.gif)
- 【2021-3-10】面部表情迁移：吴京+甄子丹 [微博示例](https://video.weibo.com/show?fid=1034:4609199536013325)
- 【2020-12-29】[单张图片三维重建](https://blog.csdn.net/zouxy09/article/details/8083553),Andrew Ng介绍他的两个学生用单幅图像去重构这个场景的三维模型。
   - [斯坦福大学](http://ai.stanford.edu/~asaxena/reconstruction3d/)
      - ![](http://ai.stanford.edu/~asaxena/reconstruction3d/Results/mountain_mesh_small.jpg)
   - [康奈尔大学](http://www.cs.cornell.edu/~asaxena/learningdepth/)

### 图像三维重建算法

【2023-3-19】图像三维重建

截止2022年，一些2D图片三维重建研究工作汇总，英文[视频介绍](https://www.zhihu.com/zvideo/1542654820820869121)

基于深度学习的图像三维重建算法性能较好的主要有：MVSNet、PatchMatchNet、NeuralRecon。
- `MVSNet` 开启了深度学习做三维重建的先河，本质是借鉴基于两张图片cost volume的双目立体匹配的深度估计方法，扩展到多张图片的深度估计，后续系列的改进思路主要是把回归网络改成cascade。
- `PatchMatchNet` 结合了传统PatchMatch算法以及深度学习的优点，是一种以learning-based Patchmatch为主体的cascade结构，主要包括基于FPN的多尺度特征提取、嵌入在cascade结构中的learning-based Patchmatch以及spatial refinement模块
- `NeuralRecon` 一种新的基于单目视频的实时三维场景重建框架，其核心思想是利用三维稀疏卷积和GRU算法，对每个视频片段的稀疏TSDF体进行增量联合重构和融合，这种设计能够实时输出精确的重建。实验表明，NeuralRecon在重建质量和运行速度上都优于现有的方法。


### 视频三维重建

【2023-3-22】NVIDIA [2023 GTC大会](https://www.nvidia.com/gtc/keynote/)，4:45开始看，里面有根据视频生成3D模型的


## pillow

PIL提供了通用的图像处理功能，以及大量的基本图像操作，如图像缩放、裁剪、旋转、颜色转换等。
- [Python 图像处理 Pillow 库](https://zhuanlan.zhihu.com/p/58671158)

Matplotlib提供了强大的绘图功能，其下的pylab/pyplot接口包含很多方便用户创建图像的函数。


### 图像操作

```py
from PIL import Image
import matplotlib.pyplot as plt

image = Image.open('python-logo.png')  # 创建图像实例
# 查看图像实例的属性
print(image.format, image.size, image.mode)
image.show() # 显示图像

img = Image.open("girl.jpg")

plt.figure()
# 子图
plt.subplot(221)
# 原图
plt.imshow(img)
plt.subplot(222)
# 将图像缩放至 256 * 256
plt.imshow(img.resize((256, 256)))
plt.subplot(223)
# 将图像转为灰度图
plt.imshow(img.convert('L'))
plt.subplot(224)
# 旋转图像
plt.imshow(img.rotate(45))
# 保存图像
plt.savefig("tmp.jpg")
plt.show()

```

![](https://img2018.cnblogs.com/blog/1503464/201909/1503464-20190905210234525-1188098313.jpg)


## opencv

【2022-10-7】[opencv-python快速入门篇](https://zhuanlan.zhihu.com/p/44255577)

### opencv简介

opencv 是用于快速处理图像处理、计算机视觉问题的工具，支持多种语言进行开发如c++、python、java等

### Python opencv安装

环境：
- 1、 python3
- 2、 numpy
- 3、 opencv-python

```shell
# 安装numpy
pip install numpy
# 安装opencv-python
pip install opencv-python
```

测试：
- 执行 import cv2

### 图像读取

（1）imread函数：读取数字图像

cv2.imread(path_of_image, intflag)
- 参数一： 需要读入图像的完整路径
- 参数二： 标志以什么形式读入图像，可以选择一下方式：
  - · cv2.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都将被忽略。它是默认标志
  - · cv2.IMREAD_GRAYSCALE：以灰度模式加载图像
  - · cv2.IMREAD_UNCHANGED：保留读取图片原有的颜色通道
    - · 1 ：等同于cv2.IMREAD_COLOR
    - · 0 ：等同于cv2.IMREAD_GRAYSCALE
    - · -1 ：等同于cv2.IMREAD_UNCHANGED

### 图像显示

（2）imshow 函数
- imshow函数作用是在窗口中显示图像，窗口自动适合于图像大小，我们也可以通过imutils模块调整显示图像的窗口的大小。
- 函数官方定义：cv2.imshow(windows_name, image)
  - 参数一： 窗口名称(字符串)
  - 参数二： 图像对象，类型是numpy中的ndarray类型，注：这里可以通过imutils模块改变图像显示大小

```py
import cv2
import numpy as np

raw_img = cv2.imread("liu.jpg")
h, w, _ = raw_img.shape
# 高斯模糊
gaussianBlur = cv2.GaussianBlur(raw_img, (0, 0), 10)
# resize to same scale 缩放
im1 = cv2.resize(raw_img, (200, 200))
cv2.imwrite('lena.bmp',im1)  # 写图像
# 灰度化 Image to Gray Image
gray_img = cv2.cvtColor(raw_img, cv2.COLOR_BGR2GRAY)
# 镜像 Gray Image to Inverted Gray Image
inverted_gray_image = 255 - gray_img
## Blurring The Inverted Gray Image
blurred_inverted_gray_image = cv2.GaussianBlur(inverted_gray_image, (19,19),0)
## Inverting the blurred image
inverted_blurred_image = 255-blurred_inverted_gray_image
### Preparing Photo sketching
sketck = cv2.divide(gray_img, inverted_blurred_image,scale= 256.0)
cv2.imshow("Original Image",img) # 开启第一个窗口
cv2.imshow("Pencil Sketch", sketck) # 开启第二个窗口
# ------ 多图展示 --------
print(raw_img.shape, sketck.shape)
# imgs = np.hstack([img,img2]) # 横向铺开
# imgs = np.vstack([img,img2]) # 纵向铺开
merge = np.hstack((raw_img, gaussianBlur))
cv2.imshow("Pencil Sketch", merge)
# ------ 按ESC退出（默认无关闭按键） -----
k = cv2.waitKey(0)
# 图像出现后必须把光标移动到窗口上再按键才会退出
if k == 27: # ESC键
  cv2.destroyAllWindows()
```

注意
- 不同尺寸、不同颜色（RGB和灰度）不能放在一个窗体中 -- 黑屏

解决办法
- 使用matplotlib

```py
import cv2
import matplotlib.pyplot as plt

# 使用matplotlib展示多张图片
def matplotlib_multi_pic1():
    for i in range(9):
        img = cv2.imread('880.png')
        title="title"+str(i+1)
        #行，列，索引
        plt.subplot(3,3,i+1)
        plt.imshow(img)
        plt.title(title,fontsize=8)
        plt.xticks([])
        plt.yticks([])
    plt.show()
matplotlib_multi_pic1()
```


### 图像写入

（3）imwrite 函数
- imwrite函数检图像保存到本地，官方定义：cv2.imwrite(image_filename, image)
  - 参数一： 保存的图像名称(字符串)
  - 参数二： 图像对象，类型是numpy中的ndarray类型


### 颜色空间

图像颜色主要是由于图像受到外界光照影响随之产生的不同颜色信息，同一个背景物的图像在不同光源照射下产生的不同颜色效果的图像，因此在做图像特征提取和识别过程时，要的是图像的**梯度信息**，也就是图像的本质内容，而**颜色信息**会对梯度信息提取造成一定的干扰，因此会在做图像特征提取和识别前将图像转化为**灰度图**，这样同时也降低了处理的数据量并且增强了处理效果。

图像色彩空间变换函数cv2.cvtColor

函数定义：cv2.cvtColor(input_image, flag)
- 参数一： input_image表示将要变换色彩的图像ndarray对象
- 参数二： 表示图像色彩空间变换的类型，以下介绍常用的两种：
  - · cv2.COLOR_BGR2GRAY： 表示将图像从BGR空间转化成灰度图，最常用
  - · cv2.COLOR_BGR2HSV： 表示将图像从RGB空间转换到HSV空间

如果想查看参数flag的全部类型，请执行以下程序便可查阅，总共有274种空间转换类型：

```python
import cv2
flags = [i for i in dir(cv2) if i.startswith('COLOR_')]
print(flags)
```

### 自定义图像

绘图简单图像
- 对于一个长宽分别为w、h的RGB彩色图像来说，每个像素值是由(B、G、R)的一个tuple组成，opencv-python 中每个像素三个值的顺序是B、G、R，而对于灰度图像来说，每个像素对应的便只是一个整数，如果要把像素缩放到0、1，则灰度图像就是二值图像，0便是黑色，1便是白色

```python
import cv2
#这里图像采用的仍旧是上面那个卡通美女啦
rgb_img = cv2.imread('E:/peking_rw/ocr_project/base_prehandle/img/cartoon.jpg')
print(rgb_img.shape)     #(1200, 1600, 3)
print(rgb_img[0, 0])     #[137 124  38]
print(rgb_img[0, 0, 0])  #137

gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)
print(gray_img.shape)    #(1200, 1600)
print(gray_img[0, 0])    #100
```

彩色图像的高度height = 1200， 宽度w=1600且通道数为3， 像素(0， 0)的值是(137 124 38)，即R=137, G=124, B=38， 对于灰度图像来说便只是单通道的了

因此(0, 0, 0)便是代表一个黑色像素，(255, 255, 255)便是代表一个白色像素。这么想，B=0, G=0, R=0相当于关闭了颜色通道也就相当于无光照进入，所以图像整个是黑的，而(255, 255, 255)即B=255, G=255, R=255， 相当于打开了B、G、R所有通道光线全部进入，因此便是白色。

#### 图像绘制方法

各种绘制方法
- 直线cv2.line、长方形cv2.rectangle、圆cv2.circle、椭圆cv2.ellipse、多边形cv2.polylines等集合图像绘制函数

公共参数：
- · img： 表示需要进行绘制的图像对象ndarray
- · color： 表示绘制几何图形的颜色，采用BGR即上述说的(B、G、R)
- · thickness： 表示绘制几何图形中线的粗细，默认为1，对于圆、椭圆等封闭图像取-1时是填充图形内部
- · lineType ： 表示绘制几何图形线的类型，默认8-connected线是光滑的，当取cv2.LINE_AA时线呈现锯齿状

##### (1) cv2.line函数

直线绘制函数， 函数官方定义为：
- cv2.line(image, starting, ending, color, thickness, lineType)
- 参数image、color、thickness、lineType分别是上述公共定义，参数starting、ending分别表示线的起点像素坐标、终点像素坐标

##### (2) cv2.rectangle函数

长方形绘制函数，函数官方定义：
- cv2.rectangle(image, top-left, bottom-right, color, thickness, lineType)
- 参数image、color、thickness、lineType分别是上述公共定义，参数top-left、bottom-right分别表示长方形的左上角像素坐标、右下角像素坐标


##### (3) cv2.circle函数
圆形绘制函数，官方定义函数为：
- cv2.circle(image, center, radius, color, thickness, lineType)
- 参数image、color、thickness、lineType分别是上述公共定义，参数center、radius分别表示圆的圆心像素坐标、圆的半径长度，圆绘制函数中当参数thickness = -1 时绘制的是实心圆，当thickness >= 0 时绘制的是空心圆


##### (4) cv2.ellipse函数

椭圆绘制函数，官方定义为：
- cv2.circle(image, center, (major-axis-length, minor-axis-length), angle, startAngle, endAngle, color, thickness, lineType)
- 椭圆的参数较多，首先参数image、color、thickness、lineType分别是上述公共定义，椭圆绘制函数中当参数thickness = -1 时绘制的是实心椭圆，当thickness >= 0 时绘制的是空心椭圆，其他参数如下
  - · center： 表示椭圆中心像素坐标
  - · major-axis-length： 表示椭圆的长轴长度
  - · minor-axis-length： 表示椭圆的短轴长度
  - · angle： 表示椭圆在逆时针方向旋转的角度
  - · startAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的起始角度
  - · endAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的终止时角度


##### (5) cv2.polylines函数

多边形绘制函数，官方定义函数为：
- cv2.polylines(image, \[point-set], flag, color, thickness, lineType)
- 参数image、color、thickness、lineType分别是上述公共定义，其他参数如下：
  - · \[point-set]： 表示多边形点的集合，如果多边形有m个点，则便是一个m*1*2的数组，表示共m个点
  - · flag： 当flag = True 时，则多边形是封闭的，当flag = False 时，则多边形只是从第一个到最后一个点连线组成的图像，没有封闭


#### 图像绘制示例

```python
import cv2
import numpy as np

img = np.ones((512,512,3), np.uint8)
img = 255*img
img = cv2.line(img, (100,100), (400,400),(255, 0, 0), 5)
img = cv2.rectangle(img,(200, 20),(400,120),(0,255,0),3)
img = cv2.circle(img,(100,400), 50, (0,0,255), 2)
img = cv2.circle(img,(250,400), 50, (0,0,255), 0)
img = cv2.ellipse(img,(256,256),(100,50),0,0,180,(0, 255, 255), -1)
pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)
img = cv2.polylines(img,[pts],True,(0, 0, 0), 2)

cv2.imshow('img', img)
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()
```

![](https://pic3.zhimg.com/80/v2-37c3e0653291eafc7d16ce071fdf9db6_1440w.webp)

### 像素操作

#### (1) 对图像取反

```python
reverse_img = 255 - gray_img
```

#### (2) 对图像像素线性变换

```python
for i in range(gray_img.shape[0]):
    for j in range(gray_img.shape[1]):
        random_img[i, j] = gray_img[i, j]*1.2
```

![](https://pic4.zhimg.com/80/v2-8fca4ea068a45033056e89236ae1644b_1440w.webp)

完整代码

```python
import cv2
import imutils
import numpy as np

rgb_img = cv2.imread('E:/peking_rw/ocr_project/base_prehandle/img/cartoon.jpg')
gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)
reverse_img = 255 - gray_img

random_img = np.zeros((gray_img.shape[0], gray_img.shape[1]), dtype=np.uint8)
for i in range(gray_img.shape[0]):
    for j in range(gray_img.shape[1]):
        random_img[i, j] = gray_img[i, j]*1.2
cv2.imshow('reverse_img', imutils.resize(reverse_img, 800))
cv2.imshow('random_img', imutils.resize(random_img, 800))
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()
```

### 窗口销毁

（4）窗口销毁函数
- 当使用imshow函数展示图像时，最后需要在程序中对图像展示窗口进行销毁，否则程序将无法正常终止
- 常用的销毁窗口的函数有下面两个：
  - ① cv2.destroyWindow(windows_name) # 销毁单个特定窗口
    - 参数： 将要销毁的窗口的名字
  - ② cv2.destroyAllWindows() # 销毁全部窗口，无参数

何时销毁窗口？肯定不能图片窗口一出现就将窗口销毁，这样便没法观看窗口，试想有两种方式：
- ① 让窗口停留一段时间然后自动销毁；
- ② 接收指定的命令，如接收指定的键盘敲击然后结束我们想要结束的窗口

以上两种情况都将使用cv2.waitKey函数， 首先产看函数定义：cv2.waitKey(time_of_milliseconds)
- 唯一参数 time_of_milliseconds是整数，可正可负也可是零，含义和操作也不同，分别对应上面说的两种情况
- ① time_of_milliseconds > 0 ：此时time_of_milliseconds表示时间，单位是毫秒，含义表示等待 time_of_milliseconds毫秒后图像将自动销毁
- ② time_of_milliseconds <= 0 ： 此时图像窗口将等待一个键盘敲击，接收到指定的键盘敲击便会进行窗口销毁。我们可以自定义等待敲击的键盘，通过下面的例子进行更好的解释


### 视频处理

[链接](https://blog.csdn.net/ljx1400052550/article/details/107410157)

```py
import cv2
import numpy as np
  
# 定义保存图片函数
# image:要保存的图片名字
# addr；图片地址与相片名字的前部分
# num: 相片，名字的后缀。int 类型
def save_image(image,addr,num):
  address = addr + str(num)+ '.jpg'
  cv2.imwrite(address,image)
  
# 读取视频文件
videoCapture = cv2.VideoCapture("test.mp4")
# 通过摄像头的方式
# videoCapture=cv2.VideoCapture(1)

#读帧
success, frame = videoCapture.read()
i = 0
#设置固定帧率
timeF = 10
j=0
while success :
  i = i + 1
  if (i % timeF == 0):
    j = j + 1
    save_image(frame,'./output/image',j)
    print('save image:',i)
  success, frame = videoCapture.read()
```


opencv按指定时间提取片段：[提取](https://blog.csdn.net/qq_41251963/article/details/123932842)

其它方法
- ffmpeg 工具

```sh
# 按时间窗
ffmpeg  -i ./SN.mp4 -vcodec copy -acodec copy -ss 00:00:00 -to 00:00:05 ./cutout1.mp4 -y
# 按帧截取
ffmpeg -i ./input.mp4 -vf "select=between(n\,20\,200)" -y -acodec copy ./output.mp4

```


### opencv 汇总示例

```python
import numpy as np
import cv2

gray_img = cv2.imread('img/cartoon.jpg', 0)  #加载灰度图像
rgb_img = cv2.imread('img/cartoon.jpg', 1)   #加载RGB彩色图像

cv2.imshow('origin image', rgb_img)   #显示原图
cv2.imshow('origin image', imutils.resize(rgb_img, 800))  #利用imutils模块调整显示图像大小
cv2.imshow('gray image', imutils.resize(gray_img, 800))
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()

cv2.imwrite('rgb_img.jpg', rgb_img)   #将图像保存成jpg文件
cv2.imwrite('gray_img.png', gray_img) #将图像保存成png文件

#表示等待10秒后，将销毁所有图像
if cv2.waitKey(10000):
    cv2.destroyAllWindows()
#表示等待10秒，将销毁窗口名称为'origin image'的图像窗口
if cv2.waitKey(10000):
    cv2.destroyWindow('origin image')
#当指定waitKey(0) == 27时，当敲击键盘 Esc 时便销毁所有窗口
if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()
#当接收到键盘敲击A时，便销毁名称为'origin image'的图像窗口
if cv2.waitKey(-1) == ord('A'):
    cv2.destroyWindow('origin image')
```

### imutils 工具包

imutils 是在OPenCV基础上的一个封装，达到更为简结的调用OPenCV接口的目的，它可以轻松的实现图像的平移，旋转，缩放，骨架化等一系列的操作。

安装方法

```shell
# 在安装前应确认已安装numpy,scipy,matplotlib和opencv
pip install imutils
# pip install NumPy SciPy opencv-python matplotlib imutils
```

图像操作：[参考](https://walkonnet.com/archives/364235)
- 图像平移
  - 相对于原来的cv，使用imutiles可以直接指定平移的像素，不用构造平移矩阵
  - OpenCV中也提供了图像平移的实现，要先计算平移矩阵，然后利用仿射变换实现平移，在imutils中可直接进行图像的平移。
  - translated = imutils.translate(img,x,y)
- 缩放函数：imutils.resize(img,width=100)
- 图像旋转
  - 逆时针旋转 rotated = imutils.rotate(image, 90)
  - 顺时针旋转 rotated_round = imutils.rotate_bound(image, 90)
- 骨架提取（边缘提取）
  - 骨架提取（边缘提取），是指对图片中的物体进行拓扑骨架(topological skeleton)构建的过程。
  - imutils提供的方法是skeletonize()
- 转RGB
  - img = cv.imread("lion.jpeg") 
  - plt.figure() 
  - plt.imshow(imutils.opencv2matplotlib(img))


### 完整示例


```python
import cv2
#pip install imutils
import imutils
import numpy as np

rgb_img = cv2.imread('/Users/wqw/Desktop/二十面体.png')
# 颜色空间转换：rgb → gray
gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)
# -------------
# 总共有274种空间转换类型：
# flags = [i for i in dir(cv2) if i.startswith('COLOR_')]
# print(flags)
# -----------
cv2.imshow('origin image', imutils.resize(rgb_img, 800))
cv2.imshow('gray image', imutils.resize(gray_img, 800))
cv2.imwrite('rgb_img.jpg', rgb_img)
cv2.imwrite('gray_img.png', gray_img)

# 等待一定时间自动销毁图像窗口
#if cv2.waitKey(10000):
#    cv2.destroyAllWindows()
#if cv2.waitKey(10000):
#    cv2.destroyWindow('origin image')
# 接收特定键盘销毁图像窗口
#if cv2.waitKey(-1) == ord('A'):
#    cv2.destroyWindow('origin image')
if cv2.waitKey(0) == 27: # 按 Esc键销毁所有窗口
    cv2.destroyAllWindows()
```

### gradio web

web上操作图像
- ![](https://pic3.zhimg.com/80/v2-2f1596269ed54ae5f882da2713cb0e56_1440w.webp)

```py
import gradio as gr
import cv2
​
def to_black(image):
    output = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    return output
​
interface = gr.Interface(fn=to_black, inputs="image", outputs="image",
                        examples=[["test.png"]])
interface.launch()
```


# OCR

- `光学字符识别`(`OCR`,Optical Character Recognition)是指对文本资料进行扫描，然后对图像文件进行分析处理，获取文字及版面信息的过程。OCR技术非常专业，一般多是印刷、打印行业的从业人员使用，可以快速的将纸质资料转换为电子资料。

## OCR 历史

OCR技术发展历程分为几类：
- 概念提出： 1929年由德国科学家Tausheck最早提出OCR概念，后来美国科学家Handel也提出利用技术对文字进行识别想法。最先对印刷体汉字识别进行研究的是IBM公司，于1966年发表第一篇关于汉字识别的文章，采用模板匹配法识别印刷体汉字。
- 发展研究： 早在60、70年代，世界各国就开始有OCR的研究，而初期以文字识别方法研究为主，且识别的文字仅为0至9的数字。
  - 以日本为例，1960年左右开始研究OCR的基本识别理论，初期以数字为对象，直至1965至1970年之间开始有一些简单的产品，如印刷文字的邮政编码识别系统。
- 形成产品： 在70年代，中国开始对数字、英文字母及符号识别进行研究，1986年，我国提出“863”高新科技研究计划，汉字识别的研究进入一个实质性阶段，相继推出中文OCR产品。早期OCR软件，因为识别率、硬件设备成本高及产品化等多方面的因素，未能达到实际要求。
- 百花齐放： 进入20世纪90年代之后，随着信息自动化普及，大大推进了OCR技术的进一步发展，使OCR的识别正确率和速度满足广大用户需求。随着人工智能技术不断发展，OCR软件产品已趋于成熟，可以识别各类语言、各类场景下识别，代表有全能扫描王、天若OCR等。

作者：[GoAI](https://juejin.cn/post/7260146586860912699)

## OCR 应用场景

应用场景
- ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eebb0147cf447b89da6b0e97b005ce1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)


按照**识别场景**划分，可分为:
-   **文档文字识别**：可以将图书馆、报社、博物馆、档案馆等的纸质版图书、报纸、杂志、历史文献档案资料等进行电子化管理，实现精准地保存文献资料。
-   **自然场景文字识别**：识别自然场景图像中的文字信息如车牌、广告干词、路牌等信息。对车辆进行识别可以实现停车场收费管理、交通流量控制指标测量、车辆定位、防盗、高速公路超速自动化监管等功能。
-   **票据文字识别**：可以对增值税发票、报销单、车票等不同格式的票据进行文字识别，可以避免财务人员手动输入大量票据信息，如今已广泛应用于财务管理、银行、金融等众多领域。。
-   **证件识别**：可以快速识别身份证、银行卡、驾驶证等卡证类信息，将证件文字信息直接转换为可编辑文本，可以大大提高工作效率、减少人工成本、还可以实时进行相关人员的身份核验，以便安全管理。

按照**文字形成方式**划分，可分为:
-   **标准印刷体文字的识别**（包括印刷体数字、汉字、英文）;
-   **手写文字的识别**（包括手写数字、汉字、英文）;
-   **即存在印刷体又存在手写体的文字识别**；
-   **艺术体、合成文字等复杂字体识别**；

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28e873e7c1504a5aaeee11148d5e32a9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

主要指标有：
- `拒识率`、`误识率`、`识别速度`、用户界面的友好性，产品的稳定性，易用性及可行性等


## OCR 识别技术


### OCR技术流程

OCR技术流程进行介绍。典型的OCR技术pipline如下图所示： 
- 输入 → 图像预处理 → 文字检测 → 文本识别 → 输出
- ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ca30e39795c40a189f9ed78d0658606~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

其中，`文本检测`和`识别`是OCR技术的两个重要核心技术。

#### 1 图像预处理：

图像预处理是OCR流程的第一步，用于提高字符识别的准确性。常见的预处理操作包括灰度化、二值化和去噪。
- 灰度化将彩色图像转换为灰度图像，将每个像素的RGB值转换为相应的灰度值。在灰度图像中每个像素只有一个灰度值，简化后续的处理步骤。
- 二值化将灰度图像转换为二值图像，将灰度值高于某个阈值的像素设为白色，低于阈值的像素设为黑色。这将图像转换为黑白二值图像，方便后续的文本定位和字符分割。
- 去噪是为了减少图像中的噪声和干扰，以提高后续处理的准确性。常用的去噪方法包括中值滤波、高斯滤波和形态学操作。

此外，针对不规则文本识别，在预处理阶段可以先进行校正操作再进行识别。

#### 2 文字检测

文本检测的任务是定位出输入图像中的文字区域。

近年来，使用深度学习进行文本检测成为主流技术，一类方法将文本检测视为目标检测中的一个特定场景，基于通用目标检测算法进行改进适配，如TextBoxes 基于一阶段目标检测器SSD 算法，调整目标框使之适合极端长宽比的文本行，CTPN则是基于Faster RCNN架构改进而来。但是文本检测与目标检测在目标信息以及任务本身上仍存在一些区别，如文本一般长宽比较大，往往呈“条状”，文本行之间可能比较密集，弯曲文本等，因此又衍生了很多专用于文本检测的算法，如EAST、PSENet、DBNet 等等。

#### 3 文字识别

文本识别的任务是识别出图像中的文字内容。

文本识别一般输入来自于文本检测得到的文本框截取出的图像文字区域。文本识别一般可以根据待识别文本形状分为**规则**文本识别和**不规则**文本识别两大类。不规则文本场景具有很大的挑战性，也是目前文本识别领域的主要研究方向。
- **规则**文本主要指印刷字体、扫描文本等，文本大致处在水平线位置，如下图左半部分；
- **不规则**文本往往不在水平位置，存在弯曲、遮挡、模糊等问题，如下图右半部分。
- ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8201b8bc88b4223b45a3b62b5e5e47d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)


### 识别难点

#### 自然场景：

> 自然场景下的文本通常出现在复杂的背景中，且文本的字体、颜色、大小和方向都可能不同。例如路标、广告牌和商品包装等。 不同于传统的扫描图像文本，自然场景文本因表现形式丰富，图像背景复杂，以及图像拍摄引入的干扰因素等的影响，其识别的难点包括但不限于以下几个方面:

-   **图片背景多变：** 经常面临低亮度、低对比度、光照不均、透视变形和残缺遮挡等问题，还可能会受到噪声的影响，例如风沙、雨雪等天气条件，以及拍摄设备本身的噪声等，使得对其的分析与处理难度远高于传统的扫描文档图像。
-   **文字弯曲：** 文本的布局可能存在扭曲、褶皱、换向等问题，其中的文字也可能字体多样、字号字重颜色不一的问题。
-   **文本格式：** 自然场景中的文字数量较多，且分布较为分散，这使得算法的训练难度加大。针对长文本，需要处理文本行之间的连续性和上下文关系。针对多行文本，需要进行有效的文本区域分割和识别。
-   **数据规模与资源** 为训练和优化深度学习OCR模型，需要大规模的数据集和充足的计算资源。然而，自然场景OCR数据集往往比较难以获取和标注，同时深度学习模型的训练也需要较大的计算开销。

#### 文档文字：

尽管普通文档识别相较于场景文本识别来说通常难度较小，但在特定领域中仍存在许多挑战。例如，针对票据扫描的目标检测，由于扫描仪分辨率低、纸张和油墨质量差等因素的影响，导致所扫描的票据质量低下。此外，字体过小以及干扰文本也是需要考虑的问题。

此外，针对复杂场景（复杂版面、数学公式、表格、结构化符号/图形等）的识别效果仍存在一定提升空间。

#### 识别难点解决办法：

> 关于上述不同场景OCR技术面临许多挑战，需要更强大算法来应对文本的多样性和背景的复杂性。那么我们从那些角度入手解决上述问题呢？

以下为作者简单列出几点通用的解决方法，：
1.  **数据增强：** 通过对训练数据进行增强，如随机旋转、缩放、裁剪、变换和加噪声等，可以使OCR模型更好地适应不同的图像条件和多样性。
2.  **多尺度检测：** 设计多尺度的检测模型可以在不同大小和分辨率的文本实例中进行检测，从而提高对不同文本大小和形状的适应性。
3.  **背景抑制：** 采用背景抑制技术，通过将注意力集中在文本区域，忽略或减弱背景干扰，从而提高文本检测的准确性。
4.  **多任务学习：** 将文本检测和识别任务结合起来进行多任务学习，可以更好地处理复杂场景中的文本实例，并提高整体性能。
5.  **引入先验知识：** 利用先验知识，如字符形状、文本的统计信息等，对文本进行建模，可以提高对复杂文本实例的理解和识别。
6.  **迁移学习|强化学习：** 使用迁移学习或强化学习技术来优化OCR模型，使其能够在不同场景下进行更好的适应和调整。


## OCR 数据集

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4391e558fe404aa790aa4562c608399f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

### 规则数据集

规则数据集
- IIIT5K-Words (IIIT) 2000 for Train; 3000 for Test
- Street View Text (SVT) 257 for Train; 647 for Test
- ICDAR 2003(IC03) 、ICDAR2013 (IC13)
  - 由500张左右英文标注的自然场景图片构成，标注形式为两点水平标注，坐标格式为左上角，和右下角

### 不规则数据集

不规则数据集
- ICDAR2015 (IC15) 4468 for Train; 2077 for Test;
  - 1500张（训练1000，测试500）英文标注的自然场景图片构成，标注形式为四点标注，坐标格式依次为为左上角，右上角，右下角和左下角
- SVT Perspective (SP) 645 for Test
- CUTE80 (CT) 288 for Test

### 合成数据集

SynthText(ST) 5.5million个图像

### 中文场景数据集

中文场景数据集
- Chinese Text in the Wild (CTW)：

CTW数据集是一个针对中文场景文本的数据集，用于文本检测和识别任务。CTW数据集包含了超过40,000张高分辨率的中文场景图像，这些图像从不同来源和环境中获取，具有广泛的多样性。
- ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/049ccb55465341e29073e79c09a20e59~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)


## OCR 模型

### 总结

OCR识别模型
- 评价指标为准确率

|  |  | Regular Dataset | Irregular dataset |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Model | Year | IIIT | SVT | IC13(857) | IC13(1015) | IC15(1811) | IC15(2077) | SVTP | CUTE |  |
| [CRNN](https://ieeexplore.ieee.org/abstract/document/7801919) | 2015 | 78.2 | 80.8 | \- | 86.7 | \- | \- | \- | \- |  |
| [ASTER(L2R)](https://ieeexplore.ieee.org/abstract/document/8395027) | 2015 | 92.67 | 91.16 | \- | 90.74 | 76.1 | \- | 78.76 | 76.39 |  |
| [CombBest](https://openaccess.thecvf.com/content_ICCV_2019/html/Baek_What_Is_Wrong_With_Scene_Text_Recognition_Model_Comparisons_Dataset_ICCV_2019_paper.html) | 2019 | 87.9 | 87.5 | 93.6 | 92.3 | 77.6 | 71.8 | 79.2 | 74 |  |
| [ESIR](https://openaccess.thecvf.com/content_CVPR_2019/html/Zhan_ESIR_End-To-End_Scene_Text_Recognition_via_Iterative_Image_Rectification_CVPR_2019_paper.html) | 2019 | 93.3 | 90.2 | \- | 91.3 | \- | 76.9 | 79.6 | 83.3 |  |
| [SE-ASTER](https://openaccess.thecvf.com/content_CVPR_2020/html/Qiao_SEED_Semantics_Enhanced_Encoder-Decoder_Framework_for_Scene_Text_Recognition_CVPR_2020_paper.html) | 2020 | 93.8 | 89.6 | \- | 92.8 | 80 |  | 81.4 | 83.6 |  |
| [DAN](https://ojs.aaai.org/index.php/AAAI/article/view/6903) | 2020 | 94.3 | 89.2 | \- | 93.9 | \- | 74.5 | 80 | 84.4 |  |
| [RobustScanner](https://link.juejin.cn?target=https%3A%2F%2Flink.springer.com%2Fchapter%2F10.1007%2F978-3-030-58529-7_9 "https://link.springer.com/chapter/10.1007/978-3-030-58529-7_9") | 2020 | 95.3 | 88.1 | \- | 94.8 | \- | 77.1 | 79.5 | 90.3 |  |
| [AutoSTR](https://link.springer.com/content/pdf/10.1007/978-3-030-58586-0_44.pdf) | 2020 | 94.7 | 90.9 | \- | 94.2 | 81.8 | \- | 81.7 | \- |  |
| [Yang et al.](https://www.sciencedirect.com/science/article/abs/pii/S0925231220311176) | 2020 | 94.7 | 88.9 | \- | 93.2 | 79.5 | 77.1 | 80.9 | 85.4 |  |
| [SATRN](https://openaccess.thecvf.com/content_CVPRW_2020/html/w34/Lee_On_Recognizing_Texts_of_Arbitrary_Shapes_With_2D_Self-Attention_CVPRW_2020_paper.html) | 2020 | 92.8 | 91.3 | \- | 94.1 | \- | 79 | 86.5 | 87.8 |  |
| [SRN](https://openaccess.thecvf.com/content_CVPR_2020/html/Yu_Towards_Accurate_Scene_Text_Recognition_With_Semantic_Reasoning_Networks_CVPR_2020_paper.html) | 2020 | 94.8 | 91.5 | 95.5 | \- | 82.7 | \- | 85.1 | 87.8 |  |
| [GA-SPIN](https://arxiv.org/abs/2005.13117) | 2021 | 95.2 | 90.9 | \- | 94.8 | 82.8 | 79.5 | 83.2 | 87.5 |  |
| [PREN2D](https://openaccess.thecvf.com/content/CVPR2021/html/Yan_Primitive_Representation_Learning_for_Scene_Text_Recognition_CVPR_2021_paper.html) | 2021 | 95.6 | 94 | 96.4 | \- | 83 | \- | 87.6 | 91.7 |  |
| [Bhunia et al.](https://openaccess.thecvf.com/content/ICCV2021/html/Bhunia_Joint_Visual_Semantic_Reasoning_Multi-Stage_Decoder_for_Text_Recognition_ICCV_2021_paper.html) | 2021 | 95.2 | 92.2 | \- | 95.5 | \- | **84** | 85.7 | 89.7 |  |
| [Luo et al.](https://link.springer.com/article/10.1007/s11263-020-01411-1) | 2021 | 95.6 | 90.6 | \- | **96.0** | 83.9 | 81.4 | 85.1 | 91.3 |  |
| [VisionLAN](https://openaccess.thecvf.com/content/ICCV2021/html/Wang_From_Two_to_One_A_New_Scene_Text_Recognizer_With_ICCV_2021_paper.html) | 2021 | 95.8 | 91.7 | 95.7 | \- | 83.7 | \- | 86 | 88.5 |  |
| [ABINet](https://openaccess.thecvf.com/content/CVPR2021/html/Fang_Read_Like_Humans_Autonomous_Bidirectional_and_Iterative_Language_Modeling_for_CVPR_2021_paper.html) | 2021 | 96.2 | 93.5 | 97.4 | \- | 86.0 | \- | 89.3 | 89.2 |  |
| [MATRN](https://arxiv.org/abs/2111.15263) | 2021 | **96.7** | **94.9** | **97.9** | **95.8** | **86.6** | 82.9 | **90.5** | **94.1** |  |


## OCR工具

主流OCR识别应用平台
-   百度开放平台:[PaddleOCR](https://github.com/PaddlePaddle/PaddleOCR)
-   商汤科技OpenMMLab : [MMOCR](https://github.com/open-mmlab/mmocr)
-   谷歌开源OCR引擎:[Tesseract](https://github.com/tesseract-ocr/tesseract)

### 简易工具

- 【2021-7-26】免费在线OCR工具 [ocrmaker](http://ocrmaker.com/)
- [UU Tool](https://uutool.cn/ocr/)：截图黏贴图片到网站，提取文本；text转语音
- [城华OCR](https://zhcn.109876543210.com/)，将图片转成各种文档格式，限制次数
- [白描](https://web.baimiaoapp.com/image-to-excel)：提取图片中的文字、数学公式等
- Chrome插件
  - Copyfish Free OCR, 中文支持不佳，手工设置语言后，依然乱码
  - 【2024-2-8】[一键读图(OCR)](https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E8%AF%BB%E5%9B%BEocr/agepkkdokhlaoiaenedmjbfnblfdiboc/related),可识别中文

### 对比总结

【2022-1-25】kaggle笔记：各类OCR方法对比：[Keras-OCR vs EasyOCR vs PYTESSERACT](https://www.kaggle.com/odins0n/keras-ocr-vs-easyocr-vs-pytesseract)
- ![](https://www.kaggleusercontent.com/kf/72864633/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..bibMciKL4OvFX6946nkcFw.H2h7vNPLD0EzD2z6onWrw4R9VV561rtI-O7dAgl4zRkrjH216E96Cg8_ZO6-4Xny6XZL45qeH7xqBdHs7DWKpxJwl6PSES-c3wCDkH1pZifDsjEiIhboIFocwMjIEWDWNFlTY-gafig2CIc9OMmr8Kj2HyhJ_Xmg88Lbsa25dpCF2XkWG6DDLww1eL9wmXE66SzF7sM1_rsUxLvmAplprAQVNPOo2dVSKaGtD5Q1FOD8NvkeRPVeA-MiFGHe8bCtu0paeoX7aPC1z6WzunEsbpGjAeHOWrHXDtYZMPde_Qc77FVe2Qc91b6W_aAYgFoWuehxHKhOgp-jtcSA8cr_UocTj3chqBQgJKkwFodQdZInVeknz7L1HA9IGJgpWEy8DPZcNjhNuXgoWqpjqJLslljIJa-8N3Dy3qqu5p8Ku54YnzDSak2rMgdn_ThhC5AtDM3_7aB_s6vI4LoeVFxYTJ4JLVyw3v_YqIOe1BG7qD-QN2bqZixhJvtajOYzllcLP21NqMesuo7dHa-favmNVYo6o9zirwLvyYFrW4z0BpdBGkf_nQ_6n452u6GMiaRwmpNgNpD3zVv1BRCNbvMrJyzm5Mb7iqmedml2Yi6NFMxEgyOvb6rclteSyWU8_CMhP0bl3KGxEgeqNSD9Z02teSGWd9Gl8Nb6F9SByo90TtEZPJy7kIpa9Y9VPHwV7JAD.PtUtOX_gh2gJUMvxM9Wyvw/__results___files/__results___14_1.png)

CONCLUSIONS 对比结论
* **Keras-OCR** is image specific OCR tool. If text is inside the image and their fonts and colors are unorganized, Keras-ocr consumes time if used on CPU 
* **EasyOCR** is lightweight model which is giving a good performance for receipt or PDF conversion. It is giving more accurate results with organized texts like pdf files, receipts, bills. EasyOCR also performs well on noisy images 适合发票、pdf格式、噪声图片
* **Pytesseract** is performing well for **high-resolution** images. Certain morphological operations such as dilation, erosion, OTSU binarization can help increase pytesseract performance. It also provides better results on handwritten text as compared to EasyOCR 适合高分辨率图、手写字体
* All these results can be further improved by performing specific image operations.



### Tesseract

- Tesseract 的OCR引擎最先由HP实验室于1985年开始研发，至1995年时已经成为OCR业内最准确的三款识别引擎之一。
- Tesseract 目前已作为开源项目发布在Google Project，其最新版本3.0已经支持中文OCR，并提供了一个命令行工具。

安装：
- pip install pytesseract

调用代码

```python
import cv2                        # OpenCV: Computer vision and image manipulation package
import pytesseract                # python Tesseract: OCR in python
import matplotlib.pyplot as plt   # plotting
import numpy as np                # Numpy for arrays
from PIL import Image             # Pillow: helps us read remote images
import requests                   # Requests: to fetch remote URLs
from io import BytesIO            # Helps read remote images

def get_image(url):
  response = requests.get(url)
  img = Image.open(BytesIO(response.content))
  return img

img = get_image('https://github.com/jalammar/jalammar.github.io/raw/master/notebooks/cv/label.png')
# OCR结果
print(pytesseract.image_to_string(img))
```

### EasyOCR

【2020-8-7】[一个超好用的开源OCR](https://www.toutiao.com/i6858234401206043140/?tt_from=mobile_qq&utm_campaign=client_share&timestamp=1596809559&app=news_article&utm_source=mobile_qq&utm_medium=toutiao_android&use_new_style=1&req_id=20200807221239010147083076216022E3&group_id=6858234401206043140)：[EasyOCR](https://github.com/JaidedAI/EasyOCR)，目前能够支持58种语言，其中有中文(简体和繁体)、日语、泰语、韩语等
- EasyOCR的模型主要分为两个，基于CRAFT的文字检测模型和基于ResNet+LSTM+CTC的识别模型
- ![](http://p6-tt.byteimg.com/large/pgc-image/2402e44dff954e4985f6762de5b07ce6?from=pc)
- 第三方基于easyOCR提供了几个demo地址，大家可以试试自己的数据看看效果：
  - [Demo1](https://colab.fan/easyocr)
  - [Demo2](https://hub.docker.com/r/challisa/easyocr)
  - [Demo3](https://easyocrgpu-wook-2.endpoint.ainize.ai/)
  - ![](http://p3-tt.byteimg.com/large/pgc-image/a56400ef928d419c8ef29c64abede5da?from=pc)

OCR 框架
- ![](https://github.com/JaidedAI/EasyOCR/raw/master/examples/easyocr_framework.jpeg)

实践
- 【2023-9-15】不支持中国银行卡，以国外为主

```py
# pip install easyocr
# pip install git+https://github.com/JaidedAI/EasyOCR.git
import easyocr
reader = easyocr.Reader(['ch_sim','en']) # this needs to run only once to load the model into memory
result = reader.readtext('chinese.jpg')
result = reader.readtext('chinese.jpg', detail = 0) # 精简输出
result
```

命令行方式

```sh
easyocr -l ch_sim en -f chinese.jpg --detail=1 --gpu=True
```


### Pix2Text

【2022-9-21】[Pix2Text: 替代 Mathpix 的免费 Python 开源工具](https://www.toutiao.com/article/7145465980930556450)
- [Pix2Text](https://github.com/breezedeus/pix2text) 期望成为 Mathpix 的免费开源 Python 替代工具，完成与 Mathpix 类似的功能。当前 Pix2Text 可识别截屏图片中的数学公式、英文、或者中文文字。
- ![](https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/a81b8f2c95794d0596a1d7b803df2a34~noop.image?_iz=58558&from=article.pc_detail&x-expires=1664345981&x-signature=1blBfmn0jnAV0%2FOB5VuIKt1Jd3Q%3D)

Pix2Text首先利用图片分类模型来判断图片类型，然后基于不同的图片类型，把图片交由不同的识别系统进行文字识别：
- 如果图片类型为 **formula** ，表示图片为数学公式，此时调用 LaTeX-OCR 识别图片中的数学公式，返回其Latex表示；
- 如果图片类型为 **english**，表示图片中包含的是英文文字，此时使用 CnOCR (https://github.com/breezedeus/cnocr) 中的英文模型识别其中的英文文字；英文模型对于纯英文的文字截图，识别效果比通用模型好；
- 如果图片类型为 **general**，表示图片中包含的是常见文字，此时使用 CnOCR 中的通用模型识别其中的中或英文文字。


```python
#pip install pix2text -i https://pypi.doubanio.com/simple
from pix2text import Pix2Text

img_fp = './docs/examples/formula.jpg'
p2t = Pix2Text()
out_text = p2t(img_fp)  # 也可以使用 `p2t.recognize(img_fp)` 获得相同的结果
print(out_text)
```


### 中文OCR比赛第一

【2022-1-25】[第一次比赛，拿了世界人工智能大赛 Top1 ！](https://blog.csdn.net/Datawhale/article/details/122613233)，“世界人工智能创新大赛”——手写体 OCR 识别竞赛（任务一），取得了Top1的成绩
- [赛题地址](http://ailab.aiwin.org.cn/competitions/65)
- 背景：银行日常业务中涉及到各类凭证的识别录入，例如身份证录入、支票录入、对账单录入等。以往的录入方式主要是以人工录入为主，效率较低，人力成本较高。近几年来，OCR相关技术以其自动执行、人为干预较少等特点正逐步替代传统的人工录入方式。但OCR技术在实际应用中也存在一些问题，在各类凭证字段的识别中，手写体由于其字体差异性大、字数不固定、语义关联性较低、凭证背景干扰等原因，导致OCR识别率准确率不高，需要大量人工校正，对日常的银行录入业务造成了一定的影响
- 数据集：原始手写体图像共分为三类，分别涉及银行名称、年月日、金额三大类，分别示意如下：
  - ![](https://img-blog.csdnimg.cn/img_convert/4cfda26453767dec3b2d436540d3c6b8.png)
- 相应图片切片中可能混杂有一定量的干扰信息
  - ![](https://img-blog.csdnimg.cn/img_convert/cd77146fdad3c8b41f455b2992a6b784.png)

OCR比赛最常用的模型是 CRNN + CTC，选择代码：Attention_ocr.pytorch-master.zip

模型改进：crnn的卷积部分类似VGG，我对模型的改进主要有一下几个方面：
- 1、加入激活函数Swish。
- 2、加入BatchNorm。
- 3、加入SE注意力机制。
- 4、适当加深模型。

```python
self.cnn = nn.Sequential(
   nn.Conv2d(nc, 64, 3, 1, 1), Swish(), nn.BatchNorm2d(64),
   nn.MaxPool2d(2, 2),  # 64x16x50
   nn.Conv2d(64, 128, 3, 1, 1), Swish(), nn.BatchNorm2d(128),
   nn.MaxPool2d(2, 2),  # 128x8x25
   nn.Conv2d(128, 256, 3, 1, 1), nn.BatchNorm2d(256), Swish(),  # 256x8x25
   nn.Conv2d(256, 256, 3, 1, 1), nn.BatchNorm2d(256), Swish(),  # 256x8x25
   SELayer(256, 16),
   nn.MaxPool2d((2, 2), (2, 1), (0, 1)),  # 256x4x25
   nn.Conv2d(256, 512, 3, 1, 1), nn.BatchNorm2d(512), Swish(),  # 512x4x25
   nn.Conv2d(512, 512, 1), nn.BatchNorm2d(512), Swish(),
   nn.Conv2d(512, 512, 3, 1, 1), nn.BatchNorm2d(512), Swish(),  # 512x4x25
   SELayer(512, 16),
   nn.MaxPool2d((2, 2), (2, 1), (0, 1)),  # 512x2x25
   nn.Conv2d(512, 512, 2, 1, 0), nn.BatchNorm2d(512), Swish()
)  # 512x1x25
# SE和Swish
class SELayer(nn.Module):
    def __init__(self, channel, reduction=16):
        super(SELayer, self).__init__()
        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.fc = nn.Sequential(
            nn.Linear(channel, channel // reduction, bias=True),
            nn.LeakyReLU(inplace=True),
            nn.Linear(channel // reduction, channel, bias=True),
            nn.Sigmoid()
        )

    def forward(self, x):
        b, c, _, _ = x.size()
        y = self.avg_pool(x).view(b, c)
        y = self.fc(y).view(b, c, 1, 1)
        return x * y.expand_as(x)

class Swish(nn.Module):
    def forward(self, x):
        return x * torch.sigmoid(x)
```

### META Nougat

【2023-8-30】Meta推出OCR神器，PDF、数学公式都能转[Nougat](https://www.toutiao.com/article/7272995038735630905)

存储在 PDF 等文件中的信息很难转成其他格式，尤其对数学公式更是显得无能为力，因为转换过程中很大程度上会丢失信息。

[Nougat](https://facebookresearch.github.io/nougat/) 基于 Transformer 模型构建而成，可以轻松的将 PDF 文档转换为 MultiMarkdown，扫描版的 PDF 也能转换，让人头疼的数学公式也不在话下。
- 论文[地址](https://arxiv.org/pdf/2308.13418v1.pdf)
- 项目[主页](https://facebookresearch.github.io/nougat)

2 个 Swin Transformer ，一个参数量为 350M，可处理的序列长度为 4096，另一参数量为 250M，序列长度为 3584。在推理过程中，使用贪婪解码生成文本。


## 验证码识别

- 验证码是一种区分用户是计算机还是人的公共全自动程序。可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式。由于验证码可以由计算机生成并评判，但是必须只有人类才能解答，所以回答出问题的用户就可以被认为是人类。
- 目前的验证码通常的种类及特点如下：
   - （1）最基础的英文验证码：纯粹的英文与数字组合，白色背景，这是最容易实现OCR识别的验证码。
   - （2）字体变形的英文验证码：可以通过简单的机器学习实现对英文与数字的识别，准确率较高。
   - （3）加上扰乱背景线条的验证码：可以通过程序去除干扰线，准确率较高。
   - （4）中文验证码：中文由于字体多样，形状多变，数量组合众多，实现起来难度较大，准确率不高。
   - （5）中文字体变形验证码：准确率更低。
   - （6）中英文混合验证码：非常考验OCR程序的判断能力，基本上识别起来非常有难度。
   - （7）提问式验证码：这是需要OCR结合人工智能才能实现，目前基本上无法识别。
   - （8）GIF动态图验证码：由于GIF图片是动态图，无法定位哪一帧是验证码，所以难度很大。
   - （9）划动式验证码：虽然程序可以模拟人的操作，但是具体拖动到哪个位置很难处理。
   - （10）视频验证码：目前OCR识别还未实现。
   - （11）手机验证码：手机验证码实现自动化是很容易的，但是手机号码不那么容易获得。
   - （12）印象验证码：目前无解。

![](https://pic1.zhimg.com/80/v2-2b9748a5ca5498ba1955eec9a5b79db4_720w.jpg)

- 附录：
   - [利用Tesseract-OCR实现验证码识别](https://zhuanlan.zhihu.com/p/34530032)

- 「Happy Captcha」，一款易于使用的 Java 验证码软件包，旨在花最短的时间，最少的代码量，实现 Web 站点的验证码功能。
   - Captcha缩写含义：Completely Automated Public Turing test to tell Computers and Humans Apart
- 效果图
   - ![](https://pic3.zhimg.com/v2-971f594800cdd101950f916f92cb7b1e_b.webp)

## GAN方法

【2018-12-14】[基于GAN的验证码识别工具，0.5秒宣告验证码死刑！](https://baijiahao.baidu.com/s?id=1619803729564462538)
- 中英两国研究人员联合开发了一套基于GAN的验证码AI识别系统，能在0.5秒之内识别出验证码，从 实际测试结果看，可以说宣布了对验证码的“死刑判决”。
  - ![](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=280512761,907748494&fm=173&app=49&f=JPEG?w=640&h=273&s=0D30E51281D85DC04A55B0CB0000D0B3)
  - [论文地址](http://www.lancaster.ac.uk/staff/wangz3/publications/ccs18.pdf)，博文介绍：[An A.I. cracks the internet’s squiggly letter bot test in 0.5 seconds](https://www.digitaltrends.com/cool-tech/ai-cracks-captcha-05-seconds/)
- 该系统已在不同的33个验证码系统中进行了成功测试，其中11个来自世界上最受欢迎的一些网站，包括eBay和维基百科等。
- 这种方法的新颖之处在于：使用生成对抗网络（GAN）来创建训练数据。不需要收集和标记数以百万计的验证码文本数据，只需要500组数据就可以成功学习。而且可以使用这些数据，来生成数百万甚至数十亿的合成训练数据，建立高性能的图像分类器。
- 结果显示，<font color='red'>该系统比迄今为止所见的任何验证码识别器系统的识别精度都高。</font>
- ![](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1299396691,4195542946&fm=173&app=49&f=JPEG?w=640&h=416&s=A498E633795644CA4A6580DA0000C0B3)


## 扩散模型

详见：[图像生成专题](image-generation)


# 风格迁移

- [深度学习之风格迁移简介](http://melonteam.com/posts/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/)

`风格迁移`（style transfer）最近两年非常火，可谓是深度学习领域很有创意的研究成果。它主要是通过神经网络，将一幅艺术风格画（style image）和一张普通的照片（content image）巧妙地融合，形成一张非常有意思的图片。

![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/4a0dbd0ba7031a2b9e0f97d222d5050799764b92b7b135ffba3edfda4fd2feea)

因为新颖而有趣，自然成为了大家研究的焦点。目前已经有许多基于风格迁移的应用诞生了，如移动端风格画应用Prisma，手Q中也集成了不少的风格画滤镜：

![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/de7624d2c5163daeb833b4a4a4d4bbbf340fbc2a8289763833f8de2608f89b9c)

对风格迁移的实现原理进行下简单介绍，然后介绍下它的快速版，即fast-style- transfer[^2]。

[图像风格迁移(Neural Style)简史](https://zhuanlan.zhihu.com/p/26746283)

图像风格迁移科技树
- ![](https://pic4.zhimg.com/80/v2-526f16430324d3fbd8c07ff3d1c05c0b_hd.jpg)

## 风格化Demo

- 【2021-5-11】[案例解析：用Tensorflow和Pytorch计算骰子值](https://www.toutiao.com/i6622845628902801933/)
  - ![](https://p6-tt.byteimg.com/origin/pgc-image/557db089145144b5a7ae5195cf6d4aef?from=pc)，[github](https://github.com/sugi-chan/2-stage-dice-pipeline)
- 【2020-12-04】AI姿势传递模型，[论文地址](https://arxiv.org/pdf/2012.01158.pdf)，不愿意出节目的码农的年会神器？[将舞蹈化为己用-视频](https://weibo.com/tv/show/1034:4578074625245199?from=old_pc_videoshow)
- 【2020-12-02】【MaskDetection：滴滴开源的口罩检测模型】 by DiDi [GitHub](https://github.com/didi/maskdetection)
- 【2020-12-04】[孪生网络用于图片搜索](https://www.pyimagesearch.com/2020/11/30/siamese-networks-with-keras-tensorflow-and-deep-learning/)《Siamese networks with Keras, TensorFlow, and Deep Learning - PyImageSearch》by Adrian Rosebrock
  - ![](https://www.pyimagesearch.com/wp-content/uploads/2020/11/keras_siamese_networks_header.png)
- 【2022-10-8】北大博士的图像、视频风格化展示：[williamyang1991](https://williamyang1991.github.io/)，还有[文本字体风格化](https://williamyang1991.github.io/project.html#research1)


【2022-11-25】图像风格化工具
- ① [Image to Sketch AI](https://imagetosketch.com/)，caricature漫画；素描
- ② [newprofilepic](https://newprofilepic.com/)，多种风格可选
- ③ [AnimeGANv2](https://huggingface.co/spaces/akhaliq/AnimeGANv2)，卡通画，hugging face上

【2022-1-25】[5个方便好用的Python自动化脚本](https://www.toutiao.com/i7056585992664269344)

### 素描风格

自动生成素描草图
- 这个脚本可以把彩色图片转化为铅笔素描草图，对人像、景色都有很好的效果。而且只需几行代码就可以一键生成，适合批量操作，非常的快捷。

第三方库：
- Opencv - 计算机视觉工具，可以实现多元化的图像视频处理，有Python接口

安装

```shell
# 安装opencv的Python库
pip install opencv-python
```

示例

```python
""" Photo Sketching Using Python """
import cv2

img = cv2.imread("elon.jpg")
## Image to Gray Image
gray_image = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
## Gray Image to Inverted Gray Image
inverted_gray_image = 255-gray_image
## Blurring The Inverted Gray Image
blurred_inverted_gray_image = cv2.GaussianBlur(inverted_gray_image, (19,19),0)
## Inverting the blurred image
inverted_blurred_image = 255-blurred_inverted_gray_image
### Preparing Photo sketching
sketck = cv2.divide(gray_image, inverted_blurred_image,scale= 256.0)
cv2.imshow("Original Image",img)
cv2.imshow("Pencil Sketch", sketck)
cv2.waitKey(0)
```

素描草图：马斯克
- ![](https://p26.toutiaoimg.com/origin/tos-cn-i-qvj2lq49k0/8c5a6fdc6274477ca9e3b85990f6942f?from=pc)


### fast-style

- 图像风格迁移，[深度学习之风格迁移简介](http://melonteam.com/posts/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/)
- ![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/5489df3b2f1d117cbd275724697edda9ccadb0e92ba6d7c40dfb19c465378e01)
- Fast style transfer check [demo](https://wqw547243068.github.io/demo/fast-style/)

![alt text](https://raw.githubusercontent.com/zaidalyafeai/zaidalyafeai.github.io/master/images/fast-style.PNG)

### 风格化案例

- 【2019-07-19】[图像风格迁移示例](https://reiinakano.github.io/arbitrary-image-stylization-tfjs)

<iframe src="https://reiinakano.github.io/arbitrary-image-stylization-tfjs" scrolling="yes" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width='800' height='600'> </iframe>

### Real Time style transfer 实时风格迁移

Real Time style transfer check [demo](https://wqw547243068.github.io/demo/RST/)
- ![alt text](https://raw.githubusercontent.com/zaidalyafeai/zaidalyafeai.github.io/master/images/rst.png)


## 1. 风格迁移开山之作

2015年，Gatys等人发表了文章[^1]《A Neural Algorithm of Artistic Style》，首次使用深度学习进行艺术画风格学习。把风格图像Xs的绘画风格融入到内容图像Xc，得到一幅新的图像Xn。则新的图像Xn：即要保持内容图像Xc的原始图像内容（内容画是一部汽车，融合后应仍是一部汽车，不能变成摩托车），又要保持风格图像Xs的特有风格（比如纹理、色调、笔触等）。

### 1.1 内容损失（Content Loss）

在CNN网络中，一般认为较低层的特征描述了图像的具体视觉特征（即纹理、颜色等），较高层的特征则是较为抽象的图像内容描述。 所以要比较两幅图像的内容相似性，可以比较两幅图像在CNN网络中高层特征的相似性（欧式距离）。

![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/880c6f8c21936bb4c29a2e6952ce357f7e844e7328c86f2a730f500768e66802)

### 1.2 风格损失（Style Loss）

而要比较两幅图像的风格相似性，则可以比较它们在CNN网络中较低层特征的相似性。不过值得注意的是，不能像内容相似性计算一样，简单的采用欧式距离度量，因为低层特征包含较多的图像局部特征（即空间信息过于显著），比如两幅风格相似但内容完全不同的图像，若直接计算它们的欧式距离，则可能会产生较大的误差，认为它们风格不相似。论文中使用了Gram矩阵，用于计算不同响应层之间的联系，即在保留低层特征的同时去除图像内容的影响，只比较风格的相似性。

![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/bc72f7cd6be684f73c7c7e3649dbba4b030bb2607c66370104e043c71b2ac31c)

那么风格的相似性计算可以用如下公式表示：

![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/1a7ce05010b913ae2c5f58ef362aa76638199c79293f493856feb80d99703476)

![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/eff0adf1fd4b183cb872d79e2a5a70ca66d6d21845a59bbf6faf31012532be3a)

### 1.3 总损失（Total Loss）

这样对两幅图像进行“内容+风格”的相似度评价，可以采用如下的损失函数：
- ![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/3d679c5b0a174e93a56eba66383e6abd57431c24e76805f0fdcf8d7caa3d89ef)

### 1.4 训练过程

文章使用了著名的VGG19网络[3]来进行训练（包含16个卷积层和5个池化层，但实际训练中未使用任何全连接层，并使用平均池化average- pooling替代最大池化max-pooling）。
- ![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/3f981ef8277f3d56dbc0dfb8cb9fb38bbcf6c35914f8bc3e53fda29ac2eed6f6)

内容层和风格层的选择：将`内容图像`和`风格图像`分别输入到VGG19网络中，并将网络各个层的特征图（feature map）进行可视化（重构）。

内容重构五组对比实验：
- 1. conv1_1 (a)
- 2. conv2_1 (b)
- 3. conv3_1 (c)
- 4. conv4_1 (d)
- 5. conv5_1 (e)
风格重构五组对比实验：
- 1. conv1_1 (a)
- 2. conv1_1 and conv2_1 (b) 
- 3. conv1_1, conv2_1 and conv3_1 (c)
- 4. conv1_1, conv2_1, conv3_1 and conv4_1 (d)
- 5. conv1_1, conv2_1, conv3_1, conv4_1 and conv5_1 (e)

通过实验发现：对于内容重构，(d)和(e)较好地保留了图像的高阶内容（high-level content）而丢弃了过于细节的像素信息；对于风格重构，(e)则较好地描述了艺术画的风格。如下图红色方框标记：
- ![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/44a2b217d7d007c6110d5248c90ccf0f66c6296f320954668d73c1af6b0d5fa7)

在实际实验中，内容层和风格层选择如下：
- 内容层：conv4_2
- 风格层：conv11, conv2_1, conv3__1_, _conv4_1, conv5_1
- 训练过程：以白噪声图像作为输入(x)到VGG19网络，conv4_2层的响应与原始内容图像计算出内容损失（Content Loss），“conv1_1, conv2_1, conv3_1, conv4_1, conv5_1”这5层的响应分别与风格图像计算出风格损失，然后它们相加得到总的风格损失（Style Loss），最后Content Loss + Style Loss = Total Loss得到总的损失。采用梯度下降的优化方法求解Total Loss函数的最小值，不断更新x，最终得到一幅“合成画”。

### 1.5 总结

每次训练迭代，更新的参数并非VGG19网络本身，而是随机初始化的输入x；
由于输入x是随机初始化的，最终得到的“合成画”会有差异；
每生成一幅“合成画”，都要重新训练一次，速度较慢，难以做到实时。

## 2. 快速风格迁移

2016年Johnson等人提出了一种更为快速的风格迁移方法[2]《[Perceptual losses for real-time style transfer and super- resolution](http://cs.stanford.edu/people/jcjohns/papers/eccv16/JohnsonECCV16.pdf)》。

### 2.1 网络结构
它们设计了一个变换网络（Image Transform Net），并用VGG16网络作为损失网络（Loss Net）。输入图像经由变换网络后，会得到一个输出，此输出与风格图像、内容图像分别输入到VGG16损失网络，类似于[1]的思路，使用VGG16不同层的响应结果计算出内容损失和风格损失，最终求得总损失。然后使用梯度下降的优化方法不断更新变换网络的参数。 
- 内容层：relu3_3
- 风格层：relu12, relu2_2, relu3_3, _relu4_3
其中变换网络（Image Transform Net）的具体结构如下图所示： 

![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/bea3e1a19df5198b9a31f7d241361cb129f13e0d0d5f4f4e0d14439d6d0b8126)

### 2.2 跑个实验

Johnson等人将论文的代码实现在[github](https://github.com/jcjohnson/fast-neural-style)上进行了开源，包括了论文的复现版本，以及将“Batch-Normalization ”改进为“Instance Normalization”[[4](https://arxiv.org/pdf/1607.08022.pdf)]的版本。咱们可以按照他的说明，训练一个自己的风格化网络。我这里训练了一个“中国风”网络，运行效果如下： 
- ![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/5489df3b2f1d117cbd275724697edda9ccadb0e92ba6d7c40dfb19c465378e01)
- ![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/c628d678344dddaef81c122d33fcff1cd00d1d7f2b90834410492ae03bf005d4)

### 2.3 总结

网络训练一次即可，不像Gatys等人[1]的方法需要每次重新训练网络；
可以实现实时的风格化滤镜：在Titan X GPU上处理一张512x512的图片可以达到20FPS。下图为fast-style-transfer与Gatys等人[1]方法的运行速度比较，包括了不同的图像大小，以及Gatys方法不同的迭代次数。

![](http://melonteam.com/image/shen_du_xue_xi_zhi_feng_ge_qian_yi_jian_jie/66b64458ff003281762ca3b3da2a7ad3e769b6274259431e2dbd82f9fd5543dd)

3. 参考资料

- Gatys L A, Ecker A S, Bethge M. A neural algorithm of artistic style[J]. arXiv preprint arXiv:1508.06576, 2015.
- Johnson J, Alahi A, Fei-Fei L. Perceptual losses for real-time style transfer and super-resolution[C]//European Conference on Computer Vision. Springer International Publishing, 2016: 694-711.
- Simonyan K, Zisserman A. Very deep convolutional networks for large-scale image recognition[J]. arXiv preprint arXiv:1409.1556, 2014.
- Ulyanov D, Vedaldi A, Lempitsky V. Instance normalization: The missing ingredient for fast stylization[J]. arXiv preprint arXiv:1607.08022, 2016.
- [Fast Style Transfer(快速风格转移)](http://closure11.com/fast-style-transfer%E5%BF%AB%E9%80%9F%E9%A3%8E%E6%A0%BC%E8%BD%AC%E7%A7%BB/)
- [图像风格迁移(Neural Style)简史](https://zhuanlan.zhihu.com/p/26746283)

## 应用案例

### 水印

【2023-9-21】花费好多时间来弄，最后却被别人直接搬运过去使用，好气哦！
- 怎么办？ 给图片加水印

方法
- 工具：
  - [制作图](https://www.zhizuotu.com/mshuiyin)
  - [iloveimg](https://www.iloveimg.com/zh-cn/watermark-image)
- 代码：

Python代码
- filestools 库一共集成了4个功能，4个库都已经全部迁移到了filestools库中

add_mark()方法一共有8个参数
-   **file：** 待添加水印的照片；
-   **mark：** 使用哪些字作为水印；
-   **out：** 添加水印后保存的位置；
-   **color：** 水印字体的颜色，默认颜色#8B8B1B；
-   **size：** 水印字体的大小，默认50；
-   **opacity：** 水印字体的透明度，默认0.15；
-   **space：** 水印字体之间的间隔, 默认75个空格；
-   **angle：** 水印字体的旋转角度，默认30度；接下来，我们仅用一行代码，给图片添加水印。

```py
# pip install filestools --index-url=http://mirrors.aliyun.com/pypi/simple -U
# 给图片加水印
from watermarker.marker import add_mark
# add_mark()方法一共有8个参数
add_mark(file=r"aixin.jpg", out=r"out.jpg", mark="人生苦短，快学Python", opacity=0.2, angle=45, space=30)
```

### 杂货店货架识别

- 【2021-1-23】[Grocery-Product-Detection](https://github.com/sayakpaul/Grocery-Product-Detection)
  - This repository builds a product detection model to recognize products from grocery shelf images. The dataset comes from [here](https://github.com/gulvarol/grocerydataset). Everything from data preparation to model training is done using [Colab Notebooks](https://colab.research.google.com/) so that no setup is required locally. All the relevant commentaries have been included inside the Colab Notebooks.

### 图片美化

【2023-4-18】[autoenhance](https://www.autoenhance.ai/#demo-video), Instant real estate photo editing, 房产领域图片美化：更换天气（阴天→蓝天）、对比度（模糊→清晰）、马赛克（模糊人脸/车牌）、角度调整（视角）、光线（暗→明）


### AI换脸

【2023-5-25】AI换脸诈骗
- [“AI诈骗正在全国爆发” AI技术让诈骗成功率接近100%](https://www.toutiao.com/video/7236615070271229240)
- [AI换脸诈骗正在全国上演，和你视频的可能不是本人](https://www.toutiao.com/video/7236732469452541241)

## 资料

- 更多[Demo地址](http://wqw547243068.github.io/demo)



# 结束